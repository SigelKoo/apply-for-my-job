# 简述HTTPS的加密与认证过程

## HTTPS流程

![img](https://img-blog.csdn.net/20180622174607442?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE3Nzk3MjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20180622174627696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE3Nzk3MjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## SSL/TLS

SSL/TLS是位于TCP/IP 7层协议中的会话层，用于认证用户和服务器，加解密数据以及维护数据的完整性，确保数据在传输过程中不会被修改。

![img](https://img2018.cnblogs.com/blog/614799/201907/614799-20190705202036384-404909701.png)

TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。

### 对称加密

对称加密是指加密和解密都用同一份密钥。例：AES/DES。

### 非对称加密

非对称加密对应于一对密钥，称为私钥和公钥，用私钥加密后需要用公钥解密，用公钥加密后需要用私钥解密。

- RSA可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在 1024 已经不安全，普遍认为至少要 2048 位。
- ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。

### 摘要算法

实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。

摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。

不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。

所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。叫哈希消息认证码（HMAC）。

![img](https://img2020.cnblogs.com/blog/916005/202110/916005-20211009160459390-593004452.png)

### 数字证书和 CA

这里还有一个“公钥的信任”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢？

这个“第三方”就是我们常说的 CA（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”

知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。

DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。

这还是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。

有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。

## HTTPS 建立连接

当你在浏览器地址栏里键入“https”开头的 URI，再按下回车，会发生什么呢？

浏览器首先要从 URI 里提取出协议名和域名。因为协议名是“https”，所以浏览器就知道了端口号是默认的 443，它再用 DNS 解析域名，得到目标的 IP 地址，然后就可以使用三次握手与网站建立 TCP 连接了。

在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。

这个“握手”过程与 TCP 有些类似，是 HTTPS 和 TLS 协议里最重要、最核心的部分，懂了它，你就可以自豪地说自己“掌握了 HTTPS”。

## TLS 协议的组成

TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有**记录协议、警报协议、握手协议、变更密码规范协议**等。

- 记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。
- 警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。
- 握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。
- 最后一个是变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。

![SSL结构](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/SSL%E7%BB%93%E6%9E%84.png)

## SSL原理

![协商过程](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E5%8D%8F%E5%95%86%E8%BF%87%E7%A8%8B.png)

在用SSL进行通信之前，首先要使用SSL的Handshake协议在通信两端握手，协商数据传输中要用到的相关安全参数（如加密算法、共享密钥、产生密钥所要的材料等），并对对端的身份进行验证。

### SSL建立第一阶段

客户端首先发送ClientHello消息到服务端，服务端收到ClientHello消息后，再发送ServerHello消息回应客户端。

![第一阶段](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.png)

#### ClientHello

握手第一步是客户端向服务端发送 ClientHello 消息，这个消息里包含了一个客户端生成的随机数 **Random1**、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。

![ClientHello](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ClientHello.png)

ClientHello中涉及到的消息具体如下：

- **客户端版本**

  按优先级列出客户端支持的协议版本，首选客户端希望支持的最新协议版本。

- **客户端随机数Random**

- **会话ID（Session id）**

  如果客户端第一次连接到服务器，那么这个字段就会保持为空。上图中该字段为空，说明这是第一次连接到服务器。

  如果该字段不为空，说明以前是与服务器有连接的，在此期间，服务器将使用Session ID映射对称密钥，并将Session ID存储在客户端浏览器中，为映射设置一个时间限。如果浏览器将来连接到同一台服务器（在时间到期之前），它将发送Session ID，服务器将对映射的Session ID进行验证，并使用以前用过的对称密钥来恢复Session，这种情况下不需要完全握手。**也叫作SSL会话恢复**。后面会有介绍。

- **加密套件**

  客户端会给服务器发送自己已经知道的密码套件列表，这是由客户按优先级排列的，但完全由服务器来决定发送与否。TLS中使用的密码套件有一种标准格式。上面的报文中，客户端发送了74套加密套件。服务端会从中选出一种来作为双方共同的加密套件。

- **压缩方法**

  为了减少带宽，可以进行压缩。但从成功攻击TLS的事例中来看，其中使用压缩时的攻击可以捕获到用HTTP头发送的参数，这个攻击可以劫持Cookie，这个漏洞我们称为CRIME。**从TLS 1.3开始，协议就禁用了TLS压缩。**

- **扩展包**

  其他参数（如服务器名称，填充，支持的签名算法等）可以作为扩展名使用。

  这些是客户端问候的一部分，如果已收到客户端问候，接下来就是服务器的确认，服务器将发送服务器问候。

#### ServerHello

收到**客户端问候**之后服务器必须发送**服务器问候**信息，服务器会检查指定诸如TLS版本和算法的客户端问候的条件，如果服务器接受并支持所有条件，它将发送其证书以及其他详细信息，否则，服务器将发送握手失败消息。

如果接受，第二步是服务端向客户端发送 ServerHello 消息，这个消息会从 ClientHello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 **Random2**。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。

![ServerHello](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ServerHello.png)

ServerHello中涉及到的具体参数：

- **服务器版本Version**

  服务器会选择客户端支持的最新版本。

- **服务器随机数Random**

  服务器和客户端都会生成32字节的随机数。用来创建加密密钥。

- **加密套件**

  服务器会从客户端发送的加密套件列表中选出一个加密套件。

- **会话ID（Session ID）**

  服务器将约定的Session参数存储在TLS缓存中，并生成与其对应的Session id。它与ServerHello一起发送到客户端。客户端可以写入约定的参数到此Session id，并给定到期时间。客户端将在ClientHello中包含此id。如果客户端在此到期时间之前再次连接到服务器，则服务器可以检查与Session id对应的缓存参数，并重用它们而无需完全握手。这非常有用，因为服务器和客户端都可以节省大量的计算成本。

  在涉及亚马逊和谷歌等流量巨大的应用程序时，这种方法存在缺点。每天都有数百万人连接到服务器，服务器必须使用Session密钥保留所有Session参数的TLS缓存。这是一个巨大的开销。

  为了解决这个问题，在扩展包里加入了**Session Tickets**, 在这里，客户端可以在client hello中指定它是否支持Session Ticket。然后，服务器将创建一个**新的会话票证(Session Ticket)**，并使用只有服务器知道的经过私钥加密的Session参数。它将存储在客户端上，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。

  此数据可以作为名为Session Ticket的扩展包含在Client Hello中。

- **压缩算法**

  如果支持，服务器将同意客户端的首选压缩方法。

- **扩展包**

这个阶段之后，客户端服务端知道了下列内容：

1. SSL版本
2. 密钥交换、信息验证和加密算法
3. 压缩方法
4. 有关密钥生成的两个随机数。

### SSL建立第二阶段

服务器向客户端发送消息。

![第二阶段](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5.png)

服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：

1. 证书：服务器将数字证书和到根CA整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。
2. 服务器密钥交换（可选）：这里视密钥交换算法而定
3. 证书请求：服务端可能会要求客户自身进行验证。
4. 服务器握手完成：第二阶段的结束，第三阶段开始的信号

#### Certificate消息（可选）——第一次建立必须要有证书

一般情况下，除了会话恢复时不需要发送该消息，在SSL握手的全流程中，都需要包含该消息。消息包含一个X.509证书，证书中包含公钥，发给客户端用来验证签名或在密钥交换的时候给消息加密。

这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。

![证书](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E8%AF%81%E4%B9%A6.png)

#### **Server Key Exchange（可选）**

根据之前在ClientHello消息中包含的CipherSuite信息，决定了密钥交换方式（例如RSA或者DH），因此在Server Key Exchange消息中便会包含完成密钥交换所需的一系列参数。

![serverKeyExchange](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/serverKeyExchange.png)

因为这里是DH算法，所以需要发送服务器使用的DH参数。RSA算法不需要这一步。

> 在Diffie-Hellman中，客户端无法自行计算预主密钥；双方都有助于计算它，因此客户端需要从服务器获取Diffie-Hellman公钥。
>
> 由上图可知，此时密钥交换也由签名保护。

#### Certificate Request（可选）——可以是单向的身份认证，也可以双向认证

这一步是可选的，如果在对安全性要求高的常见可能用到。服务器用来验证客户端。服务器端发出Certificate Request消息，要求客户端发他自己的证书过来进行验证。该消息中包含服务器端支持的证书类型（RSA、DSA、ECDSA等）和服务器端所信任的所有证书发行机构的CA列表，客户端会用这些信息来筛选证书。

#### Server Hello Done

该消息表示服务器已经将所有信息发送完毕，接下来等待客户端的消息。

![ServerHelloDone](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ServerHelloDone.png)

### SSL建立第三阶段

客户端收到服务器发送的一系列消息并解析后，将本端相应的消息发送给服务器。

![第三阶段](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5.png)

客户机启动SSL握手第3阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3步：

1. 证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。
2. 客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。
3. 证书验证（可选），对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。

#### Certificate（可选）

如果在第二阶段服务器端要求发送客户端证书，客户端便会在该阶段将自己的证书发送过去。服务器端在之前发送的Certificate Request消息中包含了服务器端所支持的证书类型和CA列表，因此客户端会在自己的证书中选择满足这两个条件的第一个证书发送过去。若客户端没有证书，则发送一个no_certificate警告。

#### Client Key exchange

根据之前从服务器端收到的随机数，按照不同的密钥交换算法（例如：RSA, Diffie-Hellman），算出一个pre-master，发送给服务器，服务器端收到pre-master算出main master。而客户端当然也能自己通过pre-master算出main master。如此以来双方就算出了对称密钥。

如果是RSA算法，会生成一个48字节的随机数，然后用server的公钥加密后再放入报文中。如果是DH算法，这是发送的就是客户端的DH参数，之后服务器和客户端根据DH算法，各自计算出相同的pre-master secret.

![ClientKeyExchange](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ClientKeyExchange.png)

本消息在给服务器发送的过程中，使用了服务器的公钥加密。服务器用自己的私钥解密后才能得到pre-master key.（向服务器证明自己的确持有客户端证书私钥。）

#### Certificate verify（可选）

只有在客户端发送了自己证书到服务器端，这个消息才需要发送。其中包含一个签名，对从第一条消息以来的所有握手消息的HMAC值（用master_secret）进行签名。

### SSL建立第四阶段

完成握手协议，建立SSL连接。

![第四阶段](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5.png)

客户机启动SSL握手第4阶段，使服务器结束。该阶段分为4步，前2个消息来自客户机，后2个消息来自服务器。

建立起一个安全的连接，客户端发送一个ChangeCipherSpec消息，并且把协商得到的CipherSuite拷贝到当前连接的状态之中。然后，客户端用新的算法、密钥参数发送一个Finished消息，这条消息可以检查密钥交换和认证过程是否已经成功。其中包括一个校验值，对客户端整个握手过程的消息进行校验。服务器同样发送Change Cipher Spec消息和Finished消息。握手过程完成，客户端和服务器可以交换应用层数据进行通信。

#### ChangeCipherSpec

编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送（**ChangeCipherSpec**是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了）。

![ClientChangeCipher](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ClientChangeCipher.png)

#### Clinet Finished

**客户端握手结束通知**, 表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验（使用**HMAC算法**计算收到和发送的所有握手消息的摘要，然后通过RFC5246中定义的一个伪函数PRF计算出结果，加密后发送。此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。）

#### Server Finished

服务端握手结束通知。

1. 使用私钥解密加密的Pre-master数据，基于之前(Client Hello 和 Server Hello)交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master);
2. 计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;
3. 发送一个 ChangeCipherSpec（告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了）
4. 服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。

根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以使用上面产生的Session Secret对数据进行加密传输了。

# 为什么前两个随机数是没有加密传输，但第三个随机数就要加密传输了？

不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。

# CA证书中包含哪些内容？

证书的格式遵循 ITUT X.509 国际标准，X.509 为证书及其 CRL 格式提供了一个标准，但 X.509 本身不是 Internet 标准，而是国际电联 ITU 标准，它定义了一个开放的框架并在一定的范围内可以进行扩展。

![X.509v3规定的数字证书格式](https://img-blog.csdnimg.cn/20191018000835743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dzaHRpbWU=,size_16,color_FFFFFF,t_70#pic_center)

复杂来说，X.509是由国际电信联盟（ITU-T)制定的数字证书标准。为了提供公用网络用户目录信息服务，ITU于1988年制定了X.500系列标准。其中X.500和X.509是安全认证系统的核心，X.500定义了一种区别命名规则，以命名树来确保用户名称的唯一性；X.509则为X.500用户名称提供了通信实体鉴别机制，并规定了实体鉴别过程中广泛适用的证书语法和数据接口，X.509称之为证书。

简单来说，X.509是一套数字证书的体系标准，它标准化了一个通用的、灵活的证书格式。X.509是X.500标准系列的一部分，在PKI的发展中，X.509起到了无可比拟的作用，其丰富的证书携带信息使之成为当前最流行的证书存储格式。

X.509 v3规范的证书格式中包含的关键信息如下：

**证书版本号**

版本号号指明X.509证书的格式版本号，如今的值能够为0、1、2，也为将来的版本号进行了提前定义。

**证书序列号**

序列号指定由CA分配给证书的唯一的数字型标识符。当证书被取消时，实际上是将此证书的序列号放入由CA签发的CRL中，这也是序列号存在的唯一原因。

**签名算法**

生成该证书的签名时所使用的HASH密码学算法和公钥密码学算法。例如，SHA-1 和 RSA 的对象标识符就用来说明该数字签名是利用 RSA 对SHA-1 杂凑加密.

**颁发者**

此域用来标识签发证书的CA的X.500 DN名字（验证者通过该字段去获取CA的证书）。包含国家、省市、地区、组织机构、单位部门和通用名。

**有效期**

指定证书的有效期。包含证书開始生效的日期和时间以及失效的日期和时间。每次使用证书时。须要检查证书是否在有效期内。

**主题：该证书时颁发给谁的，即证书持有者的名称。**

指定证书持有者的X.500唯一名字。包括国家、省市、地区、组织机构、单位部门和通用名，还可包括email地址等个人信息等

**证书持有者公开密钥信息：证书持有者的公钥信息。**

证书持有者公开密钥信息域包括两个重要信息：证书持有者的公开密钥的值；公开密钥使用的算法标识符。此标识符包括公开密钥算法和hash算法。

**签名：CA对该证书的签名，又叫做CA的指纹信息。**

# 客户端收到CA证书如何校验合法性，并验证其是否被篡改？

如果通信双方要互相验证对方的证书，那就要分别获取到为对方颁发证书的CA的证书。如下图所示，A如果要验证B的证书，则A必须先获取为B颁发证书的CA的证书，用CA的证书验证B的证书；B如果要验证A的证书，则B必须先获取为A颁发证书的CA的证书，用CA的证书验证A的证书。如果A和B是由同一个CA颁发的证书，那么两者获取到的CA的证书是相同的，如果A和B是由两个不同的CA颁发的证书，那么两者获取到的CA的证书是不同的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191018001304450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dzaHRpbWU=,size_16,color_FFFFFF,t_70#pic_center)
上述过程存在两个问题：

1. CA的公钥如何获取

   B的证书中含有为B颁发证书的CA的信息，A通过该信息请求CA的证书，CA的证书中含有CA的公钥。

2. 如何验证CA的证书是否被篡改及身份

   验证CA证书是否被篡改及CA的身份和A验证B的证书和身份的原理一样，首先通过摘要信息进行判断，然后找为CA颁发证书的上层CA，通过这种一层一层的方式验证身份。那么，什么时候这个验证过程才会停止呢？直到找到一个可信的CA或者验证出现了错误。操作系统中一般都会安装一些根证书，在进行身份验证的时候，如果在操作系统的根证书中验证了CA的身份，那么验证过程就可以终止了。

# CA证书给了服务器什么

PKI就是浏览器和CA，CA是整个安全机制的重要保障，我们平时用的证书就是由CA机构颁发，其实就是**用CA的私钥给用户的证书签名**，然后在证书的签名字段中填充这个签名值，浏览器在验证这个证书的时候就是使用CA的公钥进行验签。

# CA机构如何用自己的私钥做数字签名？

RSA 是目前最有影响力的公钥加密算法，该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用。

椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。
