# TCP 拥塞控制算法

## 出现拥塞的条件

对资源需求的总和>可用资源

网络中有许多资源同时呈现供应不足，导致网络性能变坏，网络吞吐量随负荷增大而下降（接受和发送数据速率下降）

拥塞控制本质是防止过多的数据注入到网络中

## 拥塞控制四种算法

- 慢开始——拥塞避免
- 快重传——快恢复

### 案例讲解的假定

1. 数据单方向传送，而另一个方向只传送确认
2. 接收方总是有足够大的缓存空间，发送窗口=Min{接收窗口rwnd，拥塞窗口cwnd}，因而发送窗口大小取决于拥塞程度

### 接收窗口与发送窗口的区别

1. 接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。
2. 拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。

### 慢开始和拥塞避免

![image-20201229230755983](https://img-blog.csdnimg.cn/img_convert/421b8f64c5d327bc285a7daf070ad21f.png)

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限（ssthresh）设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

**流程**：开始时cwnd=1，为一个报文段；开始慢开始算法阶段1->2->4->8->16，到达慢开始门限（ssthresh）；切换算法，由慢开始算法切换到拥塞避免算法“加法增大”，16->17->18->19->20->21->22->23->24；到达24，开始网络拥塞；从cwnd为1重新开始慢开始算法，执行“乘法减小”算法，把ssthresh门限减半（12），1->2->4->8->12，到达慢开始门限；切换算法，由慢开始算法切换到拥塞避免算法“加法增大”，12->13->14->15->16......

### 快重传和快恢复

![image-20201229231047273](https://img-blog.csdnimg.cn/img_convert/7fc917c97c52733502950a11b9c99673.png)

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

快重传配合使用的还有快恢复算法，有以下两个要点:

1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。

2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

**流程**：开始时cwnd=1，为一个报文段；开始慢开始算法阶段1->2->4->8->16，到达慢开始门限（ssthresh）；切换算法，由慢开始算法切换到拥塞避免算法“加法增大”，16->17->18->19->20->21->22->23->24；到达24，收到三个重复冗余的确认ACK，执行快重传算法；执行“乘法减小”算法，把ssthresh门限减半，切换到快恢复算法，快恢复算法将cwnd调整至出现拥塞时ssthresh减半的值12；使用拥塞避免算法12->13->14->15->16->17->18->19->20......

# TCP流量控制

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

## 滑动窗口

接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量win来表示接收窗口的大小。

发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。

![img](https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIOiaD8iaf8gpnDuSDXqzickq9pnqfIvSXJmw2E1hoyFI5nKgLf6UK2YHVwO4xKKicL2Gexh9ic96BPG96w/640)

## 发送方继续发送数据

当发送方停止发送数据后，该怎样才能知道自己可以继续发送数据？

当接收方处理好数据，接受窗口 win > 0 时，接收方发个通知报文去通知发送方，告诉他可以继续发送数据了。当发送方收到窗口大于0的报文时，就继续发送数据。

不过这时候可能会遇到一个问题，假如接收方发送的通知报文，由于某种网络原因，这个报文丢失了，这时候就会引发一个问题：接收方发了通知报文后，继续等待发送方发送数据，而发送方则在等待接收方的通知报文，此时双方会陷入一种僵局。

为了解决这种问题，我们采用了另外一种策略：当发送方收到接受窗口 win = 0 时，这时发送方停止发送报文，并且同时开启一个定时器，每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。

![img](https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIOiaD8iaf8gpnDuSDXqzickq9p2ozHyZtAl1aa8fY9p71zbHqYiamt9WIyInSibv71MpILUGqDKh7GoOEw/640)

## 流量控制中的概念

### 接收窗口与拥塞窗口（发送窗口）

由于TCP/IP支持全双工传输，因此通信的双方都拥有两个滑动窗口，一个用于接受数据，称之为接收窗口；一个用于发送数据，称之为拥塞窗口(即发送窗口)。指出接受窗口大小的通知我们称之为窗口通告。

### 接收窗口大小

在早期的TCP协议中，接受接受窗口的大小确实是固定的，不过随着网络的快速发展，固定大小的窗口太不灵活了，成为TCP性能瓶颈之一，也就是说，在现在的TCP协议中，接受窗口的大小是根据某种算法动态调整的。

### 接收窗口越大越好吗

接受窗口如果太小的话，显然这是不行的，这会严重浪费链路利用率，增加丢包率。那是否越大越好呢？答否，当接收窗口达到某个值的时候，再增大的话也不怎么会减少丢包率的了，而且还会更加消耗内存。所以接收窗口的大小必须根据网络环境以及发送发的的拥塞窗口来动态调整。

### 发送窗口与接收窗口

接收方在发送确认报文的时候，会告诉发送发自己的接收窗口大小，而发送方的发送窗口会据此来设置自己的发送窗口，但这并不意味着他们就会相等。首先接收方把确认报文发出去的那一刻，就已经在一边处理堆在自己缓存区的数据了，所以一般情况下接收窗口 >= 发送窗口。

