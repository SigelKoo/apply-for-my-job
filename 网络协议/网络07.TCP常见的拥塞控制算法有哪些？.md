# TCP常见的拥塞控制算法有哪些？

#### 出现拥塞的条件

对资源需求的总和>可用资源

网络中有许多资源同时呈现供应不足，导致网络性能变坏，网络吞吐量随负荷增大而下降（接受和发送数据速率下降）

拥塞控制本质是防止过多的数据注入到网络中

#### 拥塞控制四种算法

- 慢开始——拥塞避免
- 快重传——快恢复

###### 案例讲解的假定

1. 数据单方向传送，而另一个方向只传送确认
2. 接收方总是有足够大的缓存空间，发送窗口=Min{接收窗口rwnd，拥塞窗口cwnd}，因而发送窗口大小取决于拥塞程度

###### 接收窗口与发送窗口的区别

1. 接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。
2. 拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。

#### 慢开始和拥塞避免

![image-20201229230755983](https://img-blog.csdnimg.cn/img_convert/421b8f64c5d327bc285a7daf070ad21f.png)

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限（ssthresh）设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

**流程**：开始时cwnd=1，为一个报文段；开始慢开始算法阶段1->2->4->8->16，到达慢开始门限（ssthresh）；切换算法，由慢开始算法切换到拥塞避免算法“加法增大”，16->17->18->19->20->21->22->23->24；到达24，开始网络拥塞；从cwnd为1重新开始慢开始算法，执行“乘法减小”算法，把ssthresh门限减半（12），1->2->4->8->12，到达慢开始门限；切换算法，由慢开始算法切换到拥塞避免算法“加法增大”，12->13->14->15->16......

#### 快重传和快恢复

![image-20201229231047273](https://img-blog.csdnimg.cn/img_convert/7fc917c97c52733502950a11b9c99673.png)

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

快重传配合使用的还有快恢复算法，有以下两个要点:

1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。

2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

**流程**：开始时cwnd=1，为一个报文段；开始慢开始算法阶段1->2->4->8->16，到达慢开始门限（ssthresh）；切换算法，由慢开始算法切换到拥塞避免算法“加法增大”，16->17->18->19->20->21->22->23->24；到达24，收到三个重复冗余的确认ACK，执行快重传算法；执行“乘法减小”算法，把ssthresh门限减半，切换到快恢复算法，快恢复算法将cwnd调整至出现拥塞时ssthresh减半的值12；使用拥塞避免算法12->13->14->15->16->17->18->19->20......