# 简述TCP三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

## TCP连接传输三个阶段

```mermaid
graph LR
A(连接建立) --> B(数据传送) --> C(连接释放)
```

TCP连接的建立采用**客户服务器方式**，主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器。

## 三次握手

![img](https://img-blog.csdnimg.cn/img_convert/83ae6f9265319f24240955f1b825bda1.png)

![image-20201229221150323](https://img-blog.csdnimg.cn/img_convert/a15100281b928a7118dd4a07320d38fd.png)

假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：

ROUND 1：

客户端发送连接请求报文段，无应用层数据。

```
SYN=1（表示建立连接），seq=x（随机，表示客户端向服务器端发送的起始字节序号为x）
```

ROUND 2：

服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。

```
SYN=1（表示建立连接），ACK=1（表示ack字段生效），seq=y（随机，表示服务器端向客户端发送的起始字节序号为y），ack=x+1（表示服务器端在下一次的报文中想要接收到以x+1序号起始的字节流，是ROUND1客户端发送的下一个字节流）
```

ROUND 3：

客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。

```
SYN=0，ACK=1（表示ack字段生效），seq=x+1（表示客户端向服务器端发送的起始字节序号为x+1），ack=y+1（表示客户器端在下一次的报文中想要接收到以y+1序号起始的字节流）
```

**SYN 在两种情况下会设置为 1**

1. 连接请求的报文中
2. 连接请求的确认报文中

## 四次挥手

![image-20201229221852591](https://img-blog.csdnimg.cn/img_convert/f32f3db7249420ac0220cb55114214f6.png)

参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。

![image-20201229221859468](https://img-blog.csdnimg.cn/img_convert/b4f160ac04b5c0d0220ccde2b1a3f94b.png)

ROUND 1：

客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。

```
FIN=1（表示客户端请求释放连接），seq=u（表示客户端向服务器端发送的起始字节序号为u）
```

ROUND 2：

服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。

```
ACK=1（表示ack字段生效），seq=v（表示服务端向客户器端发送的起始字节序号为v），ack=u+1（表示服务器端上次接收到的最后一个字节序号为 u）
```

ROUND 3：

服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。

```
FIN=1（表示服务器端请求释放连接），ACK=1（表示ack字段生效），seq=w（表示服务端向客户端发送的起始字节序号为w），ack=u+1（客户端单方向释放了连接，不会再向服务器端发送数据，因此ack还是等于u+1）
```

ROUND 4：

客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。

```
ACK=1（表示ack字段生效），seq=u+1（表示客户端向服务器端发送的起始字节序号为u+1），ack=w+1（表示客户端端上次接收到的最后一个字节序号为w）
```

**FIN 在两种情况下会设置为 1**

1. 客户端的连接释放请求中
2. 服务器端的连接释放请求中

### 为什么客户端需要等待 2MSL 的时间？

如果客户端在 ROUND 4 中发送的确认报文段在路上丢失，没有到达服务器端，服务器端在一定时间内没有收到确认就会重传 ROUND3 中的连接释放报文段。如果客户端刚发送完 ROUND4 中的确认报文段就直接关闭连接，那么服务器端就会一直不停地重传 ROUND3 中的连接释放报文段，这样会大大浪费服务器端的资源

如果客户端在 ROUND 4 中发送的确认报文段在路上丢失，没有到达服务器端，那么客户端在 2MSL 时间内还会收到来自服务器重传的连接释放报文段，然后客户端会重传确认报文段，直至服务器端接收成功为止

#### MSL是什么

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。我们都知道IP头部中有个TTL字段，TTL是time to live的缩写，可译为“生存时间”，这个生存时间是由源主机设置设置初始值但不是但不是存在的具体时间，而是一个IP数据报可以经过的最大路由数，每经过一个路由器，它的值就减1，当此值为0则数据报被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，但这完全是从工程上来考虑，对于现在的网络，MSL=2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。TTL与MSL是有关系的但不是简单的相等关系，MSL要大于TTL。

## 为什么需要三次握手以及四次挥手？

**三次握手**

在谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。

谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

**四次挥手**

确保数据能够完成传输。

但关闭连接时，当收到对方的*FIN*报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭*SOCKET,*也即你可能还需要发送一些数据给对方之后，再发送*FIN*报文给对方来表示你同意现在可以关闭连接了，所以它这里的*ACK*报文和*FIN*报文多数情况下都是分开发送的。

## 服务器主动终止连接的情况分析

![这里写图片描述](https://img-blog.csdn.net/20170308215549472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYml0X2NsZWFyb2Zm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

上图中，我们让服务端先退出，然后我们用netstat观察端口的状态，此时我们发现四次挥手过程中服务器和客户端的状态颠倒了， 也就是说，服务端和客户端的进程那个先向对方发送FIN 字段报文，那么哪个就先进入FIN_WAIT2状态。

![这里写图片描述](https://img-blog.csdn.net/20170308220432148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYml0X2NsZWFyb2Zm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

上图发生的原因是这样的，当服务器进程被终止时，会关闭其打开的所有文件描述符，此时就会向客户端发送一个FIN 的报文,客户端则响应一个ACK 报文,但是这样只完成了“四次挥手”的前两次挥手，也就是说这样只实现了半关闭，客户端仍然可以向服务器写入数据。

但是当客户端向服务器写入数据时，由于服务器端的套接字进程已经终止，此时连接的状态已经异常了，所以服务端进程不会向客户端发送ACK 报文，而是发送了一个RST 报文请求将处于异常状态的连接复位； 如果客户端此时还要向服务端发送数据，将诱发服务端TCP向服务端发送SIGPIPE信号，因为向接收到RST的套接口写数据都会收到此信号. 所以说，这就是为什么我们主动关闭服务端后，用客户端向服务端写数据，还必须是写两次后连接才会关闭的原因。

## 在linux系统中，TCP连接状态的多种判断方法

- 通过错误码和信号判断
- 通过select系统函数判断
- 通过TCP_INFO套接字选项判断
- 通过SO_KEEPALIVE套接字选项判断
- 通过SO_RCVTIMEO/SO_SNDTIMEO判断

(一)通过错误码和信号判断

(1)写数据信号和错误码判断

在写TCP连接数据的时候，如果对方连接已经正常断开，那么写数据端将会收到一个SIGPIPE信号，可以通过这个信号知道对方连接已经断开。该信号信号会终止当前进程，如果不在对方连接断开不退出进程，那么就应该注册信号函数。

同时，如果对方连接已经正常断开，那么write写数据端将会返回写错误。返回的写长度为-1，此时的错误码为：32，对应错误值为EPIPE；因此可以写数据时write的返回值和错误码来判断对方连接是否已经断开了。

(2)读数据判断返回值

如果当前是默认的阻塞模式读取，那么此时read读取返回的长度为0，错误码也是为0，其实表示读取成功。这里需要注意read和recv接口的默认返回值是不一样的，使用recv接口也会返回EPIPE错误码。

(二)通过select系统函数判断

select实际是IO复用的一个接口，它可以同时检测多个连接是否有数据可读写操作，并且可以设置检测的超时时间。

在点对点的连接中如果select超时，它返回值为0；

当出现异常的时候，返回-1，如果对方断开可能收到104的错误码，也就是ECONNRESET，表示连接被重置
当select返回1，表示正常，如果read此时返回的值为0，表示对方连接已经断开。

(三)通过TCP_INFO套接字选项判断

通过getsockopt函数可以获取TCP连接的连接状态，当状态为ESTABLISHED的时候表示该连接正常。TCP的其它状态还有：

- CLOSED：表示初始状态。对服务端和C客户端双方都一样。
- LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。
- SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，并等待服务端发送ACK+SYN。
- SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。
- ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。
- FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。
- FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。
- TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果
- FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
- CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，此时就会出现CLOSING状态，表示双方都在关闭连接。
- CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。
- LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。

(五)通过SO_RCVTIMEO/SO_SNDTIMEO判断

这个是通过套接字的SO_RCVTIMEO、SO_SNDTIMEO来设置收发数据超时。对于前面的前面的几种判断方式，都是基于对方正常网络断开后，主机才能够正常的判断到网络状态。如果连接的某一方突然断电，主机并不能知道对方设备突然断电，通过TCP_INFO查询到的也是网络正常，但实际情况是这是网络连接已经断开了。

这时，可以使用收发数据超时来判断：

如果设置的时间没有收到数据，read时会返回-1，同时有错误码EAGAIN产生，这时是可以判断出对连接已经断开了。

这种方式的确定就是，如果设定的一段时间没有收发数据，就会被判断为超时断开连接

## 三次握手和四次挥手异常

### 第一次握手丢失了，会发生什么？

当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发超时重传机制。

不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。

当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？

在 Linux 里，客户端的 SYN 报文最大重传次数由 `tcp_syn_retries`内核参数控制，这个参数是可以自定义的，默认值一般是 5。

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。

所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。

### 第二次握手丢失了，会发生什么？

当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 `SYN_RCVD` 状态。

第二次握手的 `SYN-ACK` 报文其实有两个目的 ：

- 第二次握手里的 ACK， 是对第一次握手的确认报文；
- 第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；

所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？

因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。

那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。

在 Linux 下，SYN-ACK 报文的最大重传次数由 `tcp_synack_retries`内核参数决定，默认值是 5。

因此，当第二次握手丢失了，客户端和服务端都会重传：

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定。；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。

### 第三次握手丢失了，会发生什么？

客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。

因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

### 第一次挥手丢失了，会发生什么？

当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 `FIN_WAIT_1` 状态。

正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 `FIN_WAIT2` 状态。

如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。

当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，直接进入到 `close` 状态。

### 第二次挥手丢失了，会发生什么？

当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `CLOSE_WAIT` 状态。

在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。

这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 `FIN_WAIT2` 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

对于 close 函数关闭的连接，由于无法再发送和接收数据，所以`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。

这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。

### 第三次挥手丢失了，会发生什么？

当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 `CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。

服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。

如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `tcp_orphan_retrie`s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

### 第四次挥手丢失了，会发生什么？

当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 `TIME_WAIT` 状态。

在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进入关闭状态。

然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。

如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。