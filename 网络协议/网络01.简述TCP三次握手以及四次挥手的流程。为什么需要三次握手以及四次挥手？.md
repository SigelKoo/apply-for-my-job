# 简述TCP三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

#### TCP连接传输三个阶段

```mermaid
graph LR
A(连接建立) --> B(数据传送) --> C(连接释放)
```

TCP连接的建立采用**客户服务器方式**，主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器。

#### 三次握手

![img](https://img-blog.csdnimg.cn/img_convert/83ae6f9265319f24240955f1b825bda1.png)

![image-20201229221150323](https://img-blog.csdnimg.cn/img_convert/a15100281b928a7118dd4a07320d38fd.png)

假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：

ROUND 1：

客户端发送连接请求报文段，无应用层数据。

```
SYN=1（表示建立连接），seq=x（随机，表示客户端向服务器端发送的起始字节序号为x）
```

ROUND 2：

服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。

```
SYN=1（表示建立连接），ACK=1（表示ack字段生效），seq=y（随机，表示服务器端向客户端发送的起始字节序号为y），ack=x+1（表示服务器端在下一次的报文中想要接收到以x+1序号起始的字节流，是ROUND1客户端发送的下一个字节流）
```

ROUND 3：

客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。

```
SYN=0，ACK=1（表示ack字段生效），seq=x+1（表示客户端向服务器端发送的起始字节序号为x+1），ack=y+1（表示客户器端在下一次的报文中想要接收到以y+1序号起始的字节流）
```

**SYN 在两种情况下会设置为 1**

1. 连接请求的报文中
2. 连接请求的确认报文中

#### 四次挥手

![image-20201229221852591](https://img-blog.csdnimg.cn/img_convert/f32f3db7249420ac0220cb55114214f6.png)

参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。

![image-20201229221859468](https://img-blog.csdnimg.cn/img_convert/b4f160ac04b5c0d0220ccde2b1a3f94b.png)

ROUND 1：

客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。

```
FIN=1（表示客户端请求释放连接），seq=u（表示客户端向服务器端发送的起始字节序号为u）
```

ROUND 2：

服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。

```
ACK=1（表示ack字段生效），seq=v（表示服务端向客户器端发送的起始字节序号为v），ack=u+1（表示服务器端上次接收到的最后一个字节序号为 u）
```

ROUND 3：

服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。

```
FIN=1（表示服务器端请求释放连接），ACK=1（表示ack字段生效），seq=w（表示服务端向客户端发送的起始字节序号为w），ack=u+1（客户端单方向释放了连接，不会再向服务器端发送数据，因此ack还是等于u+1）
```

ROUND 4：

客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。

```
ACK=1（表示ack字段生效），seq=u+1（表示客户端向服务器端发送的起始字节序号为u+1），ack=w+1（表示客户端端上次接收到的最后一个字节序号为w）
```

**FIN 在两种情况下会设置为 1**

1. 客户端的连接释放请求中
2. 服务器端的连接释放请求中

##### 为什么客户端需要等待 2MSL 的时间？

如果客户端在 ROUND 4 中发送的确认报文段在路上丢失，没有到达服务器端，服务器端在一定时间内没有收到确认就会重传 ROUND3 中的连接释放报文段。如果客户端刚发送完 ROUND4 中的确认报文段就直接关闭连接，那么服务器端就会一直不停地重传 ROUND3 中的连接释放报文段，这样会大大浪费服务器端的资源

如果客户端在 ROUND 4 中发送的确认报文段在路上丢失，没有到达服务器端，那么客户端在 2MSL 时间内还会收到来自服务器重传的连接释放报文段，然后客户端会重传确认报文段，直至服务器端接收成功为止

#### 为什么需要三次握手以及四次挥手？

客户端第一次握手，若超时会重传

服务器第二次握手，若超时会重传

客户端第三次握手，服务器发送第二次后，以为自己进入ESTABLISHED，但客户端不一定进入ESTABLISHED，所以需要第三次



客户端第一次挥手说明自己没有数据需要发送了

服务器第二次挥手说明收到客户端想要断开的请求了，但可能还有数据需要发送

服务器第三次挥手说明发送完所有数据了

客户端第四次挥手说明客户端收到，确定连接中断

#### 服务器主动终止连接的情况分析

![这里写图片描述](https://img-blog.csdn.net/20170308215549472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYml0X2NsZWFyb2Zm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

上图中，我们让服务端先退出，然后我们用netstat观察端口的状态，此时我们发现四次挥手过程中服务器和客户端的状态颠倒了， 也就是说，服务端和客户端的进程那个先向对方发送FIN 字段报文，那么哪个就先进入FIN_WAIT2状态。

![这里写图片描述](https://img-blog.csdn.net/20170308220432148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYml0X2NsZWFyb2Zm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

上图发生的原因是这样的，当服务器进程被终止时，会关闭其打开的所有文件描述符，此时就会向客户端发送一个FIN 的报文,客户端则响应一个ACK 报文,但是这样只完成了“四次挥手”的前两次挥手，也就是说这样只实现了半关闭，客户端仍然可以向服务器写入数据。
但是当客户端向服务器写入数据时，由于服务器端的套接字进程已经终止，此时连接的状态已经异常了，所以服务端进程不会向客户端发送ACK 报文，而是发送了一个RST 报文请求将处于异常状态的连接复位； 如果客户端此时还要向服务端发送数据，将诱发服务端TCP向服务端发送SIGPIPE信号，因为向接收到RST的套接口写数据都会收到此信号. 所以说，这就是为什么我们主动关闭服务端后，用客户端向服务端写数据，还必须是写两次后连接才会关闭的原因。

#### TCP连接状态的多种判断方法

- 通过错误码和信号判断
- 通过select系统函数判断
- 通过TCP_INFO套接字选项判断
- 通过SO_KEEPALIVE套接字选项判断
- 通过SO_RCVTIMEO/SO_SNDTIMEO判断

(一)通过错误码和信号判断
(1)写数据信号和错误码判断
    在写TCP连接数据的时候，如果对方连接已经正常断开，那么写数据端将会收到一个SIGPIPE信号，可以通过这个信号知道对方连接已经断开。该信号信号会终止当前进程，如果不在对方连接断开不退出进程，那么就应该注册信号函数。
    同时，如果对方连接已经正常断开，那么write写数据端将会返回写错误。返回的写长度为-1，此时的错误码为：32,对应错误值为EPIPE;因此可以写数据时write的返回值和错误码来判断对方连接是否已经断开了。

(2)读数据判断返回值
    如果当前是默认的阻塞模式读取，那么此时read读取返回的长度为0，错误码也是为0，其实表示读取成功。这里需要注意read 和recv接口的默认返回值是不一样的，使用recv接口也会返回EPIPE错误码。

(二)通过select系统函数判断
    select实际是IO复用的一个接口，它可以同时检测多个连接是否有数据可读写操作，并且可以设置检测的超时时间。
    在点对点的连接中如果select超时，它返回值为0；

当出现异常的时候，返回-1，如果对方断开可能收到104的错误码，也就是ECONNRESET，表示连接被重置
当select返回1，表示正常，如果read此时返回的值为0，表示对方连接已经断开。

(三)通过TCP_INFO套接字选项判断
    通过getsockopt函数可以获取TCP连接的连接状态，当状态为ESTABLISHED的时候表示该连接正常。TCP的其它状态还有：

CLOSED：表示初始状态。对服务端和C客户端双方都一样。
LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。
SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，并等待服务端发送ACK+SYN。
SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。
ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。
FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。
FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。
TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，此时就会出现CLOSING状态，表示双方都在关闭连接。
CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。
LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。

(五)通过SO_RCVTIMEO/SO_SNDTIMEO判断
    这个是通过套接字的SO_RCVTIMEO、SO_SNDTIMEO来设置收发数据超时。对于前面的前面的几种判断方式，都是基于对方正常网络断开后，主机才能够正常的判断到网络状态。如果连接的某一方突然断电，主机并不能知道对方设备突然断电，通过TCP_INFO查询到的也是网络正常，但实际情况是这是网络连接已经断开了。
    这时，可以使用收发数据超时来判断：
    如果设置的时间没有收到数据，read时会返回-1，同时有错误码EAGAIN产生，这时是可以判断出对连接已经断开了。
    这种方式的确定就是，如果设定的一段时间没有收发数据，就会被判断为超时断开连接

#### TCP三次握手第三次握手时ACK丢失怎么办

Server 端

  第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。

  而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.

  如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

Client 端

  在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。