# 简述TCP的TIME_WAIT

TCP 的三次握手，四次挥手，在不稳定的物理网络中，每一个动作都有可能失败，为了保证数据被有效传输，TCP 的具体实现中也加入了很多对这些异常状况的处理。

![img](https://zhenbianshu.github.io/images/2018/tcp_state.png)

图中上面建立连接，左下部分主动关闭连接过程和右下部分被动关闭连接过程。建连过程就是我们熟悉的三次握手，只是这张图上多了一个服务端会存在的 LISTEN 状态；而主动关闭连接和被动关闭连接，都是四次挥手的过程。

#### TIME_WAIT定义

当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态。TCP 四次握手结束后，连接双方都不再交换消息，但主动关闭的一方保持这个连接在一段时间内不可用。

#### 保持该状态的作用

TIME_WAIT 状态的提出就是为了应对复杂的网络状态中的一种异常状况。

假设没有TIME_WAIT，A、B 来代指 TCP 连接的两端，A 为主动关闭的一端。

- 四次挥手中，A 发 FIN， B 响应 ACK，B 再发 FIN，A 响应 ACK 实现连接的关闭。而如果 A 响应的 ACK 包丢失，B 会以为 A 没有收到自己的关闭请求，然后会重试向 A 再发 FIN 包。

  如果没有 TIME_WAIT 状态，A 不再保存这个连接的信息，收到一个不存在的连接的包，A 会响应 RST 包，导致 B 端异常响应。

  此时， TIME_WAIT 是为了保证全双工的 TCP 连接正常终止。

- 我们还知道，TCP 下的 IP 层协议是无法保证包传输的先后顺序的。如果双方挥手之后，一个网络四元组（src/dst ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 B 接收，A 应用程序又立刻使用了同样的四元组再创建了一个新的连接后，这个迟到的数据包才到达 B，那么这个数据包就会让 B 以为是 A 刚发过来的。

  此时， TIME_WAIT 的存在是为了保证网络中迷失的数据包正常过期。

#### 时长的确定

确定 TIME_WAIT 的时长主要考虑上文的第二种情况，保证关闭连接后这个连接在网络中的所有数据包都过期。

最大分段寿命（MSL，Maximum Segment Lifetime），它表示一个 TCP 分段可以存在于互联网系统中的最大时间，由 TCP 的实现，超出这个寿命的分片都会被丢弃。

TIME_WAIT 状态由主动关闭的 A 来保持，那么我们来考虑对于 A 来说，可能接到上一个连接的数据包的最大时长：A 刚发出的数据包，能保持 MSL 时长的寿命，它到了 B 端后，B 端由于关闭连接了，会响应 RST 包，这个 RST 包最长也会在 MSL 时长后到达 A，那么 A 端只要保持 TIME_WAIT 到达 2MSL就能保证网络中这个连接的包都会消失。

#### TIME_WAIT过多

意味着有大量短连接断开

