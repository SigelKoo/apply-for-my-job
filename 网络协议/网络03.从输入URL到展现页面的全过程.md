# 从输入URL到展现页面的全过程

总体来说分为以下几个过程:

- DNS解析：将域名解析成 IP 地址
- TCP连接：TCP三次握手
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 断开连接：TCP四次挥手

1. URL统一资源定位符，用于定位互联网上资源，语法：`scheme://host.domain:port/path/filename`

    - scheme：定义因特网服务的类型。常见的协议有 http、https、ftp、file
    - host：定义域主机
    - domain：定义因特网域名
    - port：定义主机上的端口号
    - path：定义服务器上的路径
    - filename：定义文档/资源的名称
    
2. 域名解析

    1. IP地址

       IP地址是指互联网协议地址。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址是一个32位的二进制数，比如127.0.0.1为本机IP。

       域名就相当于IP地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。

    2. 域名解析
       DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。DNS是一个网络服务器，我们的域名解析简单来说就是在DNS上记录一条信息记录。

       ```
       baidu.com    182.61.200.6（服务器外网IP地址）80（服务器端口号）
       ```
       
    3. 通过域名去查询URL对应的IP
       
       - 浏览器缓存：浏览器会按照一定的频率缓存DNS记录
       - 操作系统缓存：浏览器缓存中找不到DNS记录，去操作系统中找
       - 路由缓存：路由器也有DNS缓存
       - ISP的DNS服务器：ISP、互联网服务提供商(Internet Service Provider)，ISP 有专门的DNS服务器应对DNS查询请求
       - 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询

3. TCP三次握手
    客户端发送一个带`SYN=1, Seq=X`的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
    服务器发回一个带`SYN=1, ACK=X+1, Seq=Y`的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
    客户端再回传一个带`ACK=Y+1, Seq=Z`的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

4. 发送HTTP请求
   发送HTTP请求报文。请求报文由请求行（request line）、请求头（header）、请求体四个部分组成
    1. 请求行包含请求方法、URL、协议版本
       - 请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE
       
       - URL 即请求地址，由`<协议>://<主机>:<端口>/<路径>?<参数>`组成
       
       - 协议版本即http版本号
       
       ```
       POST /chapter/user.html HTTP/1.1
       ```
       POST代表请求方法
       /chapter17/user.html表示 URL
       HTTP/1.1代表协议和协议的版本，为现在主流
    2. 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔
       请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。
    3. 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据
       ```
       name=tom&password=1234&realName=tomson
       ```
5. 服务器处理请求并返回HTTP报文
    1. 服务器
       web server：apache、nginx、IIS处理请求。
       担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如：JSP脚本，servlets，ASP脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。
    2. 后台处理阶段
       首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取redis db以及MySQL的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。
    3. http响应报文
       响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。
       响应行包含：协议版本，状态码，状态码描述，例：HTTP/1.1 200 OK
       状态码规则如下：
       
       - 1xx：指示信息–表示请求已接收，继续处理
       
       - 2xx：成功–表示请求已被成功接收、理解、接受
       
       - 3xx：重定向–要完成请求必须进行更进一步的操作
       
       - 4xx：客户端错误–请求有语法错误或请求无法实现
       
       - 5xx：服务器端错误–服务器未能实现合法的请求
       
         响应头部包含响应报文的附加信息，由键/值对组成，例：Content-type、Content-Length
       
         响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据
6. 浏览器解析渲染页面
   浏览器拿到响应文本HTML后，接下来介绍下浏览器渲染机制
    1. 根据HTML解析DOM树
       - 根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点
       - 在读取HTML文档，构建DOM树的过程中，若遇到script标签，则DOM树的构建会暂停，直至脚本执行完毕。
    2. 根据CSS解析生成CSS规则树
       - 解析CSS规则树时js执行将暂停，直至CSS规则树就绪
       - 浏览器在CSS规则树生成之前不会进行渲染
    3. 结合DOM树和CSS规则树，生成渲染树
       - DOM树和CSS规则树全部准备好了以后，浏览器才会开始构建渲染树
       - 精简CSS并可以加快CSS规则树的构建，从而加快页面相应速度
    4. 根据渲染树计算每一个节点的信息（布局）
       - 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
       - 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染
    5. 根据计算好的信息绘制页面
       - 绘制阶段，系统会遍历呈现树，并调用呈现器的paint方法，将呈现器的内容显示在屏幕上
       - 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘
       - 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染
7. 断开连接
    当数据传送完毕，需要断开tcp连接，此时发起tcp四次挥手
    - 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
    - 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
    - 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
    - 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

# 底层更细版

### 应用层

首先我们可以看到在应用层，根据当前的需求和动作，结合应用层的协议，有我们确定发送的数据内容，我们把这些数据放到一个缓冲区内，然后形成了应用层的报文**data**。

### 传输层

这些数据通过传输层发送，比如tcp协议。所以它们会被送到传输层处理，在这里报文打上了传输头的包头，主要包含端口号，以及tcp的各种制信息，这些信息是直接得到的，因为接口中需要指定端口。这样就组成了tcp的数据传送单位**segment**。tcp是一种端到端的协议，利用这些信息，比如tcp首部中的序号确认序号，根据这些数字，发送的一方不断的进行发送等待确认，发送一个数据段后，会开启一个计数器，只有当收到确认后才会发送下一个，如果超过计数时间仍未收到确认则进行重发，在接受端如果收到错误数据，则将其丢弃，这将导致发送端超时重发。通过tcp协议，控制了数据包的发送序列的产生，不断的调整发送序列，实现流控和数据完整。

### 网络层

然后待发送的数据段送到网络层，在网络层被打包，这样封装上了网络层的包头，包头内部含有源及目的的ip地址，该层数据发送单位被称为**packet**。网络层开始负责将这样的数据包在网络上传输，如何穿过路由器，最终到达目的地址。在这里，根据目的ip地址，就需要查找下一跳路由的地址。首先在本机，要查找本机的路由表，在windows上运行route print就可以看到当前路由表内容，

整个查找过程是这样的：
(1)根据目的地址，得到目的网络号，如果处在同一个内网，则可以直接发送。
(2)如果不是，则查询路由表，找到一个路由。
(3)如果找不到明确的路由，此时在路由表中还会有默认网关，也可称为缺省网关，IP用缺省的网关地址将一个数据传送给下一个指定的路由器，所以网关也可能是路由器，也可能只是内网向特定路由器传输数据的网关。
(4)路由器收到数据后，它再次为远程主机或网络查询路由，若还未找到路由，该数据包将发送到该路由器的缺省网关地址。而数据包中包含一个最大路由跳数，如果超过这个跳数，就会丢弃数据包，这样可以防止无限传递。路由器收到数据包后，只会查看网络层的包裹数据，目的ip。所以说它是工作在网络层，传输层的数据对它来说则是透明的。

如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或 “网络不可达”的错误。

一般就分这两种情况，目的地址与当前路由器接口是否在同一子网。如果是则直接发送，不需再转给路由器，否则还需要转发给下一个路由器继续进行处理。

 查找到下一跳ip地址后，还需要知道它的mac地址，这个地址要作为链路层数据装进链路层头部。这时需要arp协议，具体过程是这样的，查找arp缓冲，windows下运行arp -a可以查看当前arp缓冲内容。如果里面含有对应ip的mac地址，则直接返回。否则需要发生arp请求，该请求包含源的ip和mac地址，还有目的地的ip地址，在网内进行广播，所有的主机会检查自己的ip与该请求中的目的ip是否一样，如果刚好对应则返回自己的mac地址，同时将请求者的ip mac保存。这样就得到了目标ip的mac地址。

链路层

将mac地址及链路层控制信息加到数据包里，形成**Frame**，Frame在链路层协议下，完成了相邻的节点间的数据传输，完成连接建立，控制传输速度，数据完整。

物理层

物理线路则只负责该数据以**bit**为单位从主机传输到下一个目的地。

下一个目的地接受到数据后，从物理层得到数据然后经过逐层的解包 到 链路层 到 网络层，然后开始上述的处理，在经网络层 链路层 物理层将数据封装好继续传往下一个地址。





































