![在这里插入图片描述](https://img-blog.csdnimg.cn/20190511220403949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NjM5MDM=,size_16,color_FFFFFF,t_70)

# PC1封装数据包

数据包封装的层次结构：

应用层：HTTP协议是生成针对目标WEB服务器的HTTP请求报文，该报文就是需要传递的数据。

传输层：HTTP协议使用的是TCP协议，为了方便通信，将HTTP请求报文按序号分为多个报文段(segment)，并对每个报文段进行封装。PC1使用本地一个大于1024以上的随机TCP源端口(这里假设是1030)建立到目的服务器TCP80号端口的连接，TCP源端口和目的端口加入到报文段中，学名叫协议数据单元(Protocol Data Unit, PDU)。因TCP是一个可靠的传输控制协议，传输层还会加入序列号、窗口大小等参数。

网络层：下沉到网络层后，封装网络层的头部，主要就是添加源和目的IP地址，成为数据包。用户通常使用主机名或域名来访问服务器，这时就需要通过应用层的DNS服务来通过域名查找IP地址，或逆向从IP地址反查域名。这里的源IP地址是193.1.1.2，目的IP地址是195.1.1.2。

数据链路层：下沉到数据链路层，封帧的头部，src mac和dst mac。PC1比较去往的目标IP，发现Server IP 195.1.1.2不在本地网络中，PC1通过查找本地路由表，会有一条默认路由指向网关R1，知道数据包要先发到网关R1的Fa0/0口。PC1查找本地arp cache，如果找到193.1.1.1对应的MAC地址则进行封装; 如果在ARP cache中没有找到193.1.1.1对应的MAC地址，则用ARP协议，査询到网关对应的MAC地址 “00-11-BC-7D-25-03” 。于是，这里的源MAC地址是PC1的MAC地址“00-1B-24-7D-25-01”，目的MAC地址是网关的MAC地址 “00-11-BC-7D-25-03。

从PC1发出的数据帧格式：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190511222910431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NjM5MDM=,size_16,color_FFFFFF,t_70)

物理层：数据链路层封装后的数据帧下沉到物理层，转换成二进制形式的比特(Bit)流，从PC1的网卡发送出去。

# 数据到达集线器

PC1发出的比特流到达集线器，集线器简单地对比特流转发，从除接收端口以外的所有端口转发出去。PC2接收到这个数据包，把比特流转换成帧上传到数据链路层，PC2比较数据帧的目的MAC地址，发现与本机网卡的MAC地址不同，PC2丢弃该数据帧，放弃处理，数据到达路由器。

# 数据到达路由器R1

路由器R1收到该比特流，转换成帧上传到数据链路层，路由器R1比较数据帧的目的MAC地址，发现与路由器接收端口Fa0/0(快速以太网，简写成Fa0/0，指的是0号插槽上编号为0的接口)的MAC地址相同，路由器知道该数据帧是发往本路由器的。路由器R1的数据链路层把数据帧进行解封装，然后上传到路由器R1的网络层，路由器R1看到数据包的目的IP地址是195.1.1.2，并不是发给本路由器的，需要路由器进行转发。

路由器R1査询自己的路由表，发现数据包应该从串行接口S1/1发出。路由器R1把数据包从Fa0/0接口交换到S1/1接口。

此时R1并不能直接把这个数据包发出去，因为在R1的Fa0/0接口被解封装，现在需要被重新再封装。在路由器的入接口解封装，在路由器的出接口需要再封装。网络层的封装并没有被解开，但并不意味着网络层的信息一点都没有改变，其实网络层的数据包中源和目的IP地址都没有被改变(除非在网络地址转换的情况下)，但TTL(生存周期)会减1。网络层把数据包交给下层的数据链路层，数据链路层需要封装二层的地址。串行链路不同于以太网，因为以太网是一个多路访问的网络，要定位到目的设备需要借助于MAC地址，但串行线路一般的封装协议都是PPP(Point-to-Point Protocol,点到点协议)或HDLC(High-Level Data Link Control,高级数据链路控制协议)封装，这种封装被用于点对点线路，也就是说，一根线缆只连接两台设备，一端发出，另一端肯定可以收到（有点像容器网络中用的veth）。假设串行线缆上使用的是PPP协议，则数据链路层封装的源和目的地址都是PPP。

数据链路层封装后的数据帧被传到物理层，转换成二进制形式的比特流，从路由器R1的S1/1接口发送出去

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190511223910854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NjM5MDM=,size_16,color_FFFFFF,t_70)

# 数据到达R2

路由器R2收到这个比特流，上传至数据链路层，数据链路层去掉PPP的封装。路由器R2査询数据包的目的IP地址，发现该IP网络直接连接在Fa0/0接口，路由器R2把数据包交换到Fa0/0接口。路由器查看本地的ARP缓存，如果找到195.1.1.2对应的MAC地址，则直接进行封裝；如果没有找到，则发送ARP的查询包。路由器R2发出数据帧的源地址是Fa0/0接口的MAC地址，目的地址是服务器网卡的MAC地址。

数据链路层封装后的数据帧被传到物理层，转换成二进制形式的比特流，从路由器R2的Fa0/0接口发送出去。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190511224023407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NjM5MDM=,size_16,color_FFFFFF,t_70)

# 交换机处理

路由器R2发出的比特流到达交换机，根据源MAC地址进行学习，根据目的MAC地址进行转发。交换机根据数据帧中的目的MAC地址査询MAC地址表，把比特流从对应的端口发送出去，交换机把比特流发往服务器，并没有发往PC3。

# 服务器处理

服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层，服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层。服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层。传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性。数据最后被传到服务器的应用层。

# 反向传输

服务器收到PC1发过来的数据后，对PC1进行响应。和PC1处理的过程类似，服务器也知道要发往一个远程的网络，数据链路层的目的MAC地址需要封装网关的MAC地址；网络层源和目的IP地址与PC1发送过来的包相反，即把源地址变成目的地址，目的地址变成源地址；传输层源和目的端口与PC1发送过来的包相反，即把源端口变成目的端口，目的端口变成源端口。
