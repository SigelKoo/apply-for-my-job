# 简述TCP三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

#### TCP连接传输三个阶段

```mermaid
graph LR
A(连接建立) --> B(数据传送) --> C(连接释放)
```

TCP连接的建立采用**客户服务器方式**，主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器。

#### 三次握手

![img](https://img-blog.csdnimg.cn/img_convert/83ae6f9265319f24240955f1b825bda1.png)

![image-20201229221150323](https://img-blog.csdnimg.cn/img_convert/a15100281b928a7118dd4a07320d38fd.png)

假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：

ROUND 1：

客户端发送连接请求报文段，无应用层数据。

```
SYN=1（表示建立连接），seq=x（随机，表示客户端向服务器端发送的起始字节序号为x）
```

ROUND 2：

服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。

```
SYN=1（表示建立连接），ACK=1（表示ack字段生效），seq=y（随机，表示服务器端向客户端发送的起始字节序号为y），ack=x+1（表示服务器端在下一次的报文中想要接收到以x+1序号起始的字节流，是ROUND1客户端发送的下一个字节流）
```

ROUND 3：

客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。

```
SYN=0，ACK=1（表示ack字段生效），seq=x+1（表示客户端向服务器端发送的起始字节序号为x+1），ack=y+1（表示客户器端在下一次的报文中想要接收到以y+1序号起始的字节流）
```

**SYN 在两种情况下会设置为 1**

1. 连接请求的报文中
2. 连接请求的确认报文中

#### 四次挥手

![image-20201229221852591](https://img-blog.csdnimg.cn/img_convert/f32f3db7249420ac0220cb55114214f6.png)

参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。

![image-20201229221859468](https://img-blog.csdnimg.cn/img_convert/b4f160ac04b5c0d0220ccde2b1a3f94b.png)

ROUND 1：

客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。

```
FIN=1（表示客户端请求释放连接），seq=u（表示客户端向服务器端发送的起始字节序号为u）
```

ROUND 2：

服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。

```
ACK=1（表示ack字段生效），seq=v（表示服务端向客户器端发送的起始字节序号为v），ack=u+1（表示服务器端上次接收到的最后一个字节序号为 u）
```

ROUND 3：

服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。

```
FIN=1（表示服务器端请求释放连接），ACK=1（表示ack字段生效），seq=w（表示服务端向客户端发送的起始字节序号为w），ack=u+1（客户端单方向释放了连接，不会再向服务器端发送数据，因此ack还是等于u+1）
```

ROUND 4：

客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。

```
ACK=1（表示ack字段生效），seq=u+1（表示客户端向服务器端发送的起始字节序号为u+1），ack=w+1（表示客户端端上次接收到的最后一个字节序号为w）
```

**FIN 在两种情况下会设置为 1**

1. 客户端的连接释放请求中
2. 服务器端的连接释放请求中

##### 为什么客户端需要等待 2MSL 的时间？

如果客户端在 ROUND 4 中发送的确认报文段在路上丢失，没有到达服务器端，服务器端在一定时间内没有收到确认就会重传 ROUND3 中的连接释放报文段。如果客户端刚发送完 ROUND4 中的确认报文段就直接关闭连接，那么服务器端就会一直不停地重传 ROUND3 中的连接释放报文段，这样会大大浪费服务器端的资源

如果客户端在 ROUND 4 中发送的确认报文段在路上丢失，没有到达服务器端，那么客户端在 2MSL 时间内还会收到来自服务器重传的连接释放报文段，然后客户端会重传确认报文段，直至服务器端接收成功为止
