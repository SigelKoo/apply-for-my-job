# go数据类型和零值

![img](https://img2018.cnblogs.com/blog/720430/201810/720430-20181026095557581-1443352750.png)

 ## 基本数据类型

fmt.Printf("%T", var_name)输出变量类型

unsafe.Sizeof(var_name)查看变量占用字节

### 布尔型

布尔类型也叫做bool类型，bool类型数据只允许取值true或false

bool类型占1个字节

bool类型适用于逻辑运算，一般用于流程控制

### 数值型

#### 整型

整型数据分为两类，有符号和无符号两种类型

**有符号：** int, int8, int16, int32, int64

**无符号：** uint, uint8, uint16, uint32, uint64, byte

不同位数的整型区别在于能保存整型数字范围的大小

有符号类型可以存储任何整数，无符号类型只能存储自然数

int和uint的大小和系统有关，32位系统表示int32和uint32，如果是64位系统则表示int64和uint64

byte与uint8类似，一般用来存储单个字符

在保证程序正确运行下，尽量使用占用空间小的数据类型

#### 浮点型

浮点型也就是小数类型，可以存放小数。比如6.6，-12.34

关于浮点数在机器中存放形式的简单说明，浮点数=符号位+指数位+尾数位

尾数部分可能丢失，造成精度损失。-123.0000901

如果我们要保存一个精度高的数，则应该选择float64

0.123可以简写成.123,也支持科学计数法表示:5.1234e2 等价于512.34

#### 字符

Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用byte来保存。

- 字符只能被单引号包裹，不能用双引号，双引号包裹的是字符串
- 当我们直接输出type值时，就是输出了对应字符的ASCII码值
- 当我们希望输出对应字符，需要使用格式化输出
- Go语言的字符使用UTF-8编码，英文字母占一个字符，汉字占三个字符
- 在Go中，字符的本质是一个整数，直接输出时，是该字符对应的UTF-8编码的码值。
- 可以直接给某个变量赋一个数字，然后按格式化输出时%c，会输出该数字对应的unicode字符
- 字符类型是可以运算的，相当于一个整数，因为它们都有对应的unicode码
- 如果我们保存的字符大于255，比如存储汉字，这时byte类型就无法保存，此时可以使用uint或int类型保存

1. 字符型存储到计算机中，需要将字符对应的码值（整数）找出来

   存储：字符 --> 码值 --> 二进制 --> 存储

   读取： 二进制 -->码值 --> 字符 --> 读取

2. 字符和码值的对应关系是通过字符编码表决定的（是规定好的）

3. Go语言的编码都统一成了UTF-8。非常的方便，很统一，再也没有编码乱码的困扰了

### 字符串型

字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本

1. 字符串一旦赋值了，就不能修改了:**在Go中字符串是不可变的。**

2. 字符串的两种标识形式

   - 双引号，会识别转义字符

     ```go
     var str = "abc\nabc" //输出时会换行
     ```

   - 反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码等效果

     ```go
     var str string = `abc\nabc` //输出时原样输出，不会转义
     ```

3. 字符串拼接方式"+"

   ```go
   var str string = "hello " + "world"
   str += "!"
   ```

4. 当一行字符串太长时，需要使用到多行字符串，可以使用如下处理

   ```go
   //正确写法
   str := "hello" + 
   	" world!"
   fmt.Println(str)
   
   //错误写法
   str := "hello "
   	+ "world!"
   fmt.Println(str)
   ```

## 值类型与引用类型

**值类型**：变量直接存储值，内存通常在**栈**中分配

**引用类型**：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值），内存通常在**堆**上分配，当没有任何变量应用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。

Golang中值类型和引用类型的区分

1. 值类型：基本数据类型、数组和结构体
2. 引用类型：指针、slice切片、map、管道chan、interface等都是引用类型

## 指针

1. 基本数据类型，变量存的就是值，也叫值类型
2. 获取变量的地址，用&，比如var num int，获取num的地址：&num
3. 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值，比如：var ptr *int = &num
4. 获取指针类型所指向的值，使用：*

## 零值

| 类型                                  | 默认值                       |
| :------------------------------------ | ---------------------------- |
| 有符号整型 int8 int16 int32 int64     | 0                            |
| 无符号整型 uint8 uint16 uint32 uint64 | 0                            |
| 特殊整型 int uint byte rune uintptr   | 0                            |
| 浮点型数 float32 float64              | 0.0                          |
| 复数类型 complex64 complex128         | 0+0i                         |
| 布尔类型 true false                   | false                        |
| 字符串类型 string                     | ""                           |
| 数组类型 [SIZE]TYPE                   | 根据type类型变化而变化       |
| 结构体类型 struct                     | 根据结构体内部类型变化而变化 |
| 指针 *TYPE                            | nil                          |
| 切片 []TYPE                           | nil                          |
| 字典 map [TYPE] [TYPE]                | nil                          |
| 通道 chan                             | nil                          |
| 函数 func                             | nil                          |
| 接口 interface                        | nil                          |

- 在 Go 中不同类型的 nil 是无法比较的，他们的大小也不一样
- 引用类型中的 slice map chan 要使用 make 函数初始化，如果常规 var NAME TYPE 的方式声明，将不能通过正常的赋值方法来修改默认值