### 匿名函数

函数可以像普通的类型（整数、字符串等）一样进行赋值，作为函数的参数传递，作为函数的返回值，go的函数只能返回匿名函数。

```go
var f = func(int) {}

func main() {
	f = func(i int) {
		fmt.Println(i)
	}
	f(6)
	f = func(i int) {
		fmt.Println(i * i)
	}
	f(6)
}
```

上述代码中，`f`可以被任何输入一个整型，无返回值的函数给赋值，这类似于C++中的函数指针。因此`f`可以看成是一个函数类型的变量。这样，可以动态的改变`f`的功能。匿名函数可以动态的创建，与之成对比的常规函数必须在包中编译前就定义完毕。匿名函数可以随时改变功能。

### 闭包

闭包是匿名函数与匿名函数所引用环境的**组合**。匿名函数有动态创建的特性，该特性使得匿名函数不用通过参数传递的方式，就可以直接引用外部的变量。

这就类似于常规函数直接使用全局变量一样，个人理解为：匿名函数和它引用的变量以及环境，类似常规函数引用全局变量处于一个包的环境。

```go
func main() {
	n := 0
	f := func() int {
		n += 1
		return n
	}
	fmt.Println(f())
	fmt.Println(f())
}
```

就是一个闭包，类比于常规函数+全局变量+包。`f`不仅仅是存储了一个函数的返回值，它同时存储了一个闭包的状态。

#### 闭包作为函数返回值

匿名函数作为返回值，不如理解理解为闭包作为函数的返回值

```go
func increase() func() int {
	n := 0
	return func() int {
		n++
		return n
	}
}

func main() {
	in := increase()
	fmt.Println(in())
	fmt.Println(in())
}
```

闭包被返回赋予一个同类型的变量时，同时赋值的是整个闭包的状态，该状态会一直存在外部被赋值的变量`in`中，直到`in`被销毁，整个闭包也被销毁。

#### 并发中的闭包

要处理好循环中的闭包引用的外部变量

```go
func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			fmt.Println(i)
			wg.Done()
		}()
	}
	wg.Wait()
}
```

这种现象的原因在于闭包共享外部的变量i，注意到，每次调用go就会启动一个goroutine，这需要一定时间；但是，启动的goroutine与循环变量递增不是在同一个goroutine，可以把i认为处于主goroutine中。启动一个goroutine的速度远小于循环执行的速度，所以即使是第一个goroutine刚起启动时，外层的循环也执行到了最后一步了。由于所有的goroutine共享i，而且这个i会在最后一个使用它的goroutine结束后被销毁，所以最后的输出结果都是最后一步的i==5。

```go
func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			fmt.Println(i)
			wg.Done()
		}()
		time.Sleep(1 * time.Second)
	}
	wg.Wait()
}

```

每一步循环至少间隔一秒，而这一秒的时间足够启动一个`goroutine`了，因此这样可以输出正确的结果。

一般采取以下两个方法：

1. 共享的环境变量作为函数参数传递:

```go
func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			fmt.Println(i)
			wg.Done()
		}(i)
	}
	wg.Wait()
}
```

输出结果不一定按照顺序，这取决于每个`goroutine`的实际情况，但是最后的结果是不变的。可以理解为，函数参数的传递是瞬时的，而且是在一个`goroutine`执行之前就完成，所以此时执行的闭包存储了当前`i`的状态。

2. 使用同名的变量保留当前的状态

```go
func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		i := i
		go func() {
			fmt.Println(i)
			wg.Done()
		}()
	}
	wg.Wait()
}
```

同名的变量`i`作为内部的局部变量，覆盖了原来循环中的`i`，此时闭包中的变量不在是共享外循环的`i`，而是都有各自的内部同名变量`i`，赋值过程发生于循环`goroutine`，因此保证了独立。



#### go闭包书中概念

Go语言编程书中

- **闭包的概念：**是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。
- **闭包的价值：** 闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。

Go语言中的闭包同样也会引用到函数外的变量。闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。

#### 概念和作用


特征：
- 函数内部包含匿名子函数，子函数以return返回
- 子函数可以访问函数内部的局部变量
- 被子函数持有的局部变量不回被销毁

作用：

优点

- 访问函数的私有变量
- 外部函数为全局函数的情况下，保证内部私有变量不被回收
- 类似类的封装，数据为私有变量，操作为return的匿名函数

缺点

- 内存占用，无法回收