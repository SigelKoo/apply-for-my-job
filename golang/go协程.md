# go协程

go的协程依赖于线程进行

1. 多个协程可由一个或多个线程管理，协程的调度发生在其所在的线程中（将P设置为1，并发执行两个协程，可以随时中断，执行一段协程A，执行一段协程B。A与B都运行在同一个线程中），协程间调度不是线程的切换，而是纯用户态的协程调度
2. 协程可以被调度，调度策略由用户态代码定义，即可被高度自定义实现
3. 执行效率高，协程的调度切换不是线程切换，而是调度器控制，没有线程切换的开销；不需要多线程的锁机制，也不存在线程中的同时写变量冲突
4. 占用内存少，使用在线程中的内存，意味着一个线程的内存可以供多个协程使用

| 比较         | 线程                                                         | 协程                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据存储     | 内核态的内存空间                                             | 一般是线程提供的用户态内存空间                               |
| 切换操作     | 操作最终在内核层完成，应用层需要调用内核层提供的 syscall 底层函数 | 应用层使用代码进行简单的现场保存和恢复即可                   |
| 任务调度     | 由内核实现，抢占方式，依赖各种锁                             | 由用户态的实现的具体调度器进行。例如 go 协程的调度器         |
| 语音支持程度 | 绝大部分编程语言                                             | 部分语言：Lua，Go，Python ...                                |
| 实现规范     | 按照现代操作系统规范实现                                     | 无统一规范。在用户态由开发者实现，高度自定义，比如只支持单线程的线程。不同的调度策略，等等 |