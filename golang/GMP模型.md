# Golang的协程调度器原理及GMP设计思想？

### Golang“调度器器”由来

#### 单进程时代的两个问题

1. 单一执行流程、计算机只能一个任务一个任务处理

2. 进程阻塞所带来的CPU浪费时间

#### 多进程、多线程的问题

**设计变得复杂**

1. 进程/线程的数量越多，切换成本就越大，也就越浪费
2. 多线程伴随着同步竞争（锁、竞争资源冲突）

进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。

**问题**

- 高内存占用
  - 进程占用内存：虚拟内存4GB
  - 线程占用内存：4MB
- 高CPU调度消耗

#### 协程的问题

##### 协程

一个线程分为“内核态“线程和”用户态“线程，一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。

![img](https://img.kancloud.cn/47/e3/47e396eea8f0e71532356197412d52f1_1294x1106.png)

内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)"

![img](https://img.kancloud.cn/45/9d/459db145d4e702994548a1757238946f_1248x1064.png)

既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上

##### N:1

![img](https://img.kancloud.cn/f8/d7/f8d715899f6db333d37f2bf738116bfd_1352x1092.png)

N个协程绑定1个线程

缺点：无法利用多个CPU；出现阻塞的瓶颈

##### 1:1

![img](https://img.kancloud.cn/cf/9a/cf9a59f9776bf4c9cbbad6103b6c5e5a_1322x1112.png)

1个协程绑定1个线程

缺点：跟多线程/多进程模型相同；切换协程成本昂贵

##### M:N关系

![img](https://img.kancloud.cn/00/37/0037f6c2e12ad82a912990bba3e0085c_1336x1112.png)

协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程

缺点：多度依赖协程调度器的优化和算法

#### Go语言的协程goroutine

goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。

Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，`runtime`会自动为goroutine分配。

Goroutine特点：

- 占用内存更小（几kb）
- 调度更灵活(runtime调度)

### 被废弃的goroutine调度器

 好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。

Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？

> 大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。

[![img](https://github.com/aceld/golang/raw/main/images/13-gm.png)](https://github.com/aceld/golang/blob/main/images/13-gm.png)

 下面我们来看看被废弃的golang调度器是如何实现的？

[![img](https://github.com/aceld/golang/raw/main/images/14-old%E8%B0%83%E5%BA%A6%E5%99%A8.png)](https://github.com/aceld/golang/blob/main/images/14-old调度器.png)

 M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。

老调度器有几个缺点：

1. 创建、销毁、调度G都需要每个M获取锁，这就形成了**激烈的锁竞争**。
2. M转移G会造成**延迟和额外的系统负载**。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了**很差的局部性**，因为G’和G是相关的，最好放在M上执行，而不是其他M'。
3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

### goroutine调度器的GMP模型的设计思想

#### GMP

![img](https://img.kancloud.cn/6b/db/6bdb04101cc63565c17cd8fcaba17321_1068x876.png)

![img](https://img.kancloud.cn/eb/fe/ebfe3e28315f12a08fbb4ffaee32e046_1024x768.png)

线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。

##### 结构

1. 全局队列：存放等待运行的G
2. P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. P列表：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`（可配置）个
4. M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

**goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行**。

##### P与M的个数

- P数量：由启动时环境变量`$GOMAXPROCS`或者是由`runtime`的方法`GOMAXPROCS()`决定
- M数量：go程序启动时，会设置的最大数量，默认10000。一个M阻塞了，会创建新的M

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来

##### P和M何时会被创建

- P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P
- M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M

#### 调度器的设计策略

- 复用线程：避免频繁创建、销毁进程，而是对线程的复用
  - work stealing：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程
  - hand off： 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行
- 利用并行：`GOMAXPROCS`设置P的数量，最多有`GOMAXPROCS`个线程分布在多个CPU上同时运行
- 抢占：一个goroutine最多占用CPU 10ms，防止其他goroutine饥饿，这就是goroutine不同于coroutine的一个地方
- 全局G队列：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G

#### go func() 调度流程

![img](https://img.kancloud.cn/76/4f/764f7be119026cc16314e87628e4013f_1920x1080.jpeg)

1. 我们通过 go func()来创建一个goroutine
2. 有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中
3. G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会去其他的MP组合偷取一个可执行的G来执行
4. 一个M调度G执行的过程是一个循环机制
5. 当M执行某一个G时候如果发生了syscall或其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程（如果有空闲的线程可用就复用空闲线程）来服务于这个P
6. 当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。

#### 调度器的生命周期

![img](https://img.kancloud.cn/b3/10/b31027eeb493fa86654b41d46f34a98b_439x872.png)

###### M0

`M0`是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了

###### G0

`G0`是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度的G，G0不指向任何可执行的函数，每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0

##### 栗子

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello world")
}
```

1. runtime创建最初的线程M0和第一个goroutine的G0，并把2者关联
2. 调度器初始化：初始化M0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表
3. 示例代码中的main函数是`main.main`，`runtime`中也有1个main函数——`runtime.main`，代码经过编译后，`runtime.main`会调用`main.main`，程序启动时会为`runtime.main`创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列
4. 启动M0，M0已经绑定了P，会从P的本地队列获取G，获取到main goroutine
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，这样重复下去，直到`main.main`退出，`runtime.main`执行Defer和Panic处理，或调用`runtime.exit`退出程序

调度器的生命周期几乎占满了一个Go程序的一生，`runtime.main`的goroutine执行之前都是为调度器做准备工作，`runtime.main`的goroutine运行，才是调度器的真正开始，直到`runtime.main`结束而结束

### Go调度器GMP调度场景

1. 场景1：G1创建G2

   P拥有G1，M1获取P后开始运行G1，G1使用`go func()`创建了G2，为了**局部性**，G2优先加入到P1的本地队列。

   ![img](https://img.kancloud.cn/2d/eb/2debce43683adca1acb5ca5210057232_1074x900.png)

2. 场景2：G1执行完毕

   G1运行完成后（函数：`goexit`），M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：`schedule`）。从P的本地队列取G2，从G0切换到G2，并开始运行G2（函数：`execute`）。实现了线程M1的复用。

   ![img](https://img.kancloud.cn/93/65/93658da22081d52ed1caf32f42145e5a_1624x984.png)

3. 场景3：G2开辟过多的G

      假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。

      ![img](https://img.kancloud.cn/64/15/6415bfab3595fc22090595acc7c1b4b1_1104x1030.png)

4. 场景4：G2本地满再创建G7，基于场景3触发

   G2在创建G7的时候，发现P1的本地队列已满，需要执行**负载均衡**（把P1中本地队列中前一半的G，还有新创建G**转移**到全局队列）。目的：1.保证队列不是满的；2.保证G7也可以执行；3.打乱顺序保证谁都没有优先级先执行

   ![img](https://img.kancloud.cn/d1/27/d12776bfd5cd10f8c1979c61d467499c_1120x1068.png)

5. 场景5：G2本地未满创建G8，基于场景4触发

   G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。

   ![img](https://img.kancloud.cn/7a/01/7a01ac7a3a4fd14493224827409f77f8_1036x1048.png)

   G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。

6. 场景6：唤醒正在休眠的M

   规定：**在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行**。
   
   ![img](https://img.kancloud.cn/60/6a/606acb1e4bf6b85c352b213744771601_1976x1098.png)
   
   假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程**（没有G但为运行状态的线程，不断寻找G）**

7. 场景7：被唤醒的M2从全局队列取批量G，基于场景6

   M2尝试从全局队列（简称“GQ”）取一批G放到P2的本地队列（函数：`findrunnable()`）。M2从全局队列取的G数量符合下面的公式：

   ```
   n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
   ```

   至少从全局队列取1个G，但每次不要从全局队列移动太多的G到P本地队列，给其他P留点。这是**从全局队列到P本地队列的负载均衡**。

   ![img](https://img.kancloud.cn/d6/46/d646d4d213d7b603f211cd74ba0dd391_1920x1080.jpeg)

   假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。

8. 场景8：M2从M1中偷取G，基于场景7

   假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了，如场景8图的左半部分。

   ![img](https://img.kancloud.cn/8a/bf/8abf6b47b0871011b6f18f55365c1774_1632x1130.png)

   尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。

9. 场景9：自旋线程的最大限制

      G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于**自旋状态**，它们不断寻找goroutine。

      ![img](https://img.kancloud.cn/10/b4/10b49d04c42c3d688986ff41005ee63b_1682x1084.png)

      为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU。为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们**希望当有新goroutine创建时，立刻能有M运行它**，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有`GOMAXPROCS`个自旋的线程(当前例子中的`GOMAXPROCS`=4，所以一共4个P)，多余的没事做线程会让他们休眠。

10. 场景10：G发生系统调用/阻塞

      假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程（没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M>=P, 大部分都是M在抢占需要运行的P），G8创建了G9，G8进行了**阻塞的系统调用**，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。

      ![img](https://img.kancloud.cn/54/9a/549aa458fab4c3e7cac5086d9326c1d2_2642x1494.png)

      为什么不使用M3与M4的，因为大家抢占G，而不是抢占P，而M3和M4拥有P，所以不用抢

11. 场景11：G发生系统调用/非阻塞

       G8创建了G9，假如G8进行了**非阻塞系统调用**。

       ![img](https://img.kancloud.cn/24/6c/246c03cdf1eb8307b70865d0debaa1f0_2678x1466.png)

       M2和P2会解绑，但M2会记住P2，然后G8和M2进入**系统调用**状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态（长时间休眠等待GC回收销毁，若M2，M6长时间未唤醒，则进行销毁）