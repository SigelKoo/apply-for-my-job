go语言的channel的实现原理

sync.Map

channel关闭以后，再往其发送或接收，会发生什么

go语言的并发问题，面试官输入了一段代码：
func main() {
for i := 0; i < 10; i++ {
go fmt.Println(i)
}
}
问会怎么输出。

然后又问怎么改代码能让它顺序输出1.....9

goroutine为什么比线程开销小，实现原理

作者：SSSSSSS牛客
链接：https://www.nowcoder.com/discuss/573929?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack
来源：牛客网



### 在go语言中，new和make的区别？

new 的作用是初始化一个指向类型的指针(*T) new函数是内建函数，函数定义：func new(Type) \*Type使用new函数来分配空间。传递给new 函数的是一个类型，不是一个值。返回值是 指向这个新分配的零值的指针。
make 的作用是为 slice，map 或 chan 初始化并返回引用(T)。make函数是内建函数，函数定义：func make(Type, size IntegerType) Type 第一个参数是一个类型，第二个参数是长度，返回值是一个类型。
make(T, args)函数的目的与new(T)不同。它仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是T\*）的一个初始化的（不是零值）的实例。

### 在go语言中，Printf()、Sprintf()、Fprintf()函数的区别用法是什么？

都是把格式好的字符串输出，只是输出的目标不一样：
Printf()，是把格式字符串输出到标准输出（一般是屏幕，可以重定向）。
Printf() 是和标准输出文件(stdout)关联的,Fprintf 则没有这个限制.
Sprintf()，是把格式字符串输出到指定字符串中，所以参数比printf多一个char*。那就是目标字符串地址。
Fprintf()， 是把格式字符串输出到指定文件设备中，所以参数笔printf多一个文件指针FILE*。主要用于文件操作。Fprintf()是格式化输出到一个stream，通常是到文件。

### 说说go语言中，数组与切片的区别？

(1). 数组 数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。 数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。
数组需要指定大小，不指定也会根据初始化的自动推算出大小，不可改变 ;
数组是值传递;
数组是内置(build-in)类型,是一组同类型数据的集合，它是值类型，通过从0开始的下标索引访问元素值。在初始化后长度是固定的，无法修改其长度。当作为方法的参数传入时将复制一份数组而不是引用同一指针。数组的长度也是其类型的一部分，通过内置函数len(array)获取其长度。
数组定义：
var array [10]int
var array = [5]int{1,2,3,4,5}
(2). 切片 切片表示一个拥有相同类型元素的可变长度的序列。 切片是一种轻量级的数据结构，它有三个属性：指针、长度和容量。
切片不需要指定大小;
切片是地址传递;
切片可以通过数组来初始化，也可以通过内置函数make()初始化 .初始化时len=cap,在追加元素时如果容量cap不足时将按len的2倍扩容；
切片定义：
var slice []type = make([]type, len)

### 解释以下命令的作用？

[复制代码](#)

```
go env, go run, go build, go get, go install, go clean, go version``go env: #用于查看go的环境变量``go run: #用于编译并运行go源码文件``go build: #用于编译源码文件、代码包、依赖包``go get: #用于动态获取远程代码包``go install: #用于编译go文件，并将编译结构安装到bin、pkg目录``go clean: #用于清理工作目录，删除编译和安装遗留的目标文件``go version: #用于查看go的版本信息
```

### 说说go语言中的协程？

协程和线程都可以实现程序的并发执行；
通过channel来进行协程间的通信；
只需要在函数调用前添加go关键字即可实现go的协程，创建并发任务；
关键字go并非执行并发任务，而是创建一个并发任务单元；

### 说说go语言中的for循环？

for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环 for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量

### 说说go语言中的switch语句？

单个case中，可以出现多个结果选项
只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case

### go语言中没有隐藏的this指针，这句话是什么意思？

方法施加的对象显式传递，没有被隐藏起来
golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达
方法施加的对象不需要非得是指针，也不用非得叫this

### go语言中的引用类型包含哪些？

数组切片、字典(map)、通道（channel）、接口（interface）

### go语言中指针运算有哪些？

可以通过“&”取指针的地址
可以通过“*”取指针指向的数据

### 说说go语言的main函数

main函数不能带参数
main函数不能定义返回值
main函数所在的包必须为main包
main函数中可以使用flag包来获取和解析命令行参数

### 说说go语言的同步锁？

(1) 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex
(2) RWMutex在读锁占用的情况下，会阻止写，但不阻止读
(3) RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占

### 说说go语言的channel特性？

A. 给一个 nil channel 发送数据，造成永远阻塞
B. 从一个 nil channel 接收数据，造成永远阻塞
C. 给一个已经关闭的 channel 发送数据，引起 panic
D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
E. 无缓冲的channel是同步的，而有缓冲的channel是非同步的

### go语言触发异常的场景有哪些？

A. 空指针解析
B. 下标越界
C. 除数为0
D. 调用panic函数

### 说说go语言的beego框架？

### go语言中，GoStub的作用是什么？

### 说说go语言的select机制？

A. select机制用来处理异步IO问题
B. select机制最大的一条限制就是每个case语句里必须是一个IO操作
C. golang在语言级别支持select关键字

### 说说进程、线程、协程之间的区别？

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元；
同一个进程中可以包括多个线程；
进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束；
线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程；
进程的创建调用fork或者vfork，而线程的创建调用pthread_create；
线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源；
进程是资源分配的单位
线程是操作系统调度的单位
进程切换需要的资源很最大，效率很低 线程切换需要的资源一般，效率一般 协程切换任务资源很小，效率高 多进程、多线程根据cpu核数不一样可能是并行的 也可能是并发的。协程的本质就是使用当前进程在不同的函数代码中切换执行，可以理解为并行。 协程是一个用户层面的概念，不同协程的模型实现可能是单线程，也可能是多线程。
进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。（全局变量保存在堆中，局部变量及函数保存在栈中）
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是这样的)。
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。
协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

### golang 两个协成交替打印1-100的奇数偶数

[复制代码](#)

```
package` `main``import` `(``  ``"fmt"``  ``"time"``)``var POOL = ``100``func groutine1(p chan ``int``) {``  ``for` `i := ``1``; i <= POOL; i++ {``    ``p <- i``    ``if` `i%``2` `== ``1` `{``      ``fmt.Println(``"groutine-1:"``, i)``    ``}``  ``}``}``func groutine2(p chan ``int``) {``  ``for` `i := ``1``; i <= POOL; i++ {``    ``<-p``    ``if` `i%``2` `== ``0` `{``      ``fmt.Println(``"groutine-2:"``, i)``    ``}``  ``}``}``func main() {``  ``msg := make(chan ``int``)``  ``go groutine1(msg)``  ``go groutine2(msg)``  ``time.Sleep(time.Second * ``1``)``}
```

### golang互斥锁的两种实现

用Mutex实现

[复制代码](#)

```
package` `main``import` `(``  ``"fmt"``  ``"sync"``)``var num ``int``var mtx sync.Mutex``var wg sync.WaitGroup``func add() {``  ``mtx.Lock()``  ``defer mtx.Unlock()``  ``defer wg.Done()``  ``num += ``1``}``func main() {``  ``for` `i := ``0``; i < ``100``; i++ {``    ``wg.Add(``1``)``    ``go add()``  ``}``  ``wg.Wait()``  ``fmt.Println(``"num:"``, num)``}
```

使用chan实现

[复制代码](#)

```
package` `main``import` `(``  ``"fmt"``  ``"sync"``)``var num ``int``func add(h chan ``int``, wg *sync.WaitGroup) {``  ``defer wg.Done()``  ``h <- ``1``  ``num += ``1``  ``<-h``}``func main() {``  ``ch := make(chan ``int``, ``1``)``  ``wg := &sync.WaitGroup{}``  ``for` `i := ``0``; i < ``100``; i++ {``    ``wg.Add(``1``)``    ``go add(ch, wg)``  ``}``  ``wg.Wait()``  ``fmt.Println(``"num:"``, num)``}
```

### Golang的channel的实现方式、mutex和channel作并发控制你喜欢用哪个，哪个快，为什么。

### Golang的GPM

[复制代码](#)

```
https:``//juejin.cn/post/6844904130398404616
```



作者：自信不回头
链接：https://www.nowcoder.com/discuss/359313?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack&subType=2
来源：牛客网



4.说一下go协程设计 

 由于自己用c实现过协程，所以答的很随意。讲了一下函数调用约定，栈布局，上下文切换，x86寄存器，又讲了一下用gcc的"-finstrument-functions"。然后讲了一下go的调度思路。 

 参考go[源码]()runtime.schedule 

 5.说一下epoll 

 讲了epoll跟select的区别，然后回答了et和lt的区别以及使用场景。又回答了一下go的设计思路。 

 参考man 7 epoll和go[源码]() runtime.netpoll

讲一下raft[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)

讲了一下leader选举，日志复制，应用到上层状态机这三部分。

讲一下cap定理

回答了一下概念。然后结合 mysql(同步复制，异步复制),kafka(isr)，etcd(raft),zoo[keep](https://www.nowcoder.com/jump/super-jump/word?word=keep)er(zab)讲了一下各自是什么系统。

5.go的hashmap如何实现的

讲了一下均摊扩容，然后问了一些很细节的问题，估计是看的某个issue。

1. zab，raft，paxos协议的区别。

回答了一下raft，然后有点蒙也不知道回答什么。

\- go 语言中 hash 表

\- go 语言中切片的数据结构

\- [区块链](https://www.nowcoder.com/jump/super-jump/word?word=区块链)中存储、安全、网络分别介绍

\- gossip 协议

\- [区块链](https://www.nowcoder.com/jump/super-jump/word?word=区块链)中用到的图结构，hashgraph 共识机制

\- [区块链](https://www.nowcoder.com/jump/super-jump/word?word=区块链)存储时使用的数据结构有哪些

\- go语言中 channel 和临界区各自使用的场景

怎么原生支持高并发？

介绍一下协程

问了点go的特性，垃圾回收，反射等；