以太坊底层核心技术

数据区块

```go
type Block struct {
   header       *Header //区块头
   uncles       []*Header    //防止攻击的
   transactions Transactions //交易列表
 
   // caches
   hash atomic.Value
   size atomic.Value
 
   // Td is used by package core to store the total difficulty
   // of the chain up to and including the block.
   td *big.Int  // 难度值总和
 
   // These fields are used by package eth to track
   // inter-peer block relay.
   ReceivedAt   time.Time  // 打包时间
   ReceivedFrom interface{}
}

type Header struct {
   ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
   UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
   Coinbase    common.Address `json:"miner"            gencodec:"required"`
   Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
   TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
   ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
   Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
   Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
   Number      *big.Int       `json:"number"           gencodec:"required"`//区块高度
   GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
   GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
   Time        *big.Int       `json:"timestamp"        gencodec:"required"`
   Extra       []byte         `json:"extraData"        gencodec:"required"`
   MixDigest   common.Hash    `json:"mixHash"`
   Nonce       BlockNonce     `json:"nonce"`
}

// Body is a simple (mutable, non-safe) data container for storing and moving
// a block's data contents (transactions and uncles) together.
type Body struct {
    Transactions []*Transaction
    Uncles       []*Header
}
```

Geth P2P网络

使用Kademlia，以太坊网络中，每个客户端节点都配备有一个 enodeID，之后将此 ID 用 SHA3 算法散列为一个 256 位的值。

Kademlia 使用 XOR 操作定义距离，因此两个 256 位的数字之间的距离是他们的按位异或值。寻找距离最近的16个节点。

![科普 | 理解以太坊的 P2P 网络](https://img.chainnews.com/material/images/83578c4838cb73e672af3a4b7b920db6.jpg-article)

Geth 使用 UDP 连接交换 P2P 网络的信息。有 4 种类型的 UDP 消息。一条ping消息请求一条pong消息作为返回。此对消息用来判断相邻节点是否可响应。一条findnode消息请求一条neighbors消息（其中包含 16 个已经被响应节点知晓的节点列表）作为返回。当建立好对等节点的连接之后，Geth 节点通过加密和认证的 TCP 连接来交换区块链信息。

Geth 客户端用两种数据结构存储其他节点的信息。第一种是称作 db 的长期数据库，它存储在磁盘内，客户端重启之后数据也是持久存在的。db 中包含客户端交互过的每个节点信息。db 的每条记录包含节点 ID，IP 地址，TCP 端口，UDP 端口，（此客户端）最后一次向（记录中）节点发送 ping 的时间，最后一次从节点收到 pong 的时间，节点响应 findnode 消息的失败次数。如果最后一次从一个节点收到 pong 消息的时间超过了一天，此节点将会被移出 db。

第二种数据结构是称作 table 的短期数据库。当客户端重启时 table 是空的。table 包含 256 个桶，每个桶存储至多 16 条记录。每条记录存储其他以太坊节点的信息——节点的 ID，IP 地址， TCP 端口和 UDP 端口。如果记录中的某个节点对于 findnode 消息连续响应失败，多于 4 次时将被移出 table。

当某个客户端第一次启动时，它的 db 是空的，只知道 6 个硬编码的引导节点。随后，当客户端开始发现对等节点，客户端依据上面描述的机制，将节点加入 db 和 table。

传播机制

交易传播开始于创建（或从离线接收）签名交易的以太坊节点。交易被验证，然后传送到直接连接到始发节点的所有其他以太坊节点。每个邻居节点在收到交易后立即验证交易。如果他们同意这是有效的，他们会保存一份副本并将其传播给所有的邻居（除了它的邻居）。

结果，交易从始发节点向外涟漪式地遍历网络，直到网络中的所有节点都拥有交易的副本。

验证机制

每个矿工在提交一个区块到区块链上的时候都会提供一个数学机制的“证明”，这个证明就像一个保证：如果这个证明存在，那么这个区块一定是有效的。

通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为工作量证明(proof of work)。