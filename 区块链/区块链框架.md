## EVM

用来处理智能合约的部署和执行。除了在外部账户之间的简单转账交易以外，其他所有涉及状态更新的操作都是通过EVM来计算的。从高层抽象的角度，运行在以太坊区块链上的EVM可以被想象成一个包含了数百万可执行对象的全球化的去中心化计算机，这些可执行对象都拥有它们各自的永久数据存储。

EVM是一个“准”图灵完备的状态机，因为在其中进行的任意智能合约的执行都必须限定在一个由可用的gas总量所限制的、有限的计算步骤数量之内。

EVM有一个基于栈的架构，在一个栈中保存了所有内存数值。EVM的数据处理单位被定义为256位的“字”（这主要是为了方便处理哈希运算和椭圆曲线运算操作），并且它还具有以下数据组件：

- 一个不可变的程序代码存储区ROM，加载了要执行的智能合约字节码。

- 一个内容可变的内存，它被严格地初始化为全0数值。

- 一个永久的存储，它是作为以太坊状态的一部分存在的，也会被初始化为全0。

在执行过程中还有一些可用的环境变量和数据，我们会在本章的后续段落中看到更多细节。

EVM没有可调度性，因为执行顺序是由其外部所组织好的，也就是由以太坊客户端通过验证区块中的交易来决定哪些智能合约应该运行，以及它们的执行顺序应该是什么。从这个角度讲，以太坊世界计算机就像JavaScript引擎那样是“单线程”的。EVM既没有任何“系统接口”，也没有“硬件支持”，因为并没有任何物理机器需要与之交互。以太坊世界计算机是完全虚拟化的。

EVM指令集（字节码）

EVM指令由很多标准机器码指令组成，包含：

- 算术和位运算逻辑操作

- 执行上下文查询

- 栈、内存和存储访问

- 处理流程操作

- 日志、跳转和其他操作

作为标准字节码操作的补充，EVM还可以访问账户信息（例如地址和余额）以及区块信息（比如区块号和当前的gas价格）。

让我们通过查看那些可用的字节码和它们的功能来更详细地了解EVM吧。就像我们期待的那样，所有操作都会从栈中获取操作数，而将结果（如果有的话）放回到栈顶。

算术操作

```
ADD                     //对栈顶的两个条目进行加法
MUL                     //对栈顶的两个条目进行乘法
SUB                     //对栈顶的两个条目进行减法
DIV                     //整数除法
SDIV                    //带符号的整数除法
MOD                     //模运算
SMOD                    //带符号的模运算
ADDMOD                  //先做加法然后进行模运算
MULMOD                  //先做乘法然后进行模运算
EXP                     //乘方运算
SIGNEXTEND              //符号扩展操作
SHA3                    //对内存中的一段数据进行Keccak-256哈希运算
```

注意，所有算术运算都对2256取了模（除非明确标注为不做此处理），并且0的0次方，即00，会被计算为1。

栈操作

```
POP                  //移除栈顶的一个条目
MLOAD                //从内存中加载一个“字”
MSTORE               //向内存中保存一个“字”
MSTORE8              //向内存中保存一个字节
SLOAD                //从存储中加载一个“字”
SSTORE               //向存储中保存一个“字”
MSIZE                //获得当前已分配内存的字节数大小
PUSHx                //将x字节的一个条目放到栈顶，其中x的数值可以是1到32（一个整“字”）的整数
DUPx                 //复制栈顶的第x个条目到栈顶，其中x的数值可以是1到16的整数
SWAPx                //交换栈顶条目和第x+1个栈内条目，其中x的数值可以是1到16的整数
```

处理流程操作

```
STOP                 //停止执行
JUMP                 //将程序计数器设置为任意数值
JUMPI                //基于条件修改程序计数器的值
PC                   //取得程序计数器的数值（增加这个指令本身的计数之前的数值）
JUMPDEST             //标记一个有效的跳转地址
```

系统操作

```
LOGx                  //增加一条带有x个主题的日志数据，其中x的数值可以是0到4的整数
CREATE                //用关联代码创建一个新账户
CALL                  //向另一个账户发起消息调用，也就是运行另一个账户的代码
CALLCODE              //用另一个账户的代码向当前账户发起消息调用
RETURN                //停止执行并返回输出数据
DELEGATECALL          //用其他账户的代码向当前账户发起消息调用，但sender和value的数值保持不变
STATICCALL            //向一个账户发起静态消息调用
REVERT                //停止执行并撤销状态修改，但保持返回数据和剩余gas
INVALID               //预设的无效指令
SELFDESTRUCT          //停止执行，并将当前账户标记为自毁账户
```

逻辑操作

```
LT                         //小于比较操作
GT                         //大于比较操作
SLT                        //有符号小于比较操作
SGT                        //有符号大于比较操作
EQ                         //等于比较操作
ISZERO                     //简单的非操作
AND                        //按位与操作
OR                         //按位或操作
XOR                        //按位异或操作
NOT                        //按位非操作
BYTE                       //从一个“字”中取得一个字节数据
```

环境操作

```
GAS                    //取得可用gas的数量（减去这个指令的消耗）
ADDRESS                //取得当前账户的地址
BALANCE                //取得指定账户的余额
ORIGIN                 //取得触发这次EVM执行的EOA地址
CALLER                 //取得当前执行的调用者地址
CALLVALUE              //取得当前执行的调用者所发送的以太币数量
CALLDATALOAD           //取得当前执行的输入数据
CALLDATASIZE           //取得当前输入数据的字节大小
CALLDATACOPY           //将当前输入数据复制到内存中
CODESIZE               //当前环境运行的代码的字节大小
CODECOPY               //将当前环境运行的代码复制到内存中
GASPRICE               //取得由初始交易所制定的gas价格
EXTCODESIZE            //取得任意账户代码的字节大小
EXTCODECOPY            //将任意账户的代码复制到内存中
RETURNDATASIZE         //取得在当前环境中的前一次调用的输出数据字节大小
RETURNDATACOPY         //将前一次调用的输出数据复制到内存中
```

区块操作

```
BLOCKHASH               //取得最新的256个完整区块中某个区块的哈希
COINBASE                //取得当前区块的区块奖励受益人地址
TIMESTAMP               //取得当前区块的时间戳
NUMBER                  //取得当前区块的区块号
DIFFICULTY              //取得当前区块的难度
GASLIMIT                //取得当前区块的gas上限
```

EVM的任务是基于以太坊协议、根据智能合约代码的执行来计算合法的状态转换，用以更新以太坊的状态。这也就是将以太坊作为基于交易的状态机所描述的层面，同时也是外部用户（即账户持有人和矿工）通过创建、接受交易和对交易进行排序打包来引发状态转换所反映的层面。讲到这里，我们就需要去理解以太坊状态的构成了。

状态

与任何计算系统一样，状态概念也很重要。就像CPU跟踪执行过程一样，EVM必须跟踪各种组件的状态以支持交易。这些组件的状态最终会推动总体区块链的变化程度。这方面导致将以太坊描述为基于交易的状态机，包含以下组件：

世界状态：160位地址标识符和账户状态之间的映射，在不可变的Merkle Patricia Tree数据结构中维护

账户状态：nonce（表示从该相应账户发送的交易数量的值）；balance（账户地址拥有的wei的数量）；storageRoot（Merkle Patricia Tree根节点的256位哈希值）；codeHash：各个账户的EVM代码的不可变哈希值

存储状态：在EVM上运行时维护的账户特定状态信息

区块状态：blockhash（最近完成的块的哈希值）、coinbase（收件人的地址）、timestamp（当前块的时间戳）、number（当前块的编号）、difficulty（当前区块的难度）、gaslimit（当前区块的gas限制）

运行环境信息：gasprice（当前汽油价格，由交易发起人指定）、codesize（交易代码库的大小）、caller（执行当前交易的账户的地址）、origin（当前交易原始发件人的地址）

状态转换使用以下函数计算：以太坊状态转换函数（用于计算valid state transition）、区块终结状态转换函数（用于确定最终块的状态，作为挖矿过程的一部分，包含区块奖励）、区块级状态转换函数（应用于交易状态时的区块终结状态转换函数的结果状态）

在最高层级，我们有以太坊世界状态的概念。世界状态是一个以太坊地址（160位数值）到账户数据的映射。具体来说，每个以太坊地址所对应的账户数据都由以下几部分组成：一个以太币的余额（保存了这个账户所持有的以wei为单位的以太币数量）；一个nonce（如果是EOA，则代表了从这个账户所发出的交易的数量；如果是合约账户，则代表了由它所创建的合约的数量）；账户的存储（仅供智能合约使用的永久数据存储）以及账户的程序代码（如果账户是智能合约账户）。一个EOA永远不会有代码，且只有全空的存储。

当一个交易最终反映为一次智能合约代码的执行时，一个EVM实例会基于当前正在创建的区块信息和当前这个交易的信息被初始化出来。具体地说，就是会将调用的合约账户所对应的代码加载到EVM的ROM中，程序计数器置为0，从调用的合约账户所对应的存储中加载存储数据，将内存清零并将与区块和其他环境变量相关的信息设置好。这个执行中的关键变量就是提供给这次执行的gas，这个gas被设定为原始交易开始时由交易发送者支付的gas总量。在执行的过程中，gas的供给会基于操作执行的消耗相应减少。无论何时，只要gas的供给减小到0，我们就会得到一个“out of gas”（OOG）异常；执行会立即停止，相应的交易也即失败。除了对交易发送者的nonce增加（加1）并从其账户余额中扣除到代码停止执行时在区块的beneficiary（即“挖到”这个区块的矿工）处所消耗的资源费用（即在此执行中所消耗的gas乘以交易中所指定的gasPrice所得出的执行费用）以外，其他所有变动都不会反映到以太坊状态中。这里，你可以把EVM的运行想象为将以太坊世界状态复制到了一个沙盒中，如果执行因为任何原因没有完成，那么这个沙盒中的状态就会被丢弃。不过，如果执行成功结束，那么真正的世界状态就会被更新为这个沙盒的状态，包含所有对调用过的合约的存储数据的更改、新创建的合约以及其间所有以太币余额的转移。

##### 把Solidity代码编译为EVM字节码

```
solc --help
```

通过--opcodes命令行参数可以简单地生成Solidity源代码文件对应的操作码序列，编译Solidity文件Example.sol并将字节码输出到BytecodeDir可以通过下列指令完成

```
solc -o BytecodeDir --opcodes Example.sol
solc -o BytecodeDir --asm Example.sol
```

下列命令则可以为我们的示例程序生成字节码

```
solc -o BytecodeDir --bin Example.sol
```

实际生成的操作码文件依赖于Solidity源代码文件中包含的特定合约。我们使用的这个例子源码文件Example.sol中仅包含了一个叫作example的合约：

```
pragma solidity ^0.4.19;
contract example {
  address contractOwner;
  function example() {
    contractOwner = msg.sender;
  }
}
```

如果你查看BytecodeDir目录，你会看到操作码文件example.opcode，它包含了example合约的EVM操作码指令。用文本编辑器打开example.opcode文件，你会看到如下内容：

```
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH1 0xE JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH1
0x35 DUP1 PUSH1 0x5B PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1
0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 JUMP
0xb9 SWAP14 0xcb 0x1e 0xdd RETURNDATACOPY 0xec 0xe0 0x1f 0x27 0xc9 PUSH5
0x9C5ABCC14A NUMBER 0x5e INVALID EXTCODESIZE 0xdb 0xcf EXTCODESIZE 0x27
EXTCODESIZE 0xe2 0xb8 SWAP10 0xed 0x
```

用--asm选项编译example，会在BytecodeDir目录中产生一个example.evm文件。它包含了对EVM字节码指令的稍高级一些的描述，并附带了一些有用的注解：

```
/* "Example.sol":26:132  contract example {... */
  mstore(0x40, 0x60)
    /* "Example.sol":74:130  function example() {... */
  jumpi(tag_1, iszero(callvalue))
  0x0
  dup1
  revert
tag_1:
    /* "Example.sol":115:125  msg.sender */
  caller
    /* "Example.sol":99:112  contractOwner */
  0x0
  dup1
    /* "Example.sol":99:125  contractOwner = msg.sender */
  0x100
  exp
  dup2
  sload
  dup2
  0xffffffffffffffffffffffffffffffffffffffff
  mul
  not
  and
  swap1
  dup4
  0xffffffffffffffffffffffffffffffffffffffff
  and
  mul
  or
  swap1
  sstore
  pop
    /* "Example.sol":26:132  contract example {... */
  dataSize(sub_0)
  dup1
  dataOffset(sub_0)
  0x0
  codecopy
  0x0
  return
stop
sub_0: assembly {
        /* "Example.sol":26:132  contract example {... */
      mstore(0x40, 0x60)
      0x0
      dup1
      revert
    auxdata: 0xa165627a7a7230582056b99dcb1edd3eece01f27c9649c5abcc14a435efe3b...
}
```

--bin-runtime选项会产生机器可读的十六进制字节码：

```
60606040523415600e57600080fd5b336000806101000a81548173
ffffffffffffffffffffffffffffffffffffffff
021916908373
ffffffffffffffffffffffffffffffffffffffff
160217905550603580605b6000396000f3006060604052600080fd00a165627a7a7230582056b...
```

从前4个指令开始吧：

```
PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE
```

这里有一个PUSH1后边紧跟了一个原始字节数据0x60。这意味着这个EVM指令接收一个跟在其后的字节数据作为输入（字面数值）并将这个数据压入栈顶。我们也可以将最大32字节的数据压入栈顶，比如：

```
PUSH32 0x436f6e67726174756c6174696f6e732120536f6f6e20746f206d617374657221
```

example.opcode中的第二个PUSH1操作码将0x40压入栈顶（先前的0x60所使用的数据槽会向下移动一个位置）。

接下来是MSTORE，这是一个保存内存的操作，也就是将一个值保存到EVM的内存中。它接收两个参数，并且像大多数EVM操作一样，它会使用栈里的数据来获取它实际使用的参数。每当从栈中弹出一个数据（也就是栈顶的数据槽中的数据），其下的所有数据都会向上移动一个位置。MSTORE的第一个参数是要保存的数值所应使用的目标地址。对于这个程序，我们将会从栈顶移除0x40，并将其作为内存目标地址。第二个参数就是要保存的数值，在这里就是0x60。当MSTORE执行完成之后，栈重新变为空，但我们将数值0x60（即十进制的96）保存到了内存地址0x40处。

下一个操作码是CALLVALUE，它是一个环境操作码，会将触发这次执行的消息调用所附带的以太币数量（以wei为单位）压入栈顶。

虚拟机加载字节码，通过解释器解释成汇编指令，最终再转义成机器指令

## 全节点与轻节点

全节点，其实就是同步所有区块链数据的节点，包括各种区块Body，交易列表等等相关信息。但也是因为节点全量数据都保存的情况，我们不需要相依赖中介去进行数据的验证。

轻节点，每当有区块出现在网络便下载区块头，而不是全量的情况状态，并发送客户端需要的特定状态的默克尔证明（Merkle proofs）的请求。同时在以太坊轻节点中使用分布式哈希表来追踪前缀节点，而不是直接采用LevelDB进行直接的存储。

#### Merkle证明

![img](https://ethbook.abyteahead.com/_images/Picture32.png)

在这里我们有一组份数据包含了8个元素，依次是 `[5,27,18,64,30,2,43,48]` ，当我们在传输过程中收到了数据 `64` ，我们如何才能在其他数据尚未送达之前，证明以下两点？：

> 数据 `64` 的确存在于这组组数据中。
>
> 数据 `64` 存在的位置是第4格（第四顺位）。

按照 Merkle证明，我们仅需知晓4个哈希值即可作出证明。

- 数字 `64` 的相邻数字 `18` 的哈希值 (图中为 **1FXq**)
- 相邻分组 `[5, 27]` 的联合哈希值 (图中为 **ec20**)
- 相邻分支的哈希值 (图中为 **8f74**)
- 根节点哈希值 (图中为 **6c0a**)
