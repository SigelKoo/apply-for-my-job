# 密码学算法

![img](https://img-blog.csdnimg.cn/20190911153812161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTExMTg0,size_16,color_FFFFFF,t_70)

### 对称加密

加密和解密时使用同一密钥的方式

##### 异或运算

0 XOR 0 = 0

0 XOR 1 = 1

1 XOR 0 = 1

1 XOR 1 = 0

##### 比特序列的XOR

将明文A用密钥B进行加密，得到密文A XOR B

将密文A XOR B用密钥B进行解密，得到明文A

0 1 0 0 1 1 0 0	A

1 0 1 0 1 0 1 0	B

1 1 1 0 0 1 1 0	A XOR B

解密

1 1 1 0 0 1 1 0	A XOR B

1 0 1 0 1 0 1 0	B

0 1 0 0 1 1 0 0	A

##### DES

DES已可被暴力破解，强度大不如从前了，现在仅以用来解密以前的密文

DES

DES是一种将64比特的明文加密成64比特密文的对称密码算法，它的密钥长度是56比特，尽管从本质上说它的密钥是64比特，但是由于每隔7比特会设置一个用于错误检查的比特，奇偶校验位，因此实质上密钥长度是56比特。

采用56位密钥加密64位的明文数据，当n个64位明文数据块都经过DES加密处理后，所得到的n个65位密文数据块串在一起就是密文输出。根据初始置换表将原始数据进行置换，得到置换后数据；迭代扩展置换将左右两边右边的数据扩展为48位；48位明文和48位密文进行异或运算后，使用8个S盒压缩处理得到32位数据，再经过一个P盒置换，就得到一轮运算中的最后输出。

一轮发生后，左右两边进行对调，最后一轮左右不对调

##### AES

AES的区块长度固定为128位，密钥长度则可以是128，192或256位；而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256位为上限。有SubBytes、ShiftRows、MixColumns、AddRoundKey四个阶段分别以字节、行、列为单位进行并行计算。

### 非对称加密

在加密和解密时使用不同密钥

###### 时钟运算

**加法**使用mod运算

当前时钟指向7，右转2刻度，指向9；

当前时钟指向7，右转6刻度，指向1，即(7 + 6) % 12 = 1

**减法**

当前时钟指向7，怎么让它回到0，右转5次，指向0，即 (7 + 5) % 12 = 0。

5在此与-7有着一样的效果，减去7与加上5相同，因为X + Y = 12

**乘法**

将时钟的加法进行反复，最终将结果进行取模。

7 * 4 mod 12 = 28 mod 12 = 4

**除法**

减法是加法的逆运算，除法为乘法的逆运算

7 * X mod 12 = 1 =====>将向右转动7个刻度的操作重复几次指针可指向1

X = 7

在mod 12 的世界中，7乘以几等于1，就是在mod 12的世界中1 / 7等于几

1 * 1 mod 12 = 1

5 * 5 mod 12 = 1

7 * 7 mod 12 = 1

11 *11 mod 12 = 1

**倒数**是乘积为1的两个数，n * 1 / n = 1

存在倒数的数与12之间的公约数只有1，即相较于12的质数

**乘方**

先进行一般的乘方运算之后再求余数即可。

7 ^ 4 = 7 * 7 * 7 * 7 mod 12 = 2401

在中间步骤求mod，可以避免计算大整数的乘积。

7 ^ 4 mod 12 = 7 * 7 * 7 * 7 mod 12 = ((7 * 7 mod 12) * (7 * 7 mod 12)) mod 12 = ((49 mod 12) * (49 mod 12)) mod 12 = (1 * 1) mod 12 = 1

**对数**

7 ^ X mod 13 = 8

从0开始依次尝试，可得到X = 9

当数字很大时，求离散对数非常困难，也非常耗时。

##### RSA

**加密**：

RSA，明文、密钥、密文都是数字。

```
密文 = 明文 ^ E mod N
```

RSA的密文是对代表明文的数字的E次方求mod N的结果，就是将明文和自己做E次乘法，然后将其结果除以N求余数，余数就是密文。

其中(E, N)是公钥

**解密**：

```
明文 = 密文 ^ D mod N
```

对密文的数字的D次方求mod N就可以得到明文。将密文和自己做D次乘法，再对结果除以N求余数，就可以得到明文。

其中(D,N)是私钥

**过程模拟**：

1. 求N，准备质数p = 17，质数q = 19，N = p * q = 323
2. 求L，L = lcm(p - 1, q - 1) = lcm(16, 18) = 144（16和18的最小公倍数）
3. 求E，E和L的最大公约数为1。例如5，7，11，13，17，19，23......，这里我们选择E = 5
4. 求D，E * D mod L = 1，E * D mod L = 5 * 29 mod 144 = 145 mod 144 = 1

公钥E = 5，N = 323

私钥D = 29， N = 323

将公私钥带入加密和解密的公式可验证



