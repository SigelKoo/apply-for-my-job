# 共识算法

共识算法是区块链系统中的核心机制，旨在解决系统中各分布式节点数据一致性的问题。在分布式对等网络中，不同节点通过交换信息达成共识，而网络中可能存在恶意节点篡改或伪造数据，或者通信网络也可能导致传输信息出错，从而影响节点间共识的达成，破坏分布式系统的一致性。

## PoW

PoW 中的挖矿实际上在做的事情就是将动能（电力）转化为一个账本区块。一台矿机重复地运行哈希计算，直到它解决一个密码学难题。所有的哈希运算都会被丢弃，除了那个能够解决问题的哈希值。

#### 优点

1. 机制本身当然很复杂，有很多细节，比如：挖矿难度自动调整、区块奖励逐步减半等，这些因素都是基于经济学原理，能吸引和鼓励更多人参与。
2. 理想状态，这种机制，可以吸引很多用户参与其中，特别是越先参与的获得越多，会促使加密货币的初始阶段发展迅速，节点网络迅速扩大。在CPU挖矿的时代，比特币吸引了很多人参与“挖矿”，就是很好的证明。
3. 通过“挖矿”的方式发行新币，把比特币分散给个人，实现了相对公平。

#### 缺点

1. 算力是计算机硬件提供的，要耗费电力，是对能源的直接消耗，与人类追求节能、清洁、环保的理念相悖。不过，如果非要给“加密货币”找寻“货币价值”的意义，那么这个方面，应该是最有力的证据。
2. 这种机制发展到今天，算力的提供已经不再是单纯的CPU了，而是逐步发展到GPU、FPGA，乃至ASIC矿机。用户也从个人挖矿发展到大的矿池、矿场，算力集中越来越明显。这与去中心化的方向背道而驰，渐行渐远，网络的安全逐渐受到威胁。
3. 以太坊出块奖励不断减少，当挖矿的成本高于挖矿收益时，人们挖矿的积极性降低，会有大量算力减少，比特币网络的安全性进一步堪忧。

## PoS ## 

权益证明是一类应用于公共区块链的共识算法，取决于验证者在网络中的经济权益。在基于权益证明的公共区块链（如以太坊即将实现的Casper协议）中，一组验证者轮流提议并票决下一个区块，而每位验证者的投票权重取决于其保证金额的大小（即权益）。权益证明的重要优势包括保障安全性、降低中心化危险以及提升能源效率。

权益证明算法：区块链会追踪一个验证者集，而任何持有该区块链的基础加密货币（对以太坊来说就是以太币）的人都可以通过发送一种**将以太币锁定为保证金**的特殊交易成为验证者。随后，创造并认可新区块的过程可通过当前所有验证者均可参与的共识算法来完成。

在**基于区块链的权益证明**中，共识算法在每个时段内伪随机地选择一个验证者（例如，每10秒钟为一个时间段），赋予该验证者出块的权力，新创造的区块必须跟在之前的某个区块（通常是位于最长链的末端的区块）后面。因此，随着时间的推移，大多数区块会填加到同一条区块链上，使之不断增长。

在**拜占庭容错型权益证明**中，虽然提议区块的权力会随机分配给验证者，但是决定哪一个区块是“合法的”要通过一个多轮过程来完成。每个验证者在每一轮都会给某个特定的区块投出一票，在这个多轮过程的最后，所有（诚实并联网的）验证者会就是否将这个区块添加到链上做出最终决定。要注意的是这些区块可能仍然链接在一起，其关键区别在于对一个区块的共识可以仅限于这个区块本身，与它后面的那条链的长度和大小无关。

以下是权益证明的运行过程：

- 验证者必须锁定一些他们拥有的币作为保证金。
- 在此之后，他们将开始验证区块。同时，当他们发现一个他们认为可以被加到链上的区块时，他们会通过下赌注来验证它。
- 如果该区块成功上链，验证者就将得到一个与他们的赌注成比例的奖励。

优点

- **不需要为了保护区块链而消耗大量电力**（例如，比特币和以太坊预计每天要在共识机制的电力和硬件上耗费超过100万美元的成本）。
- 由于权益证明避免了高电耗，就**没有太多必要**为了保持网络中参与者的积极性而**发行很多新代币**。从理论上来说，甚至有可能变为负发行量，其中一部分交易费被“烧掉（burned）”，因此供应量会逐渐减少。
- 权益证明有助于实现更多采用博弈论机制设计的技术，从而更好地**抑制中心化卡特尔式机构的形成**，如果这种机构确实形成了的话，也能够阻止它们危害网络（如工作量证明中的自私挖矿）。
- **降低中心化风险**，因此规模经济不会造成太大问题。你不会因为负担得起更好的大批量矿机而获得与投入资金不成比例的收益，在PoS中，1000万美元投资带给你的收益就是100万美元投资的整整十倍。
- 能够采用经济处罚，这让发动各种形式的51%攻击所要付出的代价比在工作量证明中高出许多——Vlad Zamfir说过这样一句话，大意是：“就好像如果你参与了51%攻击，你的ASIC矿场就会烧毁一样”。

### Casper

币龄的计算是通过挖矿者拥有的币乘以每个币的剩下使用时间得到，这也将意味着拥有的币越多，也越容易得到答案。

Casper实施了一个进程，使得它可以惩罚所有的恶意因素。这就是权益证明在Casper下是如何工作的：

- 验证者押下一定比例的他们拥有的以太币作为保证金。
- 然后，他们将开始验证区块。也就是说，当他们发现一个可以他们认为可以被加到链上的区块的时候，他们将以通过押下赌注来验证它。
- 如果该区块被加到链上，然后验证者们将得到一个跟他们的赌注成比例的奖励。
- 但是，如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事，他们将立即遭到惩罚，他们所有的权益都会被砍掉。

### PoW向PoS过渡

以太坊 2.0 初期，采用 Casper FFG 机制运行和出块。彼时，信标链（beacon chain）将与以太坊 1.x 互为镜像关系，信标链为侧链，但不具有任何功能，以太坊 1.x 为主链，按照原有的 PoW 机制出块。

EthFans 编辑阿剑告诉 Odaily星球日报：“用户在 PoW 链上将以太币锁进相关的合约就可以获得参与信标链的验证者资格，并得到 PoS 奖励，但在信标链上新的以太币无法退回到 PoW 主链上。”

在信标链分片阶段，信标链将产生 1024 个分片，每个分片有一个地址。Casper FFG 信标链采用二次随机选举的方式完成出块验证并防止验证者作恶。

验证者需要向分片地址投入 32 个 新以太币作为押金。信标链每隔 64 个块（1 分钟出 10 个块）会随机选出 128 名验证者作为待定委员，再由信标链在从 128 名待定委员中随机选择出一定数量的委员组成委员会。

被选中的委员可以在各自的区块上进行验证产生新的区块，但委员的“任职”期限仅为 6.4 分钟，6.4 分钟后的区块控制者将在下一届的新委会中诞生。

## PBFT

> 拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。

这一问题是一种对现实世界的模型化，尤指网络当中由于软硬件错误、网络阻塞及恶意攻击导致的各种未知行为。

显然，在此处默认了将军们在达成一致的过程中正确的传递出了自己的决定，也就是说叛徒只存在于将军当中，不存在于传令兵当中。故要让拜占庭将军问题有解，必须要具备一个重要前提，即信道必须是安全可靠的。关于信道可靠问题，会引出两军问题。两军问题的结论是，在一个不可靠的通信链路上试图通过通信以达成一致是基本不可能或者十分困难的。

### 拜占庭容错

拜占庭将军问题提出后，有很多的算法被提出用于解决这个问题。这类算法统称拜占庭容错算法（BFT: Byzantine Fault Tolerance）。简略来说，拜占庭容错（BFT）不是某一个具体算法，而是能够抵抗拜占庭将军问题导致的一系列失利的系统特点。 这意味着即使某些节点出现缺点或恶意行为，拜占庭容错系统也能够继续运转。本质上来说，拜占庭容错方案就是少数服从多数。

拜占庭将军问题的原始论文给出了一些解决思路，但其更注重理论上的可行性。算法效率不高，算法复杂度为指数级，且文中明确指出时间成本及消息传递数量很大。因此不具备太大的实用价值。

拜占庭容错系统需要达成如下两个指标：

- **安全性：**任何已经完成的请求都不会被更改，它可以在以后请求看到。在区块链系统中，可以理解为，已经生成的账本不可篡改，并且可以被节点随时查看。
- **活性：**可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。在区块链系统中，可以理解为，系统需要持续生成区块，为用户记账，这主要靠挖矿的激励机制来保证。

拜占庭系统目前普遍采用的假设条件包括:

- 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；
- 节点之间的错误是不相关的；
- 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达；
- 服务器之间传递的信息，第三方可以知晓 ，但是不能篡改、伪造信息的内容和验证信息的完整性；

#### 实用拜占庭容错

> PBFT(Practical Byzantine Fault Tolerance)算法由麻省理工学院的Miguel Castro 和Barbara Liskov于1999年提出，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。

PBFT是联盟币的共识算法的基础。实现了在有限个节点的情况下的拜占庭问题，有3f + 1的容错性（拜占庭将军问题也只在节点数N > 3f时可解），并同时保证一定的性能。其采用了密码学相关技术(RSA 签名算法、消息验证编码和摘要)确保消息传递过程无法被篡改和破坏。

拜占庭将军问题在节点数N > 3f时有解的正确性证明比较复杂，此处仅举一个简单例子说明。

在恶意节点数f = 1，节点数N = 3f = 3时，可以看到，发令者和接令者任意角色出现叛徒都会导致其他节点无法作出决定。

![img](https://pic1.zhimg.com/80/v2-0f8bb176d4dbe60d1767d143b49fed8c_720w.jpg)

而当节点数N>3f（如4个）时，无论哪个角色出现叛徒，最终其他节点总能根据少数服从多数的原则达成共识。

![img](https://pic4.zhimg.com/80/v2-b997807734fcb93b03f798265e9a81db_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-a6d90d184c7454bff552ae3709e7b1ee_720w.jpg)

**为什么PBFT算法最大容错节点数量f是(N-1)/3？**

假定节点总数是N，作恶节点数为f，那么剩下的正确节点数为N - f，意味着只要收到N - f个消息且N - f > f就能做出决定，但是这N - f个消息有可能有f个是由作恶节点冒充的（或因网络延迟导致f个恶意节点的消息先被收到），那么正确的消息就是N - f - f个，为了多数一致，正确消息必须占多数，也就是N - f - f > f ，所以N最少是3f + 1个。

#### PBFT算法流程

![PBFT normal operation.](https://www.researchgate.net/profile/Kai-Lei/publication/330513012/figure/fig1/AS:717413276479492@1548056062990/PBFT-normal-operation.png)

涉及角色：主节点、普通节点

在PBFT原始论文中，存在副本节点（replica）和备份节点（backup）两种称谓。其中，副本节点一般包括主节点在内，备份节点则不包括，而两种称谓又相当容易混淆，因此本文将备份节点称为普通节点。

每个主节点的工作过程称为一个视图（view），用v表示视图编号

主节点由普通节点轮流当选，具体计算过程为主节点p = v mod |R|（|R|为节点个数）

**主节点的作用：**

正常工作时，接收客户端的事务请求，验证request身份后，为该请求设置编号，广播pre-prepare消息

新主节点当选时，根据自己收集的View-Change消息，发送View-New信息，让其它节点同步数据

主节点与所有的其它节点维系心跳

如果主节点宕机，会因为心跳超时，而触发重新选举，保证系统运行稳定

如果主节点恶意发送错误编号的消息，那么会在后续的操作中，被副本节点察觉，因为 prepare和commit阶段都是会进行广播的，一旦不一致，触发view-change

如果主节点不发送接收到的request，客户端在超时未回复时，会重发request到所有的副本节点，并触发view-change

如果主节点节点篡改消息，因为有Request里面有数据和客户端的签名，所以primary无法篡改消息，其它副本会先验证消息的合法性，否则丢弃，并触发view-change

综上所述，限制了权限的主节点，如果宕机、或者不发生消息、或者发送错误编号的消息、或者篡改消息，都会被其它节点感知，并触发view-change。

**（1）Request**

客户端C向主节点p发送<REQUEST， o， t， c>

o：请求的具体操作

t：请求时客户端追加的时间戳

c：客户端标识

REQUEST: 包含消息内容m，以及消息摘要d(m)。

客户端对请求进行签名。

**（2）Pre-Prepare**

主节点收到客户端的请求，需要对客户端请求消息签名是否正确进行校验。

非法请求则丢弃。正确请求则分配一个编号n，编号n主要用于对客户端的请求进行排序。然后广播一条<<PRE-PREPARE， v， n， d>， m>消息给其它普通节点。

v：视图编号

d：客户端消息摘要

m：消息内容

主节点对<PRE-PREPARE， v， n， d>进行签名。

**（3）Prepare**

普通节点i收到主节点的Pre-Prepare消息，需要满足以下条件方可接受消息：

A、请求和预准备消息的签名正确，并且d与m的摘要一致。

B、当前视图编号是v。

C、该普通节点从未在视图v中接受过序号为n但是摘要d不同的消息m。

D、预准备消息的序号n在区间[h， H]内。

非法请求则丢弃。正确请求则普通节点i进入准备状态并向所有其它节点（包括主节点）发送一条<PREPARE， v， n， d， i>消息， v， n， d， m与上述Pre-Prepare消息内容相同，i是当前副本节点编号。

普通节点i对<PREPARE， v， n， d， i>签名。记录Pre-Prepare和Prepare消息到日志中，用于视图轮换过程中恢复未完成的请求操作。

Prepare阶段如果发生视图轮换会导致丢弃Prepare阶段的请求。

**（4）Commit**

主节点和普通节点收到PREPARE消息，需要满足以下条件方可接受消息：

A、普通节点对Prepare消息的签名正确。

B、消息的视图编号v与节点的当前视图编号一致。

C、n是否在区间[h， H]内。

非法请求则丢弃。如果节点i收到了2f+1个（包括自身在内）验证通过的Prepare消息，表明网络中的大多数节点已经收到同意信息，则向其它节点包括主节点发送一条<COMMIT， v， n， d， i>消息，v， n， d， i与上述PREPARE消息内容相同。

节点i对<COMMIT， v， n， d， i>签名。记录Commit消息到日志中，用于视图轮换过程中恢复未完成的请求操作。记录其它副本节点发送的Prepare消息到日志中。Commit阶段用来确保网络中大多数节点都已经收到足够多的信息来达成共识，如果Commit阶段发生视图轮换，会保存原来Commit阶段的请求，不会达不成共识，也不会丢失请求编号。

该阶段可不可以不需要：不可以，主节点崩溃换主，其他节点没有收到足够多的prepare，执行了操作的节点在新主发起新一轮共识，sequence与已执行操作一致，该节点是否需要继续执行？有commit阶段，节点收到足够多的prepare进入commit，换主但未执行，sequence不变，view改变。使用commit阶段，2f+1个节点已经prepare，换主需要重放pre-prepare，会将相同签名的消息view改为自己重发。（简言之，prepare锁定同一个view下的sequence，commit锁定sequence）

**（5）Reply**

主节点和普通节点收到Commit消息，需要满足以下条件方可接受消息：

A、节点对Commit消息的签名正确。

B、消息的视图编号v与节点的当前视图编号一致。

C、n是否在区间[h， H]内。

非法请求则丢弃。如果副本节点i收到了2f+1个（包括自身在内）验证通过的Commit消息，说明当前网络中的大部分节点已经达成共识，运行客户端的请求操作o，并返回<REPLY， v， t， c， i， r>给客户端，

r：是请求操作结果，客户端如果收到f+1个相同的REPLY消息，说明客户端发起的请求已经达成全网共识，否则客户端需要判断是否重新发送请求给主节点。记录其它副本节点发送的Commit消息到日志中。

## DPoS

DPoS是一种基于投票选举的共识算法，有点像民主大会，持币人选出几个代表节点来运营网络，用专业运行的网络服务器来保证区块链网络的安全和性能。

DPoS机制中，不需要算力解决数学难题，而是由持币者选出谁说生产者，如果生产者不称职，就有随时有可能被投票出局，这也就解决了POS的性能问题。

1. 随机指定生产者出场顺序；
2. 不按顺序生产的区块无效；
3. 每过一个周期洗牌一次，打乱原有顺序；
4. DPOS允许所有矿池每三秒钟轮换一次，并且其他人已被安排在后续进程中，于是，没有人可以在预设位置外生产区块。如果一个块生产者这么做了，就可能被投票出局。

#### 优点

1. 能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。
2. 更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。
3. 更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。相比比特币更快。以太坊（PoW机制）产生一个区块需要12秒，一笔交易完成（12个区块确认后）需要约3分钟。点点币（PoS机制）确认一笔交易大概也需要1小时。

#### 缺点

1. 投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。
2. 对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。

## PoA

PoA为权威证明

PoA共识中出块权掌握在部分签名者手里，而普通人是无法参与的（无论你有多少算力、多少权益）。可见PoA共识牺牲了一部去中心化的特性，换来了一种可控性。

**问题1：如何实现签名者的引进和踢出**

PoA的第一个问题是需要解决签名者更换的问题。在PoA中，签名者必须保证多数情况下在线出块。然而随着项目的不断运行，不可能所有签名者都一直有资源、有意愿继续工作；另外偶尔签名者也会作恶，必须及时将作恶的人踢出。

**问题2：如何控制出块时机**

首先要明确的是，出块时机由两方面决定：一是出块时间；二是由谁出块。在PoA中，签名者之间是合作关系，大家“和和气气”，什么时间出块、由谁出都要按规则来，不能争不能抢。因此需要有良好的规则控制出块时机。

### 设计概要

- **checkpoint**：一个特殊的block，它的高度是EPOCH_LENGTH的整数倍，block中不包含投票信息但包含当时所有的签名者列表

- **SIGNER_COUNT**：某一时刻签名者的数量
- **SIGNER_LIMIT**：连续的块的数量，在这些连续的块中，某一签名者最多只能签一个块；同时也是投票生效的票数的最小值
- **BLOCK_PERIOD**：两个相邻的块的Time字段的最小差值，也是出块周期
- **EPOCH_LENGTH**：两个checkpoint之间的block的数量。达到这个数量后会生成checkpoint以及清除当前所有未生效的投票信息
- **DIFF_INTURN**：出块状态（difficulty）之一，此状态代表“按道理已经轮到我出块”
- **DIFF_NOTURN**：出块状态（difficulty）之一，此状态代表“按道理还没轮到我出块”

问题1解决

- clique中签名者的引进和踢出是通过已有签名者进行投票实现的，并且加入了更加详细的控制。下面我们看一下clique中的投票规则：
  - 投票信息保存在block中。一个block只有一个投票信息，且只能在自己生成的block上保存。
  - 针对某个被投人的票数超过SIGNER_LIMIT时，投票结果立即生效。
  - 投票生效后，立即清除所有被投人是当前生效人的投票信息。如果投的是踢出票，则被投人之前投出的、但还未生效的投票全部失效。
  - 踢出一个签名者以后，可能会导致原来不通过的投票理论上可以通过。clique不特意处理这种情况，等待下次统计时再判断。
  - 发起一个投票后，客户端不会被立即清除投票信息，而是在之后每次出块时都会选一个继续投票。因为区块链中的有效区块有重新调整的可能性，所以不能认为投票生效了之后就会一直生效。
  - 无效的投票：被投票人不在当前签名者列表中但投的是踢出票，或被投票人在当前签名列表中但投的是引进票
  - 为了使编码简单，无效的投票不会受到惩罚（其实我认为有些功能实现也依赖于无效的投票）
  - 在每个EPOCH_LENGTH内，一个签名者给同一个账号地址重复投票时，会先将上次的投票信息清除，然后再统计本次的投票信息（如果本次为无效的投票不会恢复已经清除的上次投票信息）
  - 每个checkpoint不进行投票，而只是包含当前签名者列表信息。对于其它区块，可以用来携带投票信息。

关于上面重复投票的处理需要多说一下，这种处理方式会产生两个结果（假设投票人是A，被投票人是B）：

1. 在当前EPOCH_LENGTH内，A给B只能投一票
2. 在当前EPOCH_LENGTH内，如果给B的投票未生效（总票数未超过SIGNER_LIMIT）时A想把投给B的票撤消，那么A可以投一次跟之前相反的票。因为新的投票会导致旧的投票信息清除，而如果旧的投票是有效的则新的投票必定是无效的，因而也不会进入投票统计。

问题2解决

- 前面我们说过，出块时机由两方面决定：一是出块时间；二是由谁出块。下面我们看看clique是如何解决这些问题的。

  - 出块时间

    在clique中，出块时间是固定的，由BLOCK_PERIOD决定。

  - 由谁出块

    clique中出块权的确定稍微复杂，具体规则为：

    - 签名者在签名者列表中且在SIGNER_LIMIT内没出过块
    - 如果签名者是DIFF_INTURN状态，则拥有较高出块权（等待出块时间到来，签名区块并立即广播出去）
    - 如果签名者是DIFF_NOTURN状态，则拥有较低出块权（等待出块时间到来，再延迟一下（延迟时间为rand(SIGNER_COUNT * 500ms)）

可见出块权由两方面确定：**一是最近是否出过块，如果出过则没有出块权**；**二是DIFF_INTURN / DIFF_NOTURN状态，DIFF_INTURN拥有较高出块权**。

Header.Coinbase：在clique中用来保存投票时被投票人的地址。而出块者的地址通过签名数据计算得出（ecrecover）。

Header.Nonce：在clique中不需要根据Nonce调整header的哈希，因此直接用来保存投票目的。如果值为nonceAuthVote(0xffffffffffffffff)则代表这是一次授权投票；如果值为nonceDropVote(0x0000000000000000)则代表这是一次踢出投票。

Header.Extra：在clique中Extra除了依然保存vanity数据和Seal数据，还在checkpoint中增加了所有签名者地址数据。其结构为：
vanityData(固定32字节)+signer1Address+signer2Address+…+SealData(固定65字节)

在clique中，有一个值叫做”epoch”。当一个block的高度恰好是”epoch”值的整数倍时，这个block便不会包含任何投票信息，而是包含了当前所有的签名者列表。这个block被叫做checkpoint。可以看出，checkpoint类似于一个“里程碑”，可以用来表示“到目前为止，有效的签名者都记录在我这里了”；而epoch就是设立里程碑的距离。

简单来说，”epoch”的存在，是为了避免没有尽头的投票窗口，也是为了周期性的清除除旧的投票提案。更进一步地，在checkpoint中存在的签名者列表，可以让节点间基于中间某个checkpoint就可以同步到签名者列表，而不需要整个链上的数据。

```go
func (c *Clique) Prepare(chain consensus.ChainReader， header *types.Header) error {
  //others code
  ......

  // number为将要生成的块的高度

  //如果number不是epoch的整数倍（不是checkpoint），则进行投票信息的填充
  if number%c.config.Epoch != 0 {
    ......

    //填写投票信息（投票信息存储在Coinbase和Nonce字段中）
    if len(addresses) > 0 {
      header.Coinbase = addresses[rand.Intn(len(addresses))]
      if c.proposals[header.Coinbase] {
        copy(header.Nonce[:]， nonceAuthVote)
      } else {
        copy(header.Nonce[:]， nonceDropVote)
      }
    }
  }

  ......

  //如果number是epoch的整数倍（将要生成一个checkpoint），则填充签名者列表
  if number%c.config.Epoch == 0 {
    for _， signer := range snap.signers() {
      header.Extra = append(header.Extra， signer[:]...)
    }
  }
}
```

在`Snapshot.apply`方法中的代码，则体现了“避免没有尽头的投票窗口，周期性的清除除旧的投票提案”的功能：

```go
func (s *Snapshot) apply(headers []*types.Header) (*Snapshot， error) {
  ......

  for _， header := range headers {
    // Remove any votes on checkpoint blocks
    number := header.Number.Uint64()
    //如果当前header的高度是epoch的整数倍（当前block是一个checkpoint），则清除所有投票信息和统计
    //Votes和Tally字段的详细信息参看对Snapshot的介绍。
    if number%s.config.Epoch == 0 {
      snap.Votes = nil
      snap.Tally = make(map[common.Address]Tally)
    }

    ......
  }
}
```

这里稍微说明一下为什么这一点代码实现了epoch的设计目的。一个Snapshot对象中保存了在某个高度上的投票信息，而创建一个Snapshot对象其实是分两步的，apply方法属于第二步。假如给apply传入10个header，其中第8个的高度恰好是epoch的整数倍，那么前面那7个的投票信息就被抹去了。

除了epoch，代码中还有一个值为checkpointInterval。当在某个block上创建一个Snapshot对象，且这个block的高度是checkpointInterval的整数倍时，则将这个Snapshot对象写入到数据库中永久存储；以后想到再次在这个block上生成Snapshot对象时，直接从数据库中读取就可以了。摘录代码如下：

```go
func (c *Clique) snapshot(chain consensus.ChainReader， number uint64， hash common.Hash， parents []*types.Header) (*Snapshot， error) {
  ......

  for snap == nil {
    ......

    //如果高度为checkpointInterval的整数倍，则直接尝试从数据库中读取Snapshot对象
    if number%checkpointInterval == 0 {
      if s， err := loadSnapshot(c.config， c.signatures， c.db， hash); err == nil {
        snap = s
        break
      }
    }

    ......
  }

  ......

  //如果高度为checkpointInterval的整数倍，则将Snapshot对象存储到数据库中
  if snap.Number%checkpointInterval == 0 && len(headers) > 0 {
    if err = snap.store(c.db); err != nil {
      return nil， err
    }
  }
  return snap， err
}
```

##### Snapshot

Snapshot对象是clique中比较重要的一个对象，它的作用是统计并保存链的某段高度区间的投票信息和签名者列表。这个统计区间是从某个checkpoint开始（包括genesis block），到某个更高高度的block。在Snapshot对象中用到了两个重要的结构体：Vote和Tally，我们先对它们进行一下说明，再来详细说一下Snapshot结构体。

Vote struct

Vote代表的是一次投票的详细信息，包括谁给谁投的票、投的加入票还是踢出票等等。它的结构体定义如下：

```go
type Vote struct {
  Signer    common.Address // 此次投票是由谁投的
  Block     uint64         // 此次投票是在哪个高度的block上投的
  Address   common.Address // 此次投票是投给谁的
  Authorize bool           // 这是一个加入票（申请被投人成为签名者）还是踢出票（申请将被投人踢出签名者列表）
}
```

Tally struct

Tally结构体是对所有被投人的投票结果统计。注意它与Vote结构体的区别：Vote是投票过程的记录（如A给B投了一个授权票），而Tally是对结果的统计（类似于选班长唱票时计票员在黑板上画的“正”字）。Tally的定义如下：

```go
type Tally struct {
  Authorize bool // 这是加入票的统计还是踢出票的统计
  Votes     int  // 目前为止累计的票数
}
```

如果只看这里你可能会意外这里并没有“针对谁进行的统计”的信息，这是因为Tally在Snapshot结构体是是作为map的一部分的，参看下面对Snapshot结构体字段的说明。

Snapshot struct

```go
type Snapshot struct {
  config   *params.CliqueConfig
  sigcache *lru.ARCCache        

  Number  uint64                      // Block number where the snapshot was created
  Hash    common.Hash                 // Block hash where the snapshot was created
  Signers map[common.Address]struct{} // 当前的所有有效的签名者
  Recents map[uint64]common.Address   // 最近生成过block的签名者。其中map的key是生成的block的高度
  Votes   []*Vote                     // 按时间先后顺序保存的投票信息
  Tally   map[common.Address]Tally    // 目前为止累计各被投人的票数
}
```

除了Votes和Tally，比较重要的字段就是Signers和Recents了。Signers字段比较好理解，就是当前可以出块的所有的签名者。各个节点根据这个字段的信息来判断某个块的签名者是否真的有权出块。注意这个字段是可以不断动态变化的，当某个账号地址的累计投票数超过一半时，就会被加入到Signers中（或从Signers中移除），实现代码摘录如下：

```go
func (s *Snapshot) apply(headers []*types.Header) (*Snapshot， error) {
  for _， header := range headers {
    ......

    //如果累计投票数超过一半
    if tally := snap.Tally[header.Coinbase]; tally.Votes > len(snap.Signers)/2 {
      if tally.Authorize {
        //如果是加入票，则将被投人加入到Signers列表中
        snap.Signers[header.Coinbase] = struct{}{}
      } else {
        //如果是踢出票，则把被投人从Signers中删除
        delete(snap.Signers， header.Coinbase)

        //将被投人从Recents信息中删除
        if limit := uint64(len(snap.Signers)/2 + 1); number >= limit {
          delete(snap.Recents， number-limit)
        }

        //丢弃被投人之前投出的所有投票
        for i := 0; i < len(snap.Votes); i++ {
          if snap.Votes[i].Signer == header.Coinbase {
            snap.uncast(snap.Votes[i].Address， snap.Votes[i].Authorize)
            snap.Votes = append(snap.Votes[:i]， snap.Votes[i+1:]...)
            i--
          }
        }
      }

      //清除所有被投人是当前生效人的投票信息
      for i := 0; i < len(snap.Votes); i++ {
        if snap.Votes[i].Address == header.Coinbase {
          snap.Votes = append(snap.Votes[:i]， snap.Votes[i+1:]...)
          i--
        }
      }
      delete(snap.Tally， header.Coinbase)  //清空当前生效人的票数统计信息
    }
  }

  ......
}
```

`Snapshot.Recents`字段保存了最近出块的签名者和所出的块的高度。这个“最近”的定义是最新的`len(Snapshot.Signers)/2 + 1`个块。我们先看一下代码是如何操作这个字段的：

```go
func (s *Snapshot) apply(headers []*types.Header) (*Snapshot， error) {
  for _， header := range headers {
    ......

    //将高度与当前块相差limit的块从Recents中删除掉
    if limit := uint64(len(snap.Signers)/2 + 1); number >= limit {
      delete(snap.Recents， number-limit)
    }
    ......

    //将当前块的高度和签名者加入Recents中
    snap.Recents[number] = signer
  }
}
```

比如目前有6个签名者，当前块的高度是10，那么高度为”10 - (6/2 + 1) = 6”的块将从Recents中删除，然后将高度为10的块和其签名者加入Recents中；处理一下个块即高度为11时，高度为7的块又会从Recents中删除，然后高度为11的块会被加入。总之，这个”最近”的基点是当前块的高度，囊括的范围为`len(Snapshot.Signers)/2 + 1`。下面我们看看在出块时Recents字段是如何起作用的：

```go
func (c *Clique) Seal(chain consensus.ChainReader， block *types.Block， results chan<- *types.Block， stop <-chan struct{}) error {
  ......

  for seen， recent := range snap.Recents {
    if recent == signer {
      // Signer is among recents， only wait if the current block doesn't shift it out
      if limit := uint64(len(snap.Signers)/2 + 1); number < limit || seen > number-limit {
        log.Info("Signed recently， must wait for others")
        return nil
      }
    }
  }

  ......
}
```

最后，我们要说一下Snapshot的创建过程。前面其实提到过，Snapshot的创建分两步：一是在某个checkpoint(包括genesis block)上调用`newSnapshot`生成一个Snapshot对象，然后调用这个对象的apply方法。这两步被封装在了`Clique.snapshot`方法中，即`Clique.snapshot`才是正确生成Snapshot对象的方法。因此我们来详细看一下Clique的snapshot方法。下面是摘录的代码，为了更清楚的表达逻辑，对代码进行了简化，并加了一些伪代码：

```go
func (c *Clique) snapshot(chain consensus.ChainReader， number uint64， hash common.Hash， parents []*types.Header) (*Snapshot， error) {
  headers []*types.Header

  for snap == nil {
    //首先从缓存或数据库中查找
    if snapshot in cache or database {
      get and break
    }

    //既不在缓存中也不在数据库中，那么看是否是创世块或没有父块的checkpoint。
    //关于为什么要判断没有父块的checkpoint，后面有详细说明
    if number == 0 || (number%c.config.Epoch == 0 && chain.GetHeaderByNumber(number-1) == nil) {
      checkpoint := chain.GetHeaderByNumber(number)

      //从checkpoint中取出signers列表
      signers := make([]common.Address， (len(checkpoint.Extra)-extraVanity-extraSeal)/common.AddressLength)
      for i := 0; i < len(signers); i++ {
        copy(signers[i][:]， checkpoint.Extra[extraVanity+i*common.AddressLength:])
      }

      //调用newSnapshot在checkpoint上创建Snapshot对象，并将其存入数据库中
      snap = newSnapshot(c.config， c.signatures， number， checkpoint.Hash()， signers)
      snap.store(c.db)
      break
    }

    //如果以上情况都不是，则往前回溯区块的链，并保存回溯过程中遇到的header
    header := get parent by number and hash
    headers = append(headers， header)
    number， hash = number-1， header.ParentHash
  }

  //把headers中保存的头从按高度从小到大排序。
  reverse(headers)

  //将回溯中遇到的headers传给apply方法，得到一个新的snap对象
  snap， err := snap.apply(headers)

  //保存snap对象
  store snap to cache
  if should store to database {
    snap.store(c.db)
  }
  return snap， err
}
```

从上面简化的代码中可以看到，想要创建一个Snapshot对象，需要从给定的block开始向前回溯，直到从缓存或数据库中找到对应的Snapshot，或者满足`number == 0 || (number%c.config.Epoch == 0 && chain.GetHeaderByNumber(number-1) == nil)`这个奇怪的条件。然后将回溯过程中遇到的header传给apply。在apply内部会根据传入的headers逐个统计投票等信息。

关于上面提到的这个奇怪的判断条件的分析，参看[奇怪的判断条件](http://yangzhe.me/2019/02/01/ethereum-clique/#odd_if)这一小节里的说明。

##### inturn and noturn

前面说过，clique作为PoA的实现，挖矿的人之间是合作关系，因此需要有规则规定某一时刻应该由谁出块。在clique中，`inturn`状态代表的是“按道理轮到我出块了”，而`noturn`正好相反。

在代码中，inturn的值为`diffInTurn`，noturn的值为`diffNoTurn`。Header.Difficulty字段用来保存相应的值，它的计算方式非常简单，具体可以查看Snapshot.inturn方法，这里不再多说。

在`Clique.Seal`方法中，签名时会进行一定时间的等待。如果Header.Difficulty的值为`diffNoTurn`，则会比`diffInTurn`的块随机多等待一些时间，通过这种方式可以保证轮到出块的人可以优先出块。代码如下：

```
func (c *Clique) Seal(chain consensus.ChainReader， block *types.Block， results chan<- *types.Block， stop <-chan struct{}) error {
  ......

  //计算正常的等待出块时间
  delay := time.Unix(header.Time.Int64()， 0).Sub(time.Now()) // nolint: gosimple
  if header.Difficulty.Cmp(diffNoTurn) == 0 {
    //没有轮到我们出块，多等一会
    // It's not our turn explicitly to sign， delay it a bit
    wiggle := time.Duration(len(snap.Signers)/2+1) * wiggleTime
    delay += time.Duration(rand.Int63n(int64(wiggle)))

    log.Trace("Out-of-turn signing requested"， "wiggle"， common.PrettyDuration(wiggle))
  }

  ......
}
```

### 出块流程

在理解了前面提到的一些概念以后，我觉得再加上一个整体的视图，clique模块就非常容易理解了，因此这里我们从一个更高的视角来看一下clique的工作流程。

Clique对象包含两大块功能：Header的有效性验证和生成新的Header。有效性验证的方法全都是以”Verify”开头，比较容易理解，就不多说了。这里主要介绍一下生成新的block的流程。我将关键信息整理成了一张流程图。由于Clique对象只是实现了以太坊中共识接口的方法，主要流程还是由miner模块控制，因此这里也加入了简单的miner模块的流程。

![img](http://yangzhe.me/pic/ethereum-clique/flowchart.png)

### 关键问题

前面的分析已经涉及了几乎clique模块的所有重点，但为了清晰，这里把一些需要重点关注的关键问题单独拿出来，再针对性的进行一次说明。

#### 如何控制出块时机

所有的共识机制都需要有一套控制出块时机的方法，因为不可能在同一时间让所有人都出块。clique是通过两个方面对出块时机进行控制的：

1. recent列表
2. inturn或noturn

在clique中，不允许最近出过块的人再出块，必须间隔一定的高度，这是通过`Snapshot.Recents`字段控制的。在`Clique.Seal`方法中有如下一段代码：

```go
  for seen， recent := range snap.Recents {
    if recent == signer {
      // Signer is among recents， only wait if the current block doesn't shift it out
      if limit := uint64(len(snap.Signers)/2 + 1); number < limit || seen > number-limit {
        log.Info("Signed recently， must wait for others")
        return nil
      }
    }
  }
```

代码中`snap.Recents`保存的就是最近出的块的高度和块的签名者（signer），`seen`变量是块的高度，`recent`是这个块的签名者。这段代码表达的意思是，如果当前的签名者刚出过块（在Recents中），并且这个历史块的高度离新出块的高度相差在所有签名者数量的一半（严格来说是一半加1）以内，则不允许再出块。

比如目前共有7个签名者，将要新出的块高度为100，而我刚出过一个块的高度是97，那么这个高度为100的块我就不能再出了。（97 > 100 - (7/2 + 1)）

那么snap.Recents又是怎么来的呢？它是在`Snapshot.apply`中生成的：

```go
  // Delete the oldest signer from the recent list to allow it signing again
  if limit := uint64(len(snap.Signers)/2 + 1); number >= limit {
    delete(snap.Recents， number-limit)
  }
  // Resolve the authorization key and check against signers
  signer， err := ecrecover(header， s.sigcache)

  snap.Recents[number] = signer
```

可以看到在填充Recents时，会将高度比当前块小太多的块从Recents中踢出去（number - limit）。

从上面的分析中我们可以看到，在调用Seal时，其实是有大约一半数量的签名者都是可以出块的。那这一半的签名者都要出块吗？当然不是的。理想情况下，每一个时刻最好只有一个人出块。在clique中是使用inturn/noturn的机制实现的。

在前面的概念介绍时我们已经介绍过inturn概念，简单来说就是“当前是不是轮到我出块了”，判断方法是看当前块的高度是否和自己在签名者列表中的顺序一致。`Snapshot.inturn`方法实现了这一功能：

```go
func (s *Snapshot) inturn(number uint64， signer common.Address) bool {
  signers， offset := s.signers()， 0
  for offset < len(signers) && signers[offset] != signer {
    offset++
  }
  return (number % uint64(len(signers))) == uint64(offset)
}
```

在`Clique.Prepare`中会将“是否轮到自己”的值写到Header.Difficulty字段中：

```go
func (c *Clique) Prepare(chain consensus.ChainReader， header *types.Header) error {
  ......
  header.Difficulty = CalcDifficulty(snap， c.signer)
  ......
}

func CalcDifficulty(snap *Snapshot， signer common.Address) *big.Int {
  if snap.inturn(snap.Number+1， signer) {
    return new(big.Int).Set(diffInTurn)
  }
  return new(big.Int).Set(diffNoTurn)
}
```

然后在`Clique.Seal`中，会根据Header.Difficulty中的值判断“是否轮到自己”出块。如果不是，则要随机多等待点时间，这就给了该出块的人优先的出块权：

```go
func (c *Clique) Seal(chain consensus.ChainReader， block *types.Block， results chan<- *types.Block， stop <-chan struct{}) error {
  ......
  delay := time.Unix(header.Time.Int64()， 0).Sub(time.Now())
  if header.Difficulty.Cmp(diffNoTurn) == 0 {
    // It's not our turn explicitly to sign， delay it a bit
    wiggle := time.Duration(len(snap.Signers)/2+1) * wiggleTime
    delay += time.Duration(rand.Int63n(int64(wiggle)))
  }
}
```

所以，clique通过recent和inturn两种方式控制出块时机，最终给了该出块的人优先的出块权。

#### 如何动态调整签名者列表

前面我们也说过，在项目运行过程中，签名者可能会发生变化，需要一种机制能动态的调整签名者名单。在clique中，这种调整是通过投票实现的。即对是否要加入或踢除某人，现有签名者可以发起投票，当投票超过半数时投票通过，被投人被自动加入或踢出。下面我们来看看这种投票机制是怎么实现的。

我们先来看看如何发起投票。你可以在console中调用`clique.propose`来进行一次投票，比如：

> clique.propose(“0x8D5cC3e43CE479d81c7e1e4a6DebC8D6c126a9eF”， true)

调用此方法以后，投票信息就会写入`Clique.proposals`字段中。在随后出块调用`Clique.Prepare`方法时，会从`Clique.proposals`中随机选择一条投票信息，放到Header.Coinbase和Header.Nonce中：

```go
func (c *Clique) Prepare(chain consensus.ChainReader， header *types.Header) error {
  ......

  //非checkpoint才可以携带投票信息
  if number%c.config.Epoch != 0 {
    //从c.proposals中收集所有有意义的被投地址
    addresses := make([]common.Address， 0， len(c.proposals))
    for address， authorize := range c.proposals {
      if snap.validVote(address， authorize) {
        addresses = append(addresses， address)
      }
    }

    //如果确实有有意义的被投地址，随机选一个填入Header中
    if len(addresses) > 0 {
      header.Coinbase = addresses[rand.Intn(len(addresses))]
      if c.proposals[header.Coinbase] {
        copy(header.Nonce[:]， nonceAuthVote)
      } else {
        copy(header.Nonce[:]， nonceDropVote)
      }
    }
  }

  ......
}
```

现在票已经投出去了，我们再来看看如何统计投票信息，以及投票通过后如何生效。这些功能都是在`Snapshot.apply`方法中实现的：

```go
func (s *Snapshot) apply(headers []*types.Header) (*Snapshot， error) {
  for _， header := range headers {
    number := header.Number.Uint64()

    //如果达到一个epoch，则清空当前所有的投票信息
    if number%s.config.Epoch == 0 {
      snap.Votes = nil
      snap.Tally = make(map[common.Address]Tally)
    }

    //如果当前的投票人已经给某人投过票，则清除之前的投票信息
    //这保证了一个epoch内一个signer只能给某人投一次票，或用来撤消投票
    for i， vote := range snap.Votes {
      if vote.Signer == signer && vote.Address == header.Coinbase {
        snap.uncast(vote.Address， vote.Authorize)
        snap.Votes = append(snap.Votes[:i]， snap.Votes[i+1:]...)
        break
      }
    }

    //将本次的投票信息纳入统计
    var authorize bool
    switch {
      case bytes.Equal(header.Nonce[:]， nonceAuthVote):
        authorize = true
      case bytes.Equal(header.Nonce[:]， nonceDropVote):
        authorize = false
      default:
        return nil， errInvalidVote
    }
    if snap.cast(header.Coinbase， authorize) {
      snap.Votes = append(snap.Votes， &Vote{
        Signer:    signer，
        Block:     number，
        Address:   header.Coinbase，
        Authorize: authorize，
        })
    }

    //如果投票数量超过一半，则投票通过。
    if tally := snap.Tally[header.Coinbase]; tally.Votes > len(snap.Signers)/2 {
      //如果是加入票，则将被投人加入到Signers列表中
      //之后此人就可以出块了
      if tally.Authorize {
        snap.Signers[header.Coinbase] = struct{}{}
      } else {
        //如果是踢出票，则将被投人从Signers列表中踢出
        //之后这人就无法出块了
        delete(snap.Signers， header.Coinbase)

        //将被投人从Recents信息中删除
        if limit := uint64(len(snap.Signers)/2 + 1); number >= limit {
          delete(snap.Recents， number-limit)
        }

        //丢弃被投人之前投出的所有投票
        for i := 0; i < len(snap.Votes); i++ {
          if snap.Votes[i].Signer == header.Coinbase {
            snap.uncast(snap.Votes[i].Address， snap.Votes[i].Authorize)
            snap.Votes = append(snap.Votes[:i]， snap.Votes[i+1:]...)
            i--
          }
        }
      }

      //清除所有被投人是当前生效人的投票信息
      for i := 0; i < len(snap.Votes); i++ {
        if snap.Votes[i].Address == header.Coinbase {
          snap.Votes = append(snap.Votes[:i]， snap.Votes[i+1:]...)
          i--
        }
      }
      delete(snap.Tally， header.Coinbase) //清空当前生效人的票数统计信息
    }
  }
}
```

这段代码比较复杂，但通过代码中的中文注释，相信可以很容易弄明白其基本逻辑：当我们逐个遍历链上的block时，我们记录每个block上的投票信息，当投票总数达到半数以上时，对被投人作相应的操作——加入或踢除（踢除包含了更多操作）；如果遇到epoch，则之前统计的所有投票信息作废，全部清空（这在epoch概念中有详细讨论）。

#### 作恶的代价和处理

PoA机制无法保证所有签名者都不作恶。那么万一有人作恶，会造成什么影响呢？

相信经过前面不断的介绍，读者已经能理解clique的基本原理。签名者在clique中无法连续出块（Recent机制限制），因此如果有人作恶，它最多也只能每隔“出块人数量一半”的高度出一个块，这可以保证多数块是正确的，这一点与PoW类似（只要作恶者的能力（对于PoA来说是作恶的人的数量，对于PoW来说是算力）不超过一半，就可以保证多数块是正常的）。

clique有投票机制，如果及时发现某人作恶，其他签名者可以快速反应，将其强制踢出签名者列表。所以总得来说，clique的实现可以保证少量人作恶的情况下只能造成很小的影响，并且可以及时强制制止。

# 分布一致性算法

传统的分布式系统共识算法大多不考虑拜占庭容错问题，仅考虑网络延时或部分节点出现故障无法响应的情况下，非故障节点如何实现分布式系统的数据一致性。区块链系统运行在更为开放并且缺乏信任的网络环境中，节点数量众多且可能存在恶意节点。

## 非拜占庭容错算法与拜占庭容错算法

非拜占庭容错算法：Paxos -> Raft

拜占庭容错算法：BFT（PBFT）、PoW（PoS、PoA、DPoS、PoW+PoS（Casper））

## 状态机复制

状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。

我们通常所说的状态机是有限状态机，也就是被描述的事物的状态的数量是有限个，例如自动门的状态就是两个 open 和 closed 。

状态机的全称是有限状态自动机，自动两个字也是包含重要含义的。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。例如对于自动门，给定初始状态 closed ，给定输入“开门”，那么下一个状态时可以运算出来的。

#### 状态机四大概念

下面来给出状态机的四大概念

第一个是 State ，状态。一个状态机至少要包含两个状态。例如上面自动门的例子，有 open 和 closed 两个状态。

第二个是 Event ，事件。事件就是执行某个操作的触发条件或者口令。对于自动门，“按下开门按钮”就是一个事件。

第三个是 Action ，动作。事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action 一般就对应一个函数。

第四个是 Transition ，变换。也就是从一个状态变化为另一个状态。例如“开门过程”就是一个变换。

通过一个事件中的动作可以让一个状态变换到另一个状态。

### 复制状态机

一致性算法是在复制状态机（`Replicated State Machine`）的背景下提出来的。在这个方法中，一组 `Server` 的状态机计算相同状态的副本，并且即使有一部分 `Server` 宕机了它们仍然能够继续运行。在分布式系统中，复制状态机被用来解决各种容错问题。具有单个集群 `Leader` 的大规模系统，例如 `GFS`、`HDFS`、`RAMCloud`，一般使用一个单独的复制状态机来管理 `Leader` 选举和存储配置信息，必须能够使 `Leader` 从失败中恢复。使用复制状态机的例子包括 `Chubby`和 `ZooKeeper`。

![img](https://knowledge-sharing.gitbooks.io/raft/content/assets/Figure-1-Replicated-state-machine-architecture.png)

图：复制状态机架构。一致性算法管理来自客户端的状态机命令的复制日志。状态机处理日志中相同顺序的命令序列，因此会输出相同的结果。

如图所示，一般通过使用复制日志来实现复制状态机。每个 `Server`存储着一份包含命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。

保证复制日志的一致性是一致性算法的任务。一个 `Server` 上的一致性模块会接收来自客户端的命令，并把命令添加到它的日志文件中。它同其它 `Server` 上的一致性模块进行通信，确保每一个日志最终包含相同的请求且顺序也相同，即使某些 `Server` 故障。一旦这些命令被正确复制，每个 `Server` 的状态机都会按照日志中的顺序去处理，将输出结果返回给客户端。最终，这些 `Server` 看起来就像一个单独的、高可靠的状态机。

对于实际系统，一致性算法一般具有如下特点：

- 安全。满足在所有非拜占庭条件下确保安全（从来不会返回错误结果），包括网络延迟、分区、丢包、重复和重排序。
- 高可用。只要集群中的大部分 `Server` 正常运行，并能够互相通信且可以同客户端通信，这个集群就完全可用。因此，拥有5个 Server 的集群可以容忍其中的2个 `Server` 失败。假使通过停掉某些 `Server` 使其失败，稍后它们会从持久化存储的状态进行恢复，并重新加入到集群中。
- 不依赖于时序。确保日志的一致性：时钟错误，以及极端情况下的消息延迟，在最坏的情况下都会造成可用性问题。
- 通常情况下，只要集群中大多数 `Server` 成功响应了某一轮 `RPC` 调用，一个命令就算完成。少部分较慢的 `Server` 不应该影响到整个系统性能。

## CAP

![img](https://bkimg.cdn.bcebos.com/pic/5bafa40f4bfbfbed9c15b19b72f0f736aec31f81?x-bce-process=image/watermark，image_d2F0ZXIvYmFpa2U5Mg==，g_7，xp_5，yp_5/format，f_auto)

- Consistency（一致性）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
- Availability（可用性）：保证每个请求不管成功或者失败都有响应。
- Partition tolerance（分区容错性）：系统中任意信息的丢失或失败不会影响系统的继续运作。

### 分区容错性

![img](https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png)



G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。

### 一致性

写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。

![img](https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png)

接下来，用户的读操作就会得到 v1。这就叫一致性。

![img](https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png)

问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。

![img](https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png)

为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。

![img](https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png)

这样的话，用户向 G2 发起读操作，也能得到 v1。

![img](https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png)

### 可用性

只要收到用户的请求，服务器就必须给出回应。

用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。

### 矛盾

一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。

如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。

读者问，在什么场合，可用性高于一致性？

举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。

一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。

## Paxos

paxos现在大多是应用于replication的一致性，用来实现一个多节点一致的日志。

目的：让参与分布式处理的每个参与者逐步达成一致意见。或者说，在一个选举过程中，让不同的选民最终做出一致的决定。

假想了一个叫做Paxos的希腊城邦进行选举的情景，这个算法也是因此而得名。在他的假想中，这个城邦要采用民主提议和投票的方式选出一个最终的决议，但由于城邦的居民没有人愿意把全部时间和精力放在这种事情上，所以他们只能不定时的来参加提议，不定时来了解提议、投票进展，不定时的表达自己的投票意见。Paxos算法的目标就是让他们按照少数服从多数的方式，最终达成一致意见。 

具体情况

1. 在整个提议和投票过程中，主要的角色就是“提议者”（向“接受者”提出提议）和“接受者”（收到“提议者”的提议后，向“提议者”表达自己的意见）。 
2. 第一阶段：因为存在多个“提议者”，如果都提意见，那么“接受者”接受谁的不接受谁的？太混乱了。所以，要先明确哪个“提议者”是意见领袖有权提出提议，未来，“接受者”们就主要处理这个“提议者”的提议了。
3. 第二阶段：由上阶段选出的意见领袖提出提议，“接受者”反馈意见。如果多数“接受者”接受了一个提议，那么提议就通过了。

问题

1）怎么明确意见领袖呢？通过编号。每个“提议者”在第一阶段先报个号，谁的号大，谁就是意见领袖。如果不好理解，可以想象为贿选。每个提议者先拿着钞票贿赂一圈“接受者”，谁给的钱多，第二阶段“接受者”就听谁的。（注：这里和下文提到的“意见领袖”，并不是一个新的角色，而是代表在那一轮贿赂成功的“提议者”。所以，请把意见领袖理解为贿赂中胜出的“提议者”即可）

2）有个跟选举常识不一样的地方，就是每个“提议者”不会执着于让自己的提议通过，而是每个“提议者”会执着于让提议尽快达成一致意见。所以，为了这个目标，如果“提议者”在贿选的时候，发现“接受者”已经接受过前面意见领袖的提议了，即便“提议者”贿选成功，也会默默的把自己的提议改为前面意见领袖的提议。所以一旦贿赂成功，胜出的“提议者”再提出提议，提议内容也是前面意见领袖的提议。

3）钱的多少很重要，如果钱少了，无论在第一还是第二阶段“接受者”都不会理你，直接拒绝。

4）上面2）中讲到，如果“提议者”在贿选时，发现前面已经有意见领袖的提议，那就将自己的提议默默改成前面意见领袖的提议。这里有一种情况，如果你是“提议者”，在贿赂的时候，“接受者1”跟你说“他见过的意见领袖的提议是方案1”，而“接受者2”跟你说“他见过的意见领袖提议是方案2”，你该怎么办？这时的原则也很简单，还是：钱的多少很重要！你判断一下是“接受者1”见过的意见领袖有钱，还是“接受者2”见过的意见领袖有钱？如何判断呢？因为“接受者”在被“提议者”贿赂的时候，自己会记下贿赂的金额。所以当你贿赂“接受者”时，一旦你给的贿赂多而胜出，“接受者”会告诉你两件事情：a.前任意见领袖的提议内容（如果有的话），b.前任意见领袖当时贿赂了多少钱。这样，再面对刚才的情景时，你只需要判断一下“接受者1”和“接受者2”告诉你的信息中，哪个意见领袖当时给的钱多，那你就默默的把自己的提议，改成那个意见领袖的提议。

5）最后这一部分最有意思，但描述起来有点绕，如果不能一下子就理解可以先看后面的例子。在整个选举过程中，每个人谁先来谁后到，“接受者”什么时间能够接到“提议者”的信息，是完全不可控的。所以很可能一个意见领袖已经产生了，但是由于这个意见领袖的第二阶段刚刚开始，绝大部分“接受者”还没有收到这个意见领袖的提议。结果，这时突然冲进来了一个新的土豪“提议者”，那么这个土豪“提议者”也是有机会让自己的提议胜出的！

a.上一个意见领袖要赶在土豪“提议者”贿赂到“接受者”前，赶到“接受者”面前让他接受自己的提议，否则会因为自己的之前贿赂的钱比土豪少而被拒绝。b.土豪“提议者”要赶在上一个意见领袖将提议传达给“接受者”前，贿赂到“接受者”，否则土豪“提议者”即便贿赂成功，也要默默的将自己的提议改为前任意见领袖的提议。这整个博弈的过程，最终就看这两个“提议者”谁的进展快了。但最终一定会有一个意见领袖，先得到多数“接受者”的认可，那他的提议就胜出了。

**总结**

1）Paxos算法包括两个阶段：第一个阶段主要是贿选，还没有提出提议；第二个阶段主要根据第一阶段的结果，明确接受谁的提议，并明确提议的内容是什么（这个提议可能是贿选胜出“提议者”自己的提议，也可能是前任意见领袖的提议，具体是哪个提议，见下面第3点原则）。

2）编号（贿赂金额）很重要，无论在哪个阶段，编号（贿赂金额）小的，都会被鄙视（被拒绝）。

3）在第一阶段中，一旦“接受者”已经接受了之前意见领袖的提议，那后面再来找这个“接受者”的“提议者”，即便在贿赂中胜出，也要被洗脑，默默将自己的提议改为前任意见领袖的提议，然后他会在第二阶段提出该提议（也就是之前意见领袖的提议，以力争让大家的意见趋同）。如果“接受者”之前没有接受过任何提议，那贿选胜出的“提议者”就可以提出自己的提议了。

**举例**

最后举个例子，加深一下印象：

有两个“提议者”和三个“接受者”。

1）首先“提议者1”贿赂了3个“接受者”

![img](https://pic4.zhimg.com/80/v2-7ac400cb745b36f0667391999e828d14_720w.jpg?source=1940ef5c)

2）3个“接受者”记录下贿赂金额，因为目前只有一个“提议者”出价，因此$1就是最高的了，所以“接受者”们返回贿赂成功。此外，因为没有任何先前的意见领袖提出的提议，因此“接受者”们告诉“提议者1”没有之前接受过的提议（自然也就没有上一个意见领袖的贿赂金额了）。

![img](https://pic4.zhimg.com/80/v2-8b2f4d5be0e96e808b9f5cd1bcce6c8e_720w.jpg?source=1940ef5c)

3）“提议者1”向“接受者1”提出了自己的提议：1号提议，并告知自己之前已贿赂$1。

![img](https://pic1.zhimg.com/80/v2-aec9d3006e40be28b49ba0d80e2c9a47_720w.jpg?source=1940ef5c)

4）“接受者1”检查了一下，目前记录的贿赂金额就是$1，于是接受了这一提议，并把1号提议记录在案。

![img](https://pic2.zhimg.com/80/v2-b04580b0ef8f5087fce2c636b4f925a6_720w.jpg?source=1940ef5c)

5）在“提议者1”向“接受者2”“接受者3”发起提议前，土豪“提议者2”出现，他开始用$2贿赂“接受者1”与“接受者2”。

![img](https://pic4.zhimg.com/80/v2-8efd4cd44a21d220160988c1f9a7d5ed_720w.jpg?source=1940ef5c)

6）“接受者1”与“接受者2”立刻被收买，将贿赂金额改为$2。但是，不同的是：“接受者1”告诉“提议者2”，之前我已经接受过1号提议了，同时1号提议的“提议者”贿赂过$1；而，“接受者2”告诉“提议者2”，之前没有接受过其他意见领袖的提议，也没有上一个意见领袖的贿赂金额。

![img](https://pic1.zhimg.com/80/v2-50c0841a1ee64eab377a4a01abe5d974_720w.jpg?source=1940ef5c)

7）这时，“提议者1”回过神来了，他向“接受者2”和“接受者3”发起1号提议，并带着信息“我前期已经贿赂过$1”。

![img](https://pic1.zhimg.com/80/v2-5d09580e20dff6e1e464449ee5fbec61_720w.jpg?source=1940ef5c)

8）“接受者2”“接受者3”开始答复：“接受者2”检查了一下自己记录的贿赂金额，然后表示，已经有人出价到$2了，而你之前只出到$1，不接受你的提议，再见。但“接受者3”检查了一下自己记录的贿赂金额，目前记录的贿赂金额就是$1，于是接受了这一提议，并把1号提议记录在案。

![img](https://pic1.zhimg.com/80/v2-06c42e88602406736aba0d3fcd59f67c_720w.jpg?source=1940ef5c)

9）到这里，“提议者1”已经得到两个接受者的赞同，已经得到了多数“接受者”的赞同。于是“提议者1”确定1号提议最终通过。

10）下面，回到“提议者2”。刚才说到，“提议者2”贿赂了“接受者1”和“接受者2”，被“接受者1”告知：“之前已经接受过1号提议了，同时1号提议的‘提议者’贿赂过$1”，并被“接受者2”告知：“之前没有接到过其他意见领袖的提议，也没有其他意见领袖的贿赂金额”。这时“提议者2”，拿到信息后，判断一下，目前贿赂过最高金额（即$1）的提议就是1号提议了，所以“提议者2”默默的把自己的提议改为与1号提议一致，然后开始向“接受者1”“接受者2”发起提议（提议内容仍然是1号提议），并带着信息：之前自己已贿赂过$2。

![img](https://pic4.zhimg.com/80/v2-6a1856fdc8380a8841a822ef32ed072f_720w.jpg?source=1940ef5c)

11）这时“接受者1”“接受者2”收到“提议者2”的提议后，照例先比对一下贿赂金额，比对发现“提议者2”之前已贿赂$2，并且自己记录的贿赂金额也是$2，所以接受他的提议，也就是都接受1号提议。

![img](https://pic2.zhimg.com/80/v2-32b1eabfec9a6969ba1437a0972861f6_720w.jpg?source=1940ef5c)

12）于是，“提议者2”也拿到了多数派的意见，最终通过的也是1号提议。

回到上面的第5）步，如果“提议者2”第一次先去贿赂“接受者2”“接受者3”会发生什么？那很可能1号提议就不会成为最终选出的提议。因为当“提议者2”先贿赂到了“接受者2”“接受者3”，那等“提议者1”带着议题再去找这两位的时候，就会因为之前贿赂的钱少（$1<$2）而被拒绝。所以，这也就是刚才讲到可能存在博弈的地方：a.“提议者1”要赶在“提议者2”贿赂到“接受者2”“接受者3”之前，让“接受者2”“接受者3”接受自己的意见，否则“提议者1”会因为钱少而被拒绝；b.“提议者2”要赶在“提议者1”之前贿赂到“接受者”，否则“提议者2”即便贿赂成功，也要默默的将自己的提议改为“提议者1”的提议。但你往后推演会发现，无论如何，总会有一个“提议者”的提议获得多数票而胜出。

## Raft

Paxos算法不容易实现，Raft算法是对Paxos算法的简化和改进

1. Leader领导节点，负责发出提案
2. Follower追随者节点，负责同意Leader发出的提案
3. Candidate候选人，负责争夺Leader

![img](https://pic2.zhimg.com/80/v2-b503e1b87b4888a82df87896cae29bad_720w.jpg)

步骤：Raft算法将一致性问题分解为两个的子问题，**Leader选举**和**状态复制**

### Leader选举

1. 每个Follower都持有一个**定时器**。

   ![img](https://pic2.zhimg.com/80/v2-54ff345bdee35c3b90efef4e525aea69_720w.jpg)

2. 当定时器时间到了而集群中仍然没有Leader，Follower将声明自己是Candidate并参与Leader选举，同时**将消息发给其他节点来争取他们的投票**，若其他节点长时间没有响应Candidate将重新发送选举信息。

   ![img](https://pic2.zhimg.com/80/v2-ddf8c68b3e1e57594a08f032482e8251_720w.jpg)

3. 集群中其他节点将给Candidate投票

   ![img](https://pic2.zhimg.com/80/v2-b0d887514aa22bf81a9ebdd2f03cc2dd_720w.jpg)

4. 获得多数派支持的Candidate将成为**第M任Leader**（M任是最新的任期）

   ![img](https://pic4.zhimg.com/80/v2-2bf8a06c823ad2fb38e1be20fe60b0df_720w.jpg)

5. 在任期内的Leader会**不断发送心跳**给其他节点证明自己还活着，其他节点受到心跳以后就清空自己的计时器并回复Leader的心跳。这个机制保证其他节点不会在Leader任期内参加Leader选举。

   ![img](https://pic1.zhimg.com/80/v2-bd510806788699634cab9500f6c2edfc_720w.jpg)

   ![img](https://pic3.zhimg.com/80/v2-5beebe7894d879cf1ea54f460467649e_720w.jpg)

6. 当Leader节点出现故障而导致Leader失联，没有接收到心跳的Follower节点将准备成为Candidate进入下一轮Leader选举

7. 若出现两个Candidate同时选举并获得了相同的票数，那么这两个Candidate将**随机推迟一段时间**后再向其他节点发出投票请求，这保证了再次发送投票请求以后不冲突

   ![img](https://pic3.zhimg.com/80/v2-70d1b9ad1fdb058b04ff7d5a521435be_720w.jpg)

### 状态复制

1. Leader负责接收来自Client的提案请求**（红色提案表示未确认）**

   ![img](https://pic1.zhimg.com/80/v2-a27ccc3437ed92669fa479f142176614_720w.jpg)

2. 提案内容将包含在Leader发出的**下一个心跳中**

   ![img](https://pic3.zhimg.com/80/v2-461b76641286d57534288d6b3be4dbf6_720w.jpg)

3. Follower接收到心跳以后回复Leader的心跳

   ![img](https://pic2.zhimg.com/80/v2-f5e771562f2eda04c8db30d1d8462e39_720w.jpg)

4. Leader接收到多数派Follower的回复以后**确认提案**并写入自己的存储空间中并**回复Client**

   ![img](https://pic4.zhimg.com/80/v2-3e614177fe59302ec933b629f55be2f7_720w.jpg)

5. Leader**通知Follower节点确认提案**并写入自己的存储空间，随后所有的节点都拥有相同的数据

   ![img](https://pic2.zhimg.com/80/v2-dd0d388855310707dd85b4ed6c8c5f6d_720w.jpg)

6. 若集群中出现网络异常，导致集群被分割，将出现多个Leader

   ![img](https://pic2.zhimg.com/80/v2-ad1fa60698389bc0efbe3413b2549729_720w.jpg)

7. 被分割出的非多数派集群将无法达到共识，即**脑裂**，如图中的A、B节点将无法确认提案

   ![img](https://pic1.zhimg.com/80/v2-093a8f1ea3c1ea389281036f7ee9c320_720w.jpg)

   ![img](https://pic2.zhimg.com/80/v2-e54f332371974d6124ba494fc68f6fd5_720w.jpg)

8. 当集群再次连通时，将**只听从最新任期Leader**的指挥，旧Leader将退化为Follower，如图中B节点的Leader（任期1）需要听从D节点的Leader（任期2）的指挥，此时集群重新达到一致性状态

   ![img](https://pic2.zhimg.com/80/v2-c86b7d545b291d7d07d4b47e53a334cd_720w.jpg)

   ![img](https://pic2.zhimg.com/80/v2-477365ef270e6e967fee60e64886cd6d_720w.jpg)

   

raft协议对这种情况的处理是，虽然出现了双主，但是由于老的领导者是不可能在数据复制阶段拿到大多数的确认的，所以老的领导者将不能够正常地写入数据，而新的领导者是可以正常写入数据的，当两者之间的网络恢复正常之后，老的领导者接收到了比它任期大的领导者发的消息，就会自动地转换为了跟随者，集群也就恢复了正常的状态。这里面可能出现的问题就是客户端是有可能从老的领导者分区中读取到老的数据的，这个在一般的情况下也是可以接受的。

其他情况：https://www.xiaoheidiannao.com/216527.html

# POA源码

这两种节点的角色可以互换，这种互换是通过对proposal的投票完成的。

- 任何节点N都可以提交一个Propose来申请成为signer，然后所有的signers集体投票
- 一个Signer只能给节点N投一张票
- 一张投票包括：投票节点地址，被投票节点地址，被投票节点认证状态
- 每进入一个新的epoch，所有之前的pending投票都作废

PoA的大概流程是这样的：

- **1.创世区块中指定一组认证节点(signers)， signer地址保存在区块Extra字段**
- **2.开始mining后，初始指定的signers对block进行签名和广播，签名结果保存在Extra字段**
- **3.由于可能发生signers改变，Extra字段更新已授权的signers**
- **4.每一个高度上处于IN-TURN状态的signer签名的Block优先广播，OUT-OF-TURN状态的随机延时一段时间再进行广播**
- **5.新的signer通过API接口发起proposal，该proposal复用blockHeader的coinbase字段(signerAddress)和nonce字段(0xffffffffffffffff)广播，原有signers对该proposal进行投票，票数过半该发起者成为真正的signer**
- **6.如果需要踢出一个signer，所有signers对该踢出行为进行投票，同样票数过半，该signer变成普通节点**



clique结构体

```go
// Clique是在Ropsten攻击之后支持Ethereum testnet的权威证明共识引擎
type Clique struct {
	config *params.CliqueConfig // 共识引擎配置
	db     ethdb.Database       // 用于存取检索点快照的数据库

	recents    *lru.ARCCache // 最近区块的快照，用于加速快照重组
	signatures *lru.ARCCache // 最近区块的签名，用于加速挖矿

	proposals map[common.Address]bool // 当前提出的proposals列表

	signer common.Address // signer地址
	signFn SignerFn       // 签名函数
	lock   sync.RWMutex   // 读写锁

	fakeDiff bool
}
```

共识引擎配置结构

```go
type CliqueConfig struct {
	Period uint64 `json:"period"` // 距离上一区块出块后的时间间隔(s)
	Epoch  uint64 `json:"epoch"`  // 重置投票和检查点的epoch长度
}
```

snapshot是指定时间点的投票状态

```go
type Snapshot struct {
	config   *params.CliqueConfig // clique共识配置
	sigcache *lru.ARCCache        // 最近区块签名的缓存，为了加速恢复

	Number  uint64                      `json:"number"`  // 快照建立的区块号
	Hash    common.Hash                 `json:"hash"`    // 区块hash
	Signers map[common.Address]struct{} `json:"signers"` // 当下Signer的集合
	Recents map[uint64]common.Address   `json:"recents"` // 最近签名区块地址的集合
	Votes   []*Vote                     `json:"votes"`   // 按顺序排列的投票列表
	Tally   map[common.Address]Tally    `json:"tally"`   // 当前投票结果，可以避免重新计算
}
```

其中，Vote是授权签名者为修改授权列表而进行的单一投票；Tally是Tally是一个简单的投票结果，以保持当前的投票得分。

```go
type Vote struct {
	Signer    common.Address `json:"signer"`    // 提出投票的signer
	Block     uint64         `json:"block"`     // 投票所在的区块编号
	Address   common.Address `json:"address"`   // 被投票更改认证状态的地址
	Authorize bool           `json:"authorize"` // 是否授权或取消对已投票帐户的授权
}

// Tally is a simple vote tally to keep the current score of votes. Votes that
// go against the proposal aren't counted since it's equivalent to not voting.
type Tally struct {
	Authorize bool `json:"authorize"` // 投票是关于授权新的signer还是踢掉signer
	Votes     int  `json:"votes"`     // 到目前为止希望通过提案的投票数
}
```

POA共识的实现逻辑

```go
func (c *Clique) Seal(chain consensus.ChainHeaderReader, block *types.Block, results chan<- *types.Block, stop <-chan struct{}) error {
	header := block.Header()

	number := header.Number.Uint64()
    // 当前区块是创世区块
	if number == 0 {
		return errUnknownBlock
	}
	// 不支持0-period的链
	if c.config.Period == 0 && len(block.Transactions()) == 0 {
		log.Info("Sealing paused, waiting for transactions")
		return nil
	}
	// 不要在整个签名过程中持有签名字段
	c.lock.RLock()
    // 获取signer和签名方法
	signer, signFn := c.signer, c.signFn
	c.lock.RUnlock()

	// 获取快照
	snap, err := c.snapshot(chain, number-1, header.ParentHash, nil)
	if err != nil {
		return err
	}
	if _, authorized := snap.Signers[signer]; !authorized {
		return errUnauthorizedSigner
	}
	// 如果是最近的signers中的一员，等待下一个块
	for seen, recent := range snap.Recents {
		if recent == signer {
			// 当前区块没有踢出Signer则继续等待
			if limit := uint64(len(snap.Signers)/2 + 1); number < limit || seen > number-limit {
				log.Info("Signed recently, must wait for others")
				return nil
			}
		}
	}
	// 执行到这说明协议允许我们来签名这个区块
	delay := time.Unix(int64(header.Time), 0).Sub(time.Now())
	if header.Difficulty.Cmp(diffNoTurn) == 0 {
		// 当前处于OUT-OF-TURN状态,随机一定时间延迟处理
		wiggle := time.Duration(len(snap.Signers)/2+1) * wiggleTime
		delay += time.Duration(rand.Int63n(int64(wiggle)))

		log.Trace("Out-of-turn signing requested", "wiggle", common.PrettyDuration(wiggle))
	}
	// 签名工作
	sighash, err := signFn(accounts.Account{Address: signer}, accounts.MimetypeClique, CliqueRLP(header))
	if err != nil {
		return err
	}
	copy(header.Extra[len(header.Extra)-extraSeal:], sighash)
	log.Trace("Waiting for slot to sign and propagate", "delay", common.PrettyDuration(delay))
	go func() {
		select {
		case <-stop:
			return
		case <-time.After(delay):
		}

		select {
		case results <- block.WithSeal(header):
		default:
			log.Warn("Sealing result is not read by miner", "sealhash", SealHash(header))
		}
	}()

	return nil
}
```

其中获取投票状态快照的方法为：

```go
func (c *Clique) snapshot(chain consensus.ChainHeaderReader, number uint64, hash common.Hash, parents []*types.Header) (*Snapshot, error) {
	// 在内存或磁盘上检索一个快照以检查检查点
	var (
        // 区块头
		headers []*types.Header
        // 快照对象
		snap    *Snapshot
	)
	for snap == nil {
		// 如果一个内存里的快照被找到
		if s, ok := c.recents.Get(hash); ok {
			snap = s.(*Snapshot)
			break
		}
		// 如果一个磁盘检查点的快照被找到
		if number%checkpointInterval == 0 {
            // 从数据库中加载一个快照
			if s, err := loadSnapshot(c.config, c.signatures, c.db, hash); err == nil {
				log.Trace("Loaded voting snapshot from disk", "number", number, "hash", hash)
				snap = s
				break
			}
		}
		// 处于创世区块，创建一个快照
		if number == 0 || (number%c.config.Epoch == 0 && (len(headers) > params.FullImmutabilityThreshold || chain.GetHeaderByNumber(number-1) == nil)) {
			checkpoint := chain.GetHeaderByNumber(number)
			if checkpoint != nil {
				hash := checkpoint.Hash()

				signers := make([]common.Address, (len(checkpoint.Extra)-extraVanity-extraSeal)/common.AddressLength)
				for i := 0; i < len(signers); i++ {
					copy(signers[i][:], checkpoint.Extra[extraVanity+i*common.AddressLength:])
				}
                // 创建新快照
				snap = newSnapshot(c.config, c.signatures, number, hash, signers)
				if err := snap.store(c.db); err != nil {
					return nil, err
				}
				log.Info("Stored checkpoint snapshot to disk", "number", number, "hash", hash)
				break
			}
		}
		// 没有这个区块头的快照，则收集区块头并向后移动
		var header *types.Header
		if len(parents) > 0 {
			// 如果有明确的父块，必须选出一个
			header = parents[len(parents)-1]
			if header.Hash() != hash || header.Number.Uint64() != number {
				return nil, consensus.ErrUnknownAncestor
			}
			parents = parents[:len(parents)-1]
		} else {
			// 没有明确的父块
			header = chain.GetHeader(hash, number)
			if header == nil {
				return nil, consensus.ErrUnknownAncestor
			}
		}
		headers = append(headers, header)
		number, hash = number-1, header.ParentHash
	}
	// 找到之前的快照，将所有pending的区块头放在它的前面
	for i := 0; i < len(headers)/2; i++ {
		headers[i], headers[len(headers)-1-i] = headers[len(headers)-1-i], headers[i]
	}
    // 通过区块头生成新的快照
	snap, err := snap.apply(headers)
	if err != nil {
		return nil, err
	}
    // 将当前快照区块的hash存到recents中
	c.recents.Add(snap.Hash, snap)

	// 如果生成了一个新的检查点快照，保存到磁盘上
	if snap.Number%checkpointInterval == 0 && len(headers) > 0 {
		if err = snap.store(c.db); err != nil {
			return nil, err
		}
		log.Trace("Stored voting snapshot to disk", "number", snap.Number, "hash", snap.Hash)
	}
	return snap, err
}
```

根据区块头创建一个新的signer的快照

```go
func (s *Snapshot) apply(headers []*types.Header) (*Snapshot, error) {
	if len(headers) == 0 {
		return s, nil
	}
	// 对入参区块头做完整性检查
	for i := 0; i < len(headers)-1; i++ {
		if headers[i+1].Number.Uint64() != headers[i].Number.Uint64()+1 {
			return nil, errInvalidVotingChain
		}
	}
    // 判断区块序号是否连续
	if headers[0].Number.Uint64() != s.Number+1 {
		return nil, errInvalidVotingChain
	}
	// 遍历区块头数组并建立新的快照
	snap := s.copy()

	var (
		start  = time.Now()
		logged = time.Now()
	)
	for i, header := range headers {
		// 移除检查点快照上的任何投票
		number := header.Number.Uint64()
		if number%s.config.Epoch == 0 {
			snap.Votes = nil
			snap.Tally = make(map[common.Address]Tally)
		}
		// 移除投票票数过半，移除signer
		if limit := uint64(len(snap.Signers)/2 + 1); number >= limit {
			delete(snap.Recents, number-limit)
		}
		// 解析授权密钥并检查签名者
		signer, err := ecrecover(header, s.sigcache)
		if err != nil {
			return nil, err
		}
		if _, ok := snap.Signers[signer]; !ok {
			return nil, errUnauthorizedSigner
		}
		for _, recent := range snap.Recents {
			if recent == signer {
				return nil, errRecentlySigned
			}
		}
        // 记录signer为该区块的签名者
		snap.Recents[number] = signer

		// 丢弃之前的投票
		for i, vote := range snap.Votes {
			if vote.Signer == signer && vote.Address == header.Coinbase {
				// 从缓存的计数中取消投票
				snap.uncast(vote.Address, vote.Authorize)

				// 从时间顺序列表中取消投票
				snap.Votes = append(snap.Votes[:i], snap.Votes[i+1:]...)
				break // only one vote allowed
			}
		}
		// 从签名者那里获得新的投票
		var authorize bool
		switch {
		case bytes.Equal(header.Nonce[:], nonceAuthVote):
			authorize = true
		case bytes.Equal(header.Nonce[:], nonceDropVote):
			authorize = false
		default:
			return nil, errInvalidVote
		}
		if snap.cast(header.Coinbase, authorize) {
			snap.Votes = append(snap.Votes, &Vote{
				Signer:    signer,
				Block:     number,
				Address:   header.Coinbase,
				Authorize: authorize,
			})
		}
		// 投票通过，更新signers列表
		if tally := snap.Tally[header.Coinbase]; tally.Votes > len(snap.Signers)/2 {
            // 投票是选举新signer
			if tally.Authorize {
				snap.Signers[header.Coinbase] = struct{}{}
			} else {
                // 投票是选移除signer
				delete(snap.Signers, header.Coinbase)

				// 签名者列表缩小，删除任何剩余的最近缓存
				if limit := uint64(len(snap.Signers)/2 + 1); number >= limit {
					delete(snap.Recents, number-limit)
				}
				// 放弃任何以前的授权签名者投票
				for i := 0; i < len(snap.Votes); i++ {
					if snap.Votes[i].Signer == header.Coinbase {
						snap.uncast(snap.Votes[i].Address, snap.Votes[i].Authorize)

						snap.Votes = append(snap.Votes[:i], snap.Votes[i+1:]...)

						i--
					}
				}
			}
			// 放弃已更改授权状态的账户之前的投票
			for i := 0; i < len(snap.Votes); i++ {
				if snap.Votes[i].Address == header.Coinbase {
					snap.Votes = append(snap.Votes[:i], snap.Votes[i+1:]...)
					i--
				}
			}
			delete(snap.Tally, header.Coinbase)
		}
		
		if time.Since(logged) > 8*time.Second {
			log.Info("Reconstructing voting history", "processed", i, "total", len(headers), "elapsed", common.PrettyDuration(time.Since(start)))
			logged = time.Now()
		}
	}
	if time.Since(start) > 8*time.Second {
		log.Info("Reconstructed voting history", "processed", len(headers), "elapsed", common.PrettyDuration(time.Since(start)))
	}
	snap.Number += uint64(len(headers))
	snap.Hash = headers[len(headers)-1].Hash()

	return snap, nil
}
```

综上分析，只有认证节点才有权利出块，其他节点只能同步区块。每次出块时，都会创建一个snapshot快照来表示当前时间的投票状态，这里涉及到了基于投票的认证节点的维护机制。

每次认证节点的改变都是通过api向外暴露的propose接口，然后所有的认证节点signers对该提议propose进行投票，超过半数通过投票，最后更新认证节点signer列表并将认证住状态发生改变的账户之前的投票做相应处理。

同样clique也会涉及到出块时间的控制。

```go
func (c *Clique) CalcDifficulty(chain consensus.ChainHeaderReader, time uint64, parent *types.Header) *big.Int {
	snap, err := c.snapshot(chain, parent.Number.Uint64(), parent.Hash(), nil)
	if err != nil {
		return nil
	}
	return calcDifficulty(snap, c.signer)
}

// clique共识难度调整算法 当前块的难度基于前一个块和当前的签名者
func calcDifficulty(snap *Snapshot, signer common.Address) *big.Int {
	if snap.inturn(snap.Number+1, signer) {
		return new(big.Int).Set(diffInTurn)
	}
	return new(big.Int).Set(diffNoTurn)
}

// 给定高度块的签名者是否轮流
func (s *Snapshot) inturn(number uint64, signer common.Address) bool {
	signers, offset := s.signers(), 0
	for offset < len(signers) && signers[offset] != signer {
		offset++
	}
	return (number % uint64(len(signers))) == uint64(offset)
}
```

这里的出块难度实际上就是基于签名者的。如果当前区块的签名者是轮流签名的，那么当前signer可以立即签名一个区块(因为已经轮到这个signer签名了)；反之，如果签名者不是轮流的，那么将会随机等待一段时间再签名这个区块(上个区块很可能就是这个singer签名的)。



