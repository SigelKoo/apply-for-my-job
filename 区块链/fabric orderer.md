# orderer

## solo共识

solo共识的方法chain.main()判断是配置交易消息还是普通交易消息，普通交易消息，检查消息中的配置序号是否小于目前通道的配置序号，若是则说明通道配置已发生更新，需要使用ProcessNormalMsg重新过滤验证该消息；调用BlockCutter().Ordered()添加普通交易消息，并将缓存消息列表切割成批量交易集合列表batches，遍历batches包含的批量交易集合batch，先调用CreateNextBlock(batch)创建新区块block，再调用WriteBlock将新区块block写入应用通道账本的区块文件。

### 区块切割（Block Cutting）
Orderer将交易排序后，每个Orderer节点还需要进行区块切割，只要满足BatchSize和BatchTimeout其中一个条件就将产生区块。

#### BatchSize

MaxMessageCount 一个区块的最大交易个数

AbsoluteMaxBytes 限制单个交易大小

PreferredMaxBytes 期待的区块大小

Orderer中一直在积累交易，当大小总额达到PreferredMaxBytes就可以出块，或者交易个数达到了MaxMessageCount同样可以出块。

但是最后一个交易bytes可能较大，不能保证总大小一定小于PreferredMaxBytes ，这时仍然是可以将交易包含进去出块的。单个交易的大小通过AbsoluteMaxBytes进行限制，超过该限制的交易会被拒绝掉。

#### BatchTimeout
区块可能一直达不到设置的大小，到了设置的“Timeout”时间后，只要有一个交易就会出块。

## Raft

通过Order()调用Submit()，将消息提交给Raft集群的Leader节点。

构造提交消息，提交给c.submitC通道。共识协程（主循环）会不断从c.submitC读取交易消息，然后判断当前集群序号，Leader是否是本节点，不是本节点不处理，转发给Leader节点，由Leader节点完成排序和切块后再同步给其他节点。

主循环处理各种请求：收到请求应答协程传来的提交请求、收到集群状态变更消息、切块计时器超时，触发尝试切块动作、收到集群快照消息、通道关闭，清理并退出循环。

下面将具体剖析对每种情况的处理。
1. 收到提交请求

   提交请求来自应答协程。应答协程收到客户端发来的交易消息，检查后，尝试提交给本地节点进行处理。如果本地节点是 Leader，则接收；否则会告诉应答协程 Leader 节点的序号，让它转发过去。

2. 收到集群状态更新消息

   收到集群状态变更消息，说明集群中有新的提交，可能是 Leader 发生变化、加减了节点，或是提交了新的区块，需要进行对应处理。

   如果本节点为 Leader，则创建后台切块协程（进行切块处理)；否则开始担任 Follower 角色。最后接受更新内容，记录区块到本地或更新共识配置。

3. 发生切块超时

   当发生切块超时时，节点从本地缓冲区按照规则对交易进行切割，并生成新的区块，放人打包区块通道内等待进一步处理。

4. 收到状态快照消息

   收到集群 Raft 状态快照的消息，需要对比检查当前状态，领先则忽略，否则需要追踪到新的状态快照。其中c.catchUp(sn)方法负责处理状态追踪的逻辑，拉取落后的区块并写入本地。

5. 通道停止服务

   通道停止后需要清理相关数据结构，包括停止计时器、通知关闭打包区块通道、停止定期的检查等。
