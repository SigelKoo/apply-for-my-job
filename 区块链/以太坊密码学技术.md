# 以太坊背后的密码学

### 私钥

生成私钥最重要的一步就是找到一个密码学安全的熵，或者称为随机源。生成以太坊私钥基本上就是在1和2 ** 256之间选择数字。只要选择的过程不可预测也不可重复，那么通过什么方式获得这个数字并不重要。以太坊软件使用底层操作系统的随机数生成器生成一个256位的“熵”。操作系统的随机数生成器通常以用户的一些随机行为为基础，因此，在生成随机数的过程中，系统可能要求用户随意滑动鼠标，或者在键盘上随意敲击几个键。另一种替代性方案是收集计算机麦克风通道中的噪声。

更准确地说，以太坊私钥可以是任何比2 ** 256略微小一点的正整数，2 ** 256是一个77位的十进制数字，接近于1.158×10 ** 77。私钥的数字与2 ** 256的前38位相同，这被定义为以太坊椭圆曲线的阶。要生成私钥，我们随机取出一个256比特的数字，然后检查它是否在有效范围内。用编程术语来说，其实现方式是：将一个（从密码学意义上安全的熵源中得出的）很大的随机字符串放入256比特的哈希算法中，比如Keccak-256或者SHA256，这两种算法会便捷地产生一个256比特的数字。如果这个结果在有效范围内，我们就有了一个合适的私钥。否则，我们就要用另一个随机数字再试一次。

### 公钥

每个以太坊公钥都是椭圆曲线上的一个点，也就是说，每个公钥都是一组x、y坐标，这个坐标正好满足椭圆曲线方程。

简单地说，以太坊的公钥由两个数字组合在一起。这两个数字由私钥经过单向计算得来。

公钥是通过对私钥使用椭圆曲线的乘法运算得来的，而这个乘法运算基本上是不可逆的：K = k * G，其中k是私钥，G是一个常量点，称为生成点，K是计算得来的公钥，*是椭圆曲线函数的乘法运算符号。这与普通乘法运算的规则是不同的，除了与普通乘法有相同的功能属性，其他都不一样。举个例子，反向运算（普通乘法的反向运算就是除法），也称为获取“离散对数”的计算，即在已知K的情况下求解k，是非常困难的，必须采用暴力穷举的方式尝试所有可能的k。

### 哈希函数

加密哈希函数是一种单向的哈希函数，可以将任意长度的数据映射为固定长度的比特序列。这种“单向性”意味着，如果我们只知道哈希函数的输出值，还原出输入数据在计算上是不可能的。要发现可能的输入值，唯一的方式就是暴力搜寻，检查每一个可能的输入是否能得到同样的输出值；给定无限的搜索空间，显然，求得原输入在实践中是不可能的。即便可以找到一些输入能产生同样的哈希值，也不一定就是我们想求的那个初始输入：因为哈希函数是“多对一”的函数。发现具有同样哈希值的两个输入的问题被称为哈希碰撞问题。粗略来说，哈希函数的性质越好，哈希碰撞的情形就越少。对以太坊来说，这基本上是不可能的。

应用：数据指纹、数据一致性（错误侦测）、工作量证明、身份认证（密码哈希和密钥延伸）、伪随机数生成器、消息承诺（commit-reveal机制）、唯一标识符

### 以太坊地址

以太坊地址是唯一标识符，从公钥或者合约通过单向哈希函数Keccak-256计算而来。

```
私钥k
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
```

```
公钥K（x和y坐标组合后以十六进制的方式显示）
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...
```

```
使用Keccak-256来计算公钥的哈希值
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

```
以太坊地址只保留公钥哈希值后20位
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

```
十六进制的表示方式
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

###### 混合编码校验

通过修改地址中字母的大小写，我们可以获得一种校验，用于保护地址的完整性，避免地址输入式的人为错误。

```
示例地址：0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
混合大小写编码：0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
```

我们对全小写的十六进制地址计算Keccak-256哈希。这个哈希被视为地址的数字指纹，为我们提供了一个方便的校验方式。任何地址中的微小变化，都会在对应的哈希中带来巨大的变化。这样我们就能发现可能存在的输入或者打字错误。接着，把这个哈希校验信息通过大写修改的方式融合到地址中。

针对全小写的地址计算一次哈希，不包括0x前缀：

```
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
```

注意检查地址中的字母，如果在哈希中对应的十六进制大于或者等于8，就把这个字母改为大写。如果我们把地址和它的十六进制哈希值并列在一起

```
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
```

在我们地址中，第四位有一个小写的d，哈希中对应位数的数值是6，因为它小于8，所以我们保持d的小写格式不变。地址中下一个字母是f，位于第六位。哈希值中对应位置的数字是c，它比8要大，因此我们把地址中的f改为大写的F。以此类推。如你所见，我们只使用了哈希值中的前20字节（40个十六进制字符）作为校验，因为地址中只有20字节。

###### 检测（最后一位F改为E）：

```
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886
```

有几个字母被错误地设定成了大写。现在，记住，大写的位置应该跟哈希校验的值匹配对应。

### 数字签名

数字签名可以签署任何消息。对以太坊交易来说，交易本身的细节就是以消息的形式使用的。

椭圆曲线密码学中的数学规则使消息（即交易细节）可以与私钥结合在一起，创建出只能用私钥生成的代码。这些代码就是所谓的数字签名。注意，一笔以太坊交易可被视为对特定账户的使用请求。以太坊交易可以转移资金或与智能合约交互，在被发送到以太坊网络时，交易必须附带一个与地址对应的私钥创建的签名。椭圆曲线数学意味着任何人都可以验证交易的有效性，只需校验数字签名是否与交易细节以及要转移资产的地址相匹配。验证过程完全无须使用私钥——私钥完全不必公开。然而，验证过程可以使人们打消疑虑，因为交易只能来自掌握着与以太坊地址对应的私钥的人。

### 密码学基于的困难

**当前椭圆曲线基于离散对数问题**

**原先的RSA基于质数分解问题**

### 以太坊系统里的密码学

1. 共识算法（PoW的哈希）
2. Merkle树的哈希
3. PoS对区块的签名
4. 交易签名
5. Layer1对Layer2的验证
6. 验证跨链交易
7. Rollup数字签名
8. 跨分片验证
9. 零知识证明
10. 其他的隐私保护