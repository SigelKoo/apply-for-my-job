2019-10-24 陈纯院士帮中央政治局答疑，解决链上链下数据协同的问题；在提升性能和计算能力，现有侧链和状态通道方案；链和链之间互相操作和可扩展，现有跨链；隐私保护，链下计算和连下存储。

侧链，国内外文献不多，但是已经实现的应用很多，很奇怪的一点，开题找到的论文综述不多。



状态通道

状态通道开辟联通交易双方的通道，锁定区块链部分状态，将交易中间过程和相关的大量数据计算与事务处理放在通道内处理，只把最终的状态提交到链上进行开辟通道前状态记录更新，通道内数据交互不需要经过链上共识，以节省时间达到提高系统效率的目的。

一旦参与者中有一方想要停止使用支付通道，可以将最后的状态更新提交至主链进行退出操作，结算下来的余额会退给发起支付通道的两方。主链可以通过核实签名和最后结余来验证状态更新的有效性，从而防止参与者使用无效状态来退出支付通道。

问题

主链无法验证支付通道是否提交了全部交易，也就是说，在提交了状态更新之后是否不再出现新的状态更新。在转账时，一方A向另一方B支付了资金，并等待B进行服务，但是在资金尚未到达B账户的情况下A请求退出支付通道，由于主链不知道还有另外的状态更新，会将退出交易视为有效。

解决方案

1. 在A发起退出交易之后，为B留出一段时间的挑战期。在此期间，B可以提交未完成结算的状态更新，里面包含A的签名，而且轮次序号也高于A在退出时提交的状态更新。

   需要频繁监控主链以确保他们的交易对手方没有使用过去的某个状态退出。使用瞭望塔技术将监视主链的任务委托给第三方。

2. 两人签署“结束证明”



侧链

构建一条完全独立的区块链，通过主链资产的双向锚定进行数据交互，侧链依赖于主链，但是独立于主链处理事物，而且会选择性地将区块头的快照发送至主链，从而防止分叉产生。有了这些快照，就可以有效防止分叉，即便侧链上的验证者串谋起来发动分叉攻击也没用。

锁定主链资产、释放到侧链、解锁资产、侧链交易、锁定侧链资产、返回主链、解锁主链资产。

问题

无效状态转换的攻击，主链本来就不可能验证侧链上的所有区块，超过一定数量的验证者串谋的话，他们可以创建一个完全无效的区块，窃取其他参与者的资产，并将这个区块的快照发送至主链，发起并完成一个退出交易，就可以成功“偷走”这些资产。

解决方案

1. 提供密码学证明来证明之前每次状态转换都是正确的。为了避免状态有效性问题，每当侧链运营者要对某个区块进行快照之时，都要提供一个SNARK（简洁化的非交互式知识证明），证明链已经使用相关的一组交易执行了有效的状态转换。

   侧链上有三个区块A、B和C。它们的快照分别对应主链上的区块X、Y和Z。每到一个时间点，主链只需要存储侧链上最新状态的默克尔根。在区块A进行快照之时，发送到主链上的交易包括：新状态S2的默克尔根h(S2)、S2的完整状态数据，或区块中的所有交易、一个zk-SNARK，证明在从状态哈希h(S1)到状态哈希h(S2)之间的所有交易都是有效的。

   通过提供密码学证明，运营者不能隐瞒数据，因为对区块进行快照的交易必须提交完整的区块或者完整的状态作为证明，并验证交易内容是正确的，之后交易内容会保存在主网上的调用数据内；不能生成含有无效状态转换的区块，因为必需提交一个zk-SNARK来证明状态转换的正确性，而无效区块是无法计算出zk-SNARK的；无法发动分叉攻击，因为分叉选择规则始终认可最新进行过快照的区块所在的那条链，即使这条链不是最长链。

2. 激励机制、保证金机制，并设定一段时间的挑战期。侧链运营者发布新的状态根时无需每次都接受主链智能合约的检验。相反，每个人都假设状态转换是正确的。不过。如果有人发布了一次不正确的状态转换，其它运营者或者用户都可以发布欺诈证明。欺诈证明就是通过重放导致链上发生状态转换的事务，并将得到的状态根与运营者发布的状态根进行对比。如果两个状态根不同，则欺诈证明成功，状态转换被取消。跟在该无效状态转换后面的状态转换也会被取消。如果争议期已过，就无法再对事务提出争议，事务被敲定。

   挑选争议期问题，时间长对用户不友好；时间短不能及时提出挑战；运营者贿赂以太坊矿工通过争议事务，会产生子博弈精炼纳什均衡，矿工帮助运营者会产生额外的成本，还会影响以太坊的价值，降低自己的利益；验证者两难困境，总奖励数固定，验证人数越多，预期收益越少，某个企业在侧链上构建了一个大型应用。如果这个系统被破坏，应用就无法运作，代币就会丧失价值。比特币就没有通过经济激励的方式来鼓励节点运营者存储完整的区块链事务史，或将本地数据提供给对等节点，但是人们还是会无私地做这些事情。

ZK-Rollup和OP-Rollup



PoA

PoA共识中出块权掌握在部分签名者手里，而普通人是无法参与的（无论你有多少算力、多少权益）。可见PoA共识牺牲了一部去中心化的特性，换来了一种可控性。

以太坊PoA：clique；

节点可以分为两类：可出块节点、不可出块节点，两者可动态转化

每一个可出块节点，可以利用本地节点的私钥对一个区块的数据进行签名，并将产生的数字签名放置在区块头中；

其他节点在接收到该区块后，利用数字签名和区块数据找出相应的节点，若节点在本地节点所维护的可出块节点列表中，且该区块通过所有共识相关的检测，则认为该区块是合法的；否则就认为接收到了一个恶意区块。

每个认证节点尽量均等，一个节点在一段时间内只能签发一个区块，防止恶意节点不停出块。

难度总值最大的链作为主链，轮到本节点签发区块，本节点产生的区块难度为2，否则为1

clique的缺点也在此，攻击者可以预知下一轮的出块者，提前进行攻击

PoA每一轮出块的间隔时间是可配置的，若为10秒，出块者在计算当前时间戳10秒后，延迟广播区块

改进PoA加入VRF

VRF可验证随机函数可以看作是一个随机预言机，意思是说我可以通过任意的一个输入，获得一个随机数输出： 

1. 对于不同的 Input，Output 的值是随机的，并且均匀分布在值域范围内。

2. 对于相同的 Input，它得到的 Output 一定是相同的。



以太坊地址生成

1. 生成 256 位随机数作为私钥。
2. 将私钥转化为 secp256k1 非压缩格式的公钥，即 512 位的公钥。
3. 使用散列算法 Keccak256 计算公钥的哈希值，转化为十六进制字符串。
4. 取十六进制字符串的后 40 个字母，开头加上 0x 作为地址。

比特币地址生成

1. 由私钥生成公钥

2. 公钥生成hash160

3. base58运算得到地址

solidity

```
pragma solidity ^0.5.16;

contract helloworld {
    function hi() public pure returns(string memory) {
        return "helloworld";
    }
}
```

```
pragma solidity ^0.5.16;

contract StateVariables {
    string name;
    address owner;

    constructor() public {
        name = "unknown";
        owner = msg.sender;
    }

    function setName(string memory _name) public returns (string memory) {
        if(msg.sender == owner) {
            name = _name;
        } else {
            revert("Permission denied.");
        }
        return name;
    }

    function getName() public view returns (string memory) {
        return name;
    }
}
```

```
pragma solidity ^0.5.16;

contract StateVariables {
    string name;
    uint public rename_counter;
    address owner;

    constructor() public {
        name = "unknown";
        owner = msg.sender;
        rename_counter = 0;
    }

    modifier checkOwner(address _addr) {
        require(_addr == owner);
        rename_counter += 1;
        _;
    }

    function setName(string memory _name) public checkOwner(msg.sender) returns (string memory) {
        name = _name;
        return name;
    }

    function getName() public view returns (string memory) {
        return name;
    }
}
```

```
pragma solidity ^0.5.16;

contract Test {
    bool isValid;

    constructor() public {
        isValid = true;
    }

    function f1() public returns (int) {
        isValid = false;
        assert(false);
        return 0;
    }

    function f2() public returns (int) {
        isValid = false;
        require(false, "require");
        return 0;
    }

    function f3() public returns (int) {
        isValid = false;
        revert("revert");
    }
}
```

```
pragma solidity ^0.5.16;

contract Test {
    string information;
    uint balance;

    event LogCreate(string information, uint balance);
    event LogCreateIndex(string indexed information, uint indexed balance);

    constructor() public {
        information = "default";
        balance = 100;
        emit LogCreate(information, balance);
        emit LogCreateIndex(information, balance);
    }
}
```

```
pragma solidity ^0.5.16;

contract FallbackExample {
    event LogFallback(string message);
    event LogBalance(uint balance);

    function () external payable {
        emit LogFallback("Fallback");
        emit LogBalance(address(this).balance);
    }
}
```

```
pragma solidity ^0.5.16;

contract Address {
    function() external payable {
        
    }

    function Balance() public view returns (uint256) {
        return address(this).balance;
    }

    function Transfer(uint256 amount) public returns (bool) {
        msg.sender.transfer(amount * 1 ether);
        return true;
    }

    function SendWithoutCheck(uint256 amount) public returns (bool) {
        msg.sender.send(amount * 1 ether);
        return true;
    }

    function SendWithCheck(uint256 amount) public returns (bool) {
        require(msg.sender.send(amount * 1 ether));
        return true;
    }
}
```

```
pragma solidity ^0.5.16;

contract Donation {
    mapping(address => uint) public ledger;
    mapping(address => bool) public donors;
    address[] public donorList;

    function isDonor(address pAddr) internal view returns (bool) {
        return donors[pAddr];
    }

    function donate() public payable {
        if(msg.value >= 1 ether) {
            if(!isDonor(msg.sender)) {
                donors[msg.sender] = true;
                donorList.push(msg.sender);
            }
            ledger[msg.sender] = msg.value;
        } else {
            revert("< 1 ether");
        }
    }
}
```

```
pragma solidity ^0.5.16;

contract Class {
    struct Student {
        string name;
        uint score;
        bool active;
    }
    mapping(uint => Student) students;

    modifier ActiveStudent(uint id) {
        require(students[id].active);
        _;
    }

    function register(uint id, string memory name) public {
        students[id] = Student({name: name, score: 0, active: true});
    }

    function modifyScore(uint id, uint score) public ActiveStudent(id) {
        students[id].score = score;
    }

    function getStudent(uint id) public ActiveStudent(id) view returns (string memory, uint) {
        return (students[id].name, students[id].score);
    }
}
```

```
pragma solidity ^0.5.16;

contract Donation {
    struct DonorInfo {
        address[] donors;
        mapping(address => uint) ledger;
    }

    mapping (address => DonorInfo) DonationHistory;

    event LogDonate(address streamer, address donor, string nickname, uint value, string message);
    function donate(address payable _streamer, string memory _nickname, string memory _message) public payable {
        require(msg.value > 0);
        _streamer.transfer(msg.value);
        if(DonationHistory[_streamer].ledger[msg.sender] == 0) {
            DonationHistory[_streamer].donors.push(msg.sender);
        }
        DonationHistory[_streamer].ledger[msg.sender] += msg.value;
        
        emit LogDonate(_streamer, msg.sender, _nickname, msg.value, _message);
    }

    function getDonorList() public view returns (address[] memory) {
        return DonationHistory[msg.sender].donors;
    }

    event LogListDonorInfo(address streamer, address user, uint value);

    function listDonorInfo() public {
        for(uint i = 0; i < DonationHistory[msg.sender].donors.length; i++) {
            address user = DonationHistory[msg.sender].donors[i];
            emit LogListDonorInfo(msg.sender, user, DonationHistory[msg.sender].ledger[user]);
        }
    }
}
```

```
pragma solidity ^0.5.16;

contract Ownable {
    address private owner;
    constructor() internal {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    function isOwner() public view returns (bool) {
        return owner == msg.sender;
    }
}

contract Main is Ownable {
    string public name = "";
    function modifyName(string memory _name) public onlyOwner {
        name = _name;
    }
}
```

```
pragma solidity ^0.5.16;

interface Animal {
    function run(uint speed) external returns (uint);
}

contract Cat is Animal {
    function run(uint speed) public returns(uint distance) {
        return speed * speed;
    }
}

contract Dog is Animal {
    function run(uint speed) public returns(uint distance) {
        return speed * 10;
    }
}
```

```
pragma solidity ^0.5.16;

library Set {
    struct Data {
        mapping(int => bool) data;
    }
    function Insert(Data storage d, int key) public returns (bool) {
        if(d.data[key])
            return false;
        d.data[key] = true;
        return true;
    }
    
    function Remove(Data storage d, int key) public returns (bool) {
        if(!d.data[key])
            return false;
        d.data[key] = false;
        return true;
    }
    
    function Contain(Data storage d, int key) public view returns (bool) {
        return d.data[key];
    }
}

contract Main {
    Set.Data set;
    function insert(int key) public returns (bool) {
        return Set.Insert(set, key);
    }
    function remove(int key) public returns (bool) {
        return Set.Remove(set, key);
    }
    function contain(int key) public view returns (bool) {
        return Set.Contain(set, key);
    }
}
```

```
pragma solidity ^0.5.16;

/**
 * @title SafeMath
 * @dev Unsigned math operations with safety checks that revert on error.
 */
library SafeMath {
    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

contract Main {
    function test() public pure returns (uint256) {
        uint256 a = 100;
        uint256 b = 10;
        return SafeMath.add(a, b);
    }
}
```

```
pragma solidity ^0.5.16;

import "./safemath.sol";
 
contract Main {
    uint a = 2;
    uint b = 6;
    uint c = 8;
    //引入safemath库
    using SafeMath for uint256;
    
    //加法
    function addNum()public view returns(uint d){
        d = a.add(b);
    }
    //减法
    function subNum()public view returns(uint d){
        d = b.sub(a);
    }
    //乘法
    function mulNum()public view returns(uint d){
        d = a.mul(b);
    }
    //除法
    function divNum()public view returns(uint d){
        d = c.div(a);
    }
}
```

```
// Abstract contract for the full ERC 20 Token standard
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
pragma solidity ^0.4.21;


contract EIP20Interface {
    /* This is a slight change to the ERC20 base standard.
    function totalSupply() constant returns (uint256 supply);
    is replaced with:
    uint256 public totalSupply;
    This automatically creates a getter function for the totalSupply.
    This is moved to the base contract since public getter functions are not
    currently recognised as an implementation of the matching abstract
    function by the compiler.
    */
    /// total amount of tokens
    // 目前ERC20代币有多少数量，1000枚就1000
    uint256 public totalSupply;

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    // 读取_owner拥有多少代币
    function balanceOf(address _owner) public view returns (uint256 balance);

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    // 转账，msg.sender转给to
    function transfer(address _to, uint256 _value) public returns (bool success);

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    // 将代币token从from转给to，msg.sender花费的不是自己的钱，而是from给他的
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of tokens to be approved for transfer
    /// @return Whether the approval was successful or not
    // 作为msg.sender，授权給spender，可以使用我的代币token的量
    function approve(address _spender, uint256 _value) public returns (bool success);

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    // 一个owner查询給spender代币token的剩余量
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    // solhint-disable-next-line no-simple-event-func-name
    // Transfer从_from转到_to，转了多少_value的事件
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    // owner授权spender花多少_value
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
```

```
pragma solidity ^0.5.16;

import "SafeMath.sol";

contract ERC20 {
    using SafeMath for uint256;

    string public constant name = "token";
    uint8 public constant decimals = 18;
    string public constant symbol = "T";

    uint256 private _totalSupply;
    mapping(address => uint256) _balances;
    mapping(address => mapping(address => uint256)) _approve;
    
    mapping(address => bool) minters;
    address private owner;
    
    bool private _paused;
    
    constructor() public {
        owner = msg.sender;
        _paused = false;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier onlyMinter() {
        require(minters[msg.sender]);
        _;
    }
    
    modifier whenPaused() {
        require(_paused);
        _;
    }
    
    modifier whenNotPaused() {
        require(!_paused);
        _;
    }

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address tokenOwner) external view returns (uint256 balance) {
        return _balances[tokenOwner];
    }

    function transfer(address to, uint256 value) external returns (bool success) {
        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] += _balances[to].add(value);
        
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool success) {
        _approve[from][msg.sender] = _approve[from][msg.sender].sub(value);
        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool success) {
        _approve[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
    
    function addMinter(address addr) public onlyOwner returns (bool) {
        minters[addr] = true;
        return true;
    }

    function allowance(address tokenowner, address spender) external view returns (uint256 remaining) {
        return _approve[tokenowner][spender];
    }
    
    function mint(address to, uint256 tokens) public onlyMinter returns (bool) {
        _totalSupply = _totalSupply.add(tokens);
        _balances[to] = _balances[to].add(tokens);
        emit Transfer(address(0), to, tokens);
        return true;
    }
    
    function burn(uint256 tokens) public returns (bool) {
        require(tokens <= _balances[msg.sender]);
        _totalSupply = _totalSupply.sub(tokens);
        _balances[msg.sender] = _balances[msg.sender].sub(tokens);
        
        emit Burn(msg.sender, tokens);
        emit Transfer(msg.sender, address(0), tokens);
        return true;
    }
    
    function pause() public onlyOwner whenNotPaused returns (bool) {
        _paused = true;
        emit Pause(msg.sender);
        return true;
    }
    
    function unpause() public onlyOwner whenPaused returns (bool) {
        _paused = false;
        emit unPause(msg.sender);
        return true;
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    event Burn(address account, uint256 tokens);
    
    event Pause(address addr);
    
    event unPause(address addr);
}
```

```
pragma solidity ^0.5.16;

import "SafeMath.sol";

contract MiningShare {
    using SafeMath for uint256;

    // 召集人
    address private owner = address(0);
    // 召集人募资时间
    uint256 private closeBlock = 0;
    // 投资人
    // 投资金额
    mapping(address => uint256) private usersEther;
    // 提领金额
    mapping(address => uint256) private usersWithdraw;
    // 记录参数
    // 总投资金额
    uint256 private totalEther = 0;
    // 总提领金额
    uint256 private totalWithdraw = 0;

    constructor() public {
        owner = msg.sender;
        closeBlock = block.number + 2000;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier beforeCloseBlock() {
        require(block.number <= closeBlock);
        _;
    }
    
    modifier onlyShareHolders() {
        require(usersEther[msg.sender] != 0);
        _;
    }
    
    modifier afterCloseBlock() {
        require(block.number > closeBlock);
        _;
    }

    function CapitalIncrease(address account, uint256 Ether) public onlyOwner beforeCloseBlock {
        usersEther[account] = usersEther[account].add(Ether);
        totalEther = totalEther.add(Ether);
    }
    
    function CapitalDecrease(address account, uint256 Ether) public onlyOwner beforeCloseBlock {
        usersEther[account] = usersEther[account].sub(Ether);
        totalEther = totalEther.sub(Ether);
    }
    
    function MyTotalEther() public view onlyShareHolders returns (uint256) {
        return usersEther[msg.sender];
    }
    
    function MyTotalWithdraw() public view onlyShareHolders afterCloseBlock returns (uint256) {
        return usersWithdraw[msg.sender];
    }
    
    function TotalMind() public view onlyShareHolders afterCloseBlock returns (uint256) {
        return totalWithdraw.add(address(this).balance);
    }
    
    function Withdraw() public onlyShareHolders afterCloseBlock {
        uint256 totalMind = totalWithdraw.add(address(this).balance);
        uint256 userCanWithdraw = totalMind.mul(usersEther[msg.sender].div(totalEther)).sub(usersWithdraw[msg.sender]);
        usersWithdraw[msg.sender].add(userCanWithdraw);
        totalWithdraw.add(userCanWithdraw);
        msg.sender.transfer(userCanWithdraw);
    }
}
```



