# 构建链表

https://learnku.com/articles/56289

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val int
	Next *ListNode
}

func main() {
	list := new(ListNode)
	createListTail(list, 5)
	createListTail(list, 4)
	createListTail(list, 3)
	createListTail(list, 2)
	createListTail(list, 1)
	Print(list)
}

func createListTail(head *ListNode, n int) *ListNode {
	for node := head; node != nil; node = node.Next {
		if node.Next == nil {
			node.Next = &ListNode{n, nil}
			break
		}
	}
	return head
}

func Print(listNode *ListNode) {
	if listNode == nil {
		fmt.Println(nil)
	}
	temp := listNode.Next
	for temp != nil {
		fmt.Print(temp.Val, " ")
		temp = temp.Next
	}
	fmt.Println()
}
```

# 构建二叉树

```go
package main

import "fmt"

type TreeNode struct {
	Val int
	Left *TreeNode
	Right *TreeNode
}

func (node *TreeNode) Print() {
	fmt.Print(node.Val, " ")
}

func (node *TreeNode) PreOrder() {
	if node == nil {
		return
	}
	node.Print()
	node.Left.PreOrder()
	node.Right.PreOrder()
}

func (node *TreeNode) MiddleOrder() {
	if node == nil {
		return
	}
	node.Left.MiddleOrder()
	node.Print()
	node.Right.MiddleOrder()
}

func (node *TreeNode) PostOrder() {
	if node == nil {
		return
	}
	node.Left.PostOrder()	
	node.Right.PostOrder()
    node.Print()
}

func main() {
	root := TreeNode{Val: 3}
	root.Left = &TreeNode{}
	root.Left.Val = 0
	root.Left.Right = &TreeNode{Val: 2}
	root.Right = &TreeNode{Val: 5}
	root.Right.Left = &TreeNode{Val: 4}
	root.PreOrder()
	fmt.Println()
	root.MiddleOrder()
}
```



# 协程交替输出1-100奇偶数

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	A := make(chan int, 1)
	B := make(chan int, 1)
	C := make(chan int, 1)
	wg.Add(3)

	count := 0

	A <- 0

	go func(chan int, int, chan int) {
		for count < 100 {
			select {
			case <- A:
				if count < 100 {
					fmt.Println("A", count)
				}
				count++
				B <- 0
			}
		}
		defer wg.Done()
	}(A, count, B)

	go func(chan int, int, chan int) {
		for count < 100 {
			select {
			case <- B:
				if count < 100 {
					fmt.Println("B", count)
				}
				count++
				C <- 0
			}
		}
		defer wg.Done()
	}(B, count, C)

	go func(chan int, int, chan int) {
		for count < 100 {
			select {
			case <- C:
				if count < 100 {
					fmt.Println("C", count)
				}
				count++
				A <- 0
			}
		}
		defer wg.Done()
	}(C, count, A)

	wg.Wait()
}
```

# 组合总和

```go
func combinationSum2(candidates []int, target int) [][]int {
    var trcak []int
    var res [][]int
    var history map[int]bool
    history=make(map[int]bool)
    sort.Ints(candidates)
    backtracking(0,0,target,candidates,trcak,&res,history)
    return res
}
func backtracking(startIndex,sum,target int,candidates,trcak []int,res *[][]int,history map[int]bool){
    //终止条件
    if sum==target{
        tmp:=make([]int,len(trcak))
        copy(tmp,trcak)//拷贝
        *res=append(*res,tmp)//放入结果集
        return
    }
    if sum>target{return}
    //回溯
    // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
    // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
    for i:=startIndex;i<len(candidates);i++{
        if i>0&&candidates[i]==candidates[i-1]&&history[i-1]==false{
                continue
        }
        //更新路径集合和sum
        trcak=append(trcak,candidates[i])
        sum+=candidates[i]
        history[i]=true
        //递归
        backtracking(i+1,sum,target,candidates,trcak,res,history)
        //回溯
        trcak=trcak[:len(trcak)-1]
        sum-=candidates[i]
        history[i]=false
    }
}
```

# 翻转字符串里的单词

```go
import (
	"fmt"
)

func reverseWords(s string) string {
	//1.使用双指针删除冗余的空格
	slowIndex, fastIndex := 0, 0
	b := []byte(s)
	//删除头部冗余空格
	for len(b) > 0 && fastIndex < len(b) && b[fastIndex] == ' ' {
		fastIndex++
	}
    //删除单词间冗余空格
	for ; fastIndex < len(b); fastIndex++ {
		if fastIndex-1 > 0 && b[fastIndex-1] == b[fastIndex] && b[fastIndex] == ' ' {
			continue
		}
		b[slowIndex] = b[fastIndex]
		slowIndex++
	}
	//删除尾部冗余空格
	if slowIndex-1 > 0 && b[slowIndex-1] == ' ' {
		b = b[:slowIndex-1]
	} else {
		b = b[:slowIndex]
	}
	//2.反转整个字符串
	reverse(&b, 0, len(b)-1)
	//3.反转单个单词  i单词开始位置，j单词结束位置
	i := 0
	for i < len(b) {
		j := i
		for ; j < len(b) && b[j] != ' '; j++ {
		}
		reverse(&b, i, j-1)
		i = j
		i++
	}
	return string(b)
}

func reverse(b *[]byte, left, right int) {
	for left < right {
		(*b)[left], (*b)[right] = (*b)[right], (*b)[left]
		left++
		right--
	}
}
```

# 左旋转字符串

```go
func reverseLeftWords(s string, n int) string {
    b := []byte(s)
    // 1. 反转前n个字符
    // 2. 反转第n到end字符
    // 3. 反转整个字符
    reverse(b, 0, n-1)
    reverse(b, n, len(b)-1)
    reverse(b, 0, len(b)-1)
    return string(b)
}
// 切片是引用传递
func reverse(b []byte, left, right int){
    for left < right{
        b[left], b[right] = b[right],b[left]
        left++
        right--
    }
}
```

# 二分查找

```go
func BinarySearch(arr []int, value int) int {
	left := 0
	right := len(arr) - 1
	for left <= right {
		middle := left + (right - left) / 2
		if value == arr[middle] {
			return middle
		}
		if value < arr[middle] {
			right = middle - 1
		} else {
			left = middle + 1
		}
	}
	return -1
}
```

# 反转链表

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    for head != nil {
        head.Next, head, prev = prev, head.Next, head
    }
    return prev
}
```

# 排序链表

```go
func sortList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil { // 递归的出口，不用排序 直接返回
		return head
	}
	slow, fast := head, head // 快慢指针
	var preSlow *ListNode    // 保存slow的前一个结点
	for fast != nil && fast.Next != nil {
		preSlow = slow
		slow = slow.Next      // 慢指针走一步
		fast = fast.Next.Next // 快指针走两步
	}
	preSlow.Next = nil  // 断开，分成两链
	l := sortList(head) // 已排序的左链
	r := sortList(slow) // 已排序的右链
	return mergeList(l, r) // 合并已排序的左右链，一层层向上返回
}

func mergeList(l1, l2 *ListNode) *ListNode {
	dummy := &ListNode{Val: 0}   // 虚拟头结点
	prev := dummy                // 用prev去扫，先指向dummy
	for l1 != nil && l2 != nil { // l1 l2 都存在
		if l1.Val < l2.Val {   // l1值较小
			prev.Next = l1 // prev.Next指向l1
			l1 = l1.Next   // 考察l1的下一个结点
		} else {
			prev.Next = l2
			l2 = l2.Next
		}
		prev = prev.Next // prev.Next确定了，prev指针推进
	}
	if l1 != nil {    // l1存在，l2不存在，让prev.Next指向l1
		prev.Next = l1
	}
	if l2 != nil {
		prev.Next = l2
	}
	return dummy.Next // 真实头结点
}
```

# LRU算法

```go
type entry struct {
    key, value int
}

type LRUCache struct {
    cap int
    cache map[int]*list.Element
    lst *list.List
}

func Constructor(capacity int) LRUCache {
    return LRUCache{capacity, map[int]*list.Element{}, list.New()}
}

func (this *LRUCache) Get(key int) int {
    element := this.cache[key]
    if element == nil {
        return -1
    }
    this.lst.MoveToFront(element)
    return element.Value.(entry).value
}

func (this *LRUCache) Put(key int, value int)  {
    if element := this.cache[key]; element != nil {
        element.Value = entry{key, value}
        this.lst.MoveToFront(element)
        return
    }
    this.cache[key] = this.lst.PushFront(entry{key, value})
    if len(this.cache) > this.cap {
        delete(this.cache, this.lst.Remove(this.lst.Back()).(entry).key)
    }
}
```

# 快速排序

```go
func quicksort(arr []int, start, end int) {
	if start < end {
		i, j := start, end
		key := arr[(start + end) / 2]
		for i < j {
			for arr[i] < key { // 一直找到大于key的
				i++
			}
			for arr[j] > key { // 一直找到小于key的
				j--;
			}
			if i <= j { // 交换arr[i]和arr[j]顺序
				arr[i], arr[j] = arr[j], arr[i]
				i++
				j--
			}
			if start < j {
				quicksort(arr, start, j)
			}
			if end > i {
				quicksort(arr, i, end)
			}
		}
	}
}
```

```go
type stack struct {
	s []*element
}

type element struct {
	l int
	r int
}

func (s *stack) push(l, r int) {
	e := element{l, r}
	s.s = append(s.s, &e)
}

func (s *stack) pop() *element {
	if len(s.s) == 0 {
		return nil
	}
	temp := s.s[0]
	s.s = s.s[1:]
	return temp
}

func quickSort(arr []int) {
	length := len(arr)
	var stack stack
	stack.push(0, length - 1)
	for {
		s := stack.pop()
		if s == nil {
			break
		}
		if s.l <= s.r {
			i := s.l
			j := s.r
			key := arr[(s.l + s.r) / 2]
			for i <= j {
				for arr[i] < key {
					i++
				}
				for arr[j] > key {
					j--
				}
				if i <= j {
					arr[i], arr[j] = arr[j], arr[i]
					i++
					j--
				}
			}
			if s.l < j {
				stack.push(s.l, j)
			}
			if s.r > i {
				stack.push(i, s.r)
			}
		}
	}
}
```

# 插入排序

```go
func insertSort(array []int)[]int  {
    n := len(array)
    for i:=1;i<n;i++ {
        for j:=i;j>0 && array[j] < array[j-1];j-- {
                array[j],array[j-1] = array[j-1],array[j]
            
        }    
    }
    return array
}
```

# 相交链表

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    pa, pb := headA, headB
    for pa != pb {
        if pa == nil {
            pa = headB
        } else {
            pa = pa.Next
        }
        if pb == nil {
            pb = headA
        } else {
            pb = pb.Next
        }
    }
    return pa
}
```

# 最长回文子串

```go
func longestPalindrome(s string) string {
    res := s[: 1]
    for i := 0; i < len(s); i++ {
        s1 := palindrome(s, i, i)
        s2 := palindrome(s, i, i + 1)
        if len(s1) > len(res) {
            res = s1
        }
        if len(s2) > len(res) {
            res = s2
        }
    }
    return res
}

func palindrome(s string, l, r int) string {
    for l >= 0 && r <= len(s) - 1 && s[l] == s[r] {
        l--
        r++
    }
    return s[l + 1 : r]
}
```

# 不用加号的加法

https://leetcode-cn.com/problems/add-without-plus-lcci/solution/java-wei-yun-suan-chao-100si-lu-qing-xi-g1h59/

```java
class Solution {
    public int add(int a, int b) {
        int m = a ^ b; //不进位加法
        int n = (a & b) << 1; //进位
        while (n != 0) {
            int temp = n ^ m;
            n = (m & n) << 1;
            m = temp;
        }
        return m;
    }
}
```

# 删除排序链表中的重复元素

```go
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    
    cur, next := head, head.Next
    for next != nil {
        if (cur.Val == next.Val) {
            cur.Next = next.Next
        } else {
            cur = cur.Next
        }
        next = next.Next
    }

    return head
}
```

# 阶乘后的零

https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/

```go
func trailingZeroes(n int) int {
    res := 0
    for n > 0 {
        res += n / 5
        n = n / 5
    }
    return res
}
```

# 字符串相加

```go
func addStrings(num1 string, num2 string) string {
    add := 0
    ans := ""
    for i, j := len(num1) - 1, len(num2) - 1; i >= 0 || j >= 0 || add != 0; i, j = i - 1, j - 1 {
        var x, y int
        if i >= 0 {
            x = int(num1[i] - '0')
        }
        if j >= 0 {
            y = int(num2[j] - '0')
        }
        result := x + y + add
        ans = strconv.Itoa(result%10) + ans
        add = result / 10
    }
    return ans
}
```

# 99乘法表

```go
package main
import "fmt"
func main() {
    // 遍历, 决定处理第几行
    for y := 1; y <= 9; y++ {
        // 遍历, 决定这一行有多少列
        for x := 1; x <= y; x++ {
            fmt.Printf("%d*%d=%d ", x, y, x*y)
        }
        // 手动生成回车
        fmt.Println()
    }
}
```

# 数组中第k个最大元素

```go
func findKthLargest(nums []int, k int) int {
	h := &MyHeap{}
	heap.Init(h)
	for i := range nums {
		heap.Push(h, nums[i])
		if h.Len() > k {
			heap.Pop(h)
		}
	}
	return heap.Pop(h).(int)
}

type MyHeap []int

func (h MyHeap) Len() int {
	return len(h)
}

func (h MyHeap) Less(i, j int) bool {
	return h[i] < h[j]
}

func (h MyHeap) Swap(i, j int)  {
	h[i], h[j] = h[j], h[i]
}

func (h *MyHeap) Push(x interface{})  {
	*h = append(*h, x.(int))
}

func (h *MyHeap) Pop() interface{} {
	old := *h
	l := len(old)
	x := old[l - 1]
	*h = old[0 : l - 1]
	return x
}
```

# 判断回文子串

```go
func isPalindrome(s string) bool {
	i, j := 0, len(s)-1
	for i < j {
		if s[i] != s[j] {
			return false
		}
		i++
		j--
	}
	return true
}
```

# 兔子繁殖

```go
package main
import "fmt"
var n int=0
func fei(a int) int{
	if a==1||n==2 {
		n=1
		return n
	}
	   n=fei(a-1)+fei(a-2)
		return n

}
func main()  {
	fmt.Println(fei(3))
}

```



