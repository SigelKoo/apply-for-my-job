- [八股文](#八股文)
  - [MySQL text查询发生几次IO](#mysql-text查询发生几次io)
    - [TEXT类型的IO](#text类型的io)
  - [删除数据库表中的所有数据](#删除数据库表中的所有数据)
  - [从内存中访问数据的过程](#从内存中访问数据的过程)
  - [Linux文件锁与记录锁](#linux文件锁与记录锁)
    - [flock](#flock)
    - [fcntl](#fcntl)
  - [信号量与互斥量](#信号量与互斥量)
  - [临界资源](#临界资源)
  - [服务器未监听任何端口](#服务器未监听任何端口)
  - [从代码到机器运行](#从代码到机器运行)
    - [例子](#例子)
  - [Linux TCP参数设置](#linux-tcp参数设置)
  - [实现TCP](#实现tcp)
    - [基于UDP实现](#基于udp实现)
    - [自己实现](#自己实现)
  - [系统资源无法满足TCP](#系统资源无法满足tcp)
  - [发送一个包，一直都没有响应，一个线程就会卡死在这里吗](#发送一个包一直都没有响应一个线程就会卡死在这里吗)
  - [服务器响应慢了](#服务器响应慢了)
    - [排除本机自身原因](#排除本机自身原因)
    - [服务器性能分析](#服务器性能分析)
    - [项目本身分析](#项目本身分析)
      - [虚拟机分析](#虚拟机分析)
    - [数据库分析（MySql）](#数据库分析mysql)
      - [最大连接数](#最大连接数)
      - [超时控制](#超时控制)
      - [DNS反向解析](#dns反向解析)
        - [表高速缓存](#表高速缓存)
      - [慢查询日志](#慢查询日志)
  - [如何保证网络传输的安全性](#如何保证网络传输的安全性)
    - [数据机密性](#数据机密性)
      - [非对称加密](#非对称加密)
      - [非对称加密 + 对称加密（多次传输）](#非对称加密--对称加密多次传输)
      - [非对称加密 + 对称加密（单次传输）](#非对称加密--对称加密单次传输)
    - [同时解决发送方鉴别与报文完整性](#同时解决发送方鉴别与报文完整性)
    - [同时解决三个问题的方案](#同时解决三个问题的方案)
    - [解决发送方鉴别的其他方案](#解决发送方鉴别的其他方案)
    - [解决数据完整性的其他方案](#解决数据完整性的其他方案)
  - [路由找最短路径](#路由找最短路径)
  - [微信抢红包算法](#微信抢红包算法)
    - [方法1：二倍均值法](#方法1二倍均值法)
    - [方法2：线段切割法](#方法2线段切割法)
  - [线程不安全](#线程不安全)
    - [线程安全的方式](#线程安全的方式)
  - [数据库容灾](#数据库容灾)
  - [微信支付输入密码](#微信支付输入密码)

# 八股文

## MySQL text查询发生几次IO

io次数与数据是否在buffer中、行在磁盘上的组织形式、是否利用索引都有关。
当索引是InnoDB时，参数列表:
Innodb_data_reads数据读请求量数量，包含 dic ，data，undo
Innodb_data_writes数据写请求量数量，包含 dic ，data，undo
Innodb_dblwr_writes 双写请求数
Innodb_log_writes 日志redo写请求数
计算IO公式：
Innodb_data_reads + Innodb_data_writes + Innodb_dblwr_writes + Innodb_log_writes
当索引是MyISAM时
计算公式：
Key_reads  * 2 +  Key_writes * 2 + Key_read_requests

命令行输入查询：
set profiling=1;
select * from tb;
...
...
show profile block io for query N;（适用5.1以上版本）
其他版本：
在开始前执行
flush status;
yoursql;
show status;
有很多状态变量可以查看,如:
Bytes_received
Bytes_sent
Last_query_cost 这个值*4k 就是随机读取的数据量，也就是IO次数

### TEXT类型的IO

MySQL 5.1 中的 innodb_plugin 引入了新的文件格式：`Barracuda (梭子鱼)`，该文件格式拥有新的两种行格式：compressed和dynamic，两种格式对blob字段采用完全溢出的方式，数据页中只存放20字节，其余的都存放在溢出段中，因此，强烈**不建议使用BLOB、TEXT、超过255长度的VARCHAR列类型**；`

![img](https://images2015.cnblogs.com/blog/268981/201704/268981-20170416172232149-2104583353.jpg)


## 删除数据库表中的所有数据

drop直接删掉表；

truncate删除的是表中的数据，再插入数据时自增长的数据id又重新从1开始；

delete删除表中数据，可以在后面添加where字句。

1. DELETE语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
2. 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。
3. 一般而言，drop > truncate > delete
4. 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view
5. TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。
6. truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
7. delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
8. truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚
9. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。
10. Truncate table 表名 速度快,而且效率高,因为：truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
11. TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

12. 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。

## 从内存中访问数据的过程

总体流程：1.获得数据在内存的物理地址；2.从内存中取数据

**获取物理地址**

需要使用虚拟地址（逻辑地址）进行转化：

先查找TLB（快表：为硬件结构，保存有部分内存中页表的内容，目的是提高效率），把虚拟地址写为二进制的形式，由页面大小得到页内偏移位数，剩下的是虚拟页号，在这里虚拟页号进一步分为TLB标记和TLB组索引。由组索引和TLB标记查看有无对应的物理页号及标记位是否为”1”，若存在，把物理页号拼接页内地址得到实地址

若不存在，说明TLB不命中，查找内存中的页表。这里就相对比较单纯了，通过页号及页表寄存器找到相应的页表项，看一下有没有物理页号及有效位是否为“1”，若有，则命中，把物理页号拼接到页内地址即得到实地址；若无，则比较麻烦了，说明内存中没有要找的这个页面，产生缺页中断，需从外存调入。

**根据地址来访问数据**

先查找高速缓存Cache（内存的部分副本），在根据第一步得到的物理地址进行查找时，要了解Cache的几种映射方式，主要是直接映射方式和组相连映射方式，根据 不同的映射方式来分析上一步得到的物理地址。

一般说来，我们由Cache索引和标志位找到Cache中位置，再查看有效位是否为“1”，即Cache中是否存在要查找的内存地址中内容的副本；若为“1”，即有效，则根据偏移量（字块内地址）取出Cache单元的内容即可。如不在，则要去主存中查找对应的物理地址的内容。

## Linux文件锁与记录锁

Linux文件锁用于同步多个进程对同一文件执行的IO操作，防止出现竞争状态。

文件锁分为建议性锁与强制性锁：

- 建议性锁用于协同多进程，即多个已知进程间的同步；每个进程都按照加锁，读写文件，解锁的步骤对同一文件执行IO操作；若文件已被其他进程锁定，则当前进程将等待或以失败返回；建议性锁并不能阻止其他进程在文件已加锁的情况下，不获得锁而强制执行与锁的类型相冲突的IO操作。
- 强制性锁除可用于协同多进程外，还可用于保护文件内容，以防止其他进程强制读写已被当前进程加锁的文件。

### flock

```c
#include <sys/file.h>

int flock(int fd, int operation);
```

fd指定用于引用文件的文件描述符

operation指定对该文件执行的相关锁操作

- LOCK_SH：设置共享（读）锁
- LOCK_EX：设置独占（写）锁
- LOCK_UN：解锁
- 默认情况下，若其他进程已对fd指定的文件加锁，则当前进程对该文件加锁时将被阻塞，直到对该文件加锁的进程执行解锁；若LOCK_SH或LOCK_EX与该标志进行按位或操作，则当前进程立即以失败返回，并将errno设置为EWOULDBLOCK/EAGAIN

进程对未加锁的文件执行解锁操作，或对已解锁的文件再次执行解锁操作，都不会产生错误。

对于同一文件，多个进程都可以设置共享锁，但在任一时间点，仅单一进程可以对该文件设置独占锁，且其他进程无法对该文件设置共享锁与独占锁，否则将以EWOULDBLOCK/EAGAIN错误失败，即同一文件的独占锁排斥所有其他类型的锁。

### fcntl

```c
#include <unistd.h>
#include <fcntl.h>

int fcntl(int fd, int cmd, struct flock *flockstr);
```

fd指定用于引用文件的文件描述符

flockstr指定锁的属性

```c
struct flock {
    short l_type;
    short l_whence;
    off_t l_start;
    off_t l_len;
    pid_t l_pid;
};
```

l_type指定锁的类型，可以设置为F_RDLCK/F_WRLCK/F_UNLCK，含义分别与flock(2)的LOCK_SH/LOCK_EX/LOCK_UN一致，且加锁的规则与flock(2)相同，即共享锁数量任意，独占锁单一且排他。

l_whence，l_start，l_len共同设置锁定区域：
l_whence与lseek(2)的whence参数含义相同，可以设置为SEEK_SET/SEEK_CUR/SEEK_END分别表示文件起始/文件当前偏移/文件末尾
l_start指定相对于l_whence的起始字节偏移数；l_whence为SEEK_CUR或SEEK_END时，l_start可以指定为负值
l_len指定从l_start与l_whence计算得出的偏移值开始，锁定区域的字节长度

- 值为0，表示从l_start与l_whence计算得出的偏移值开始，至文件末尾，而不论文件长度的变化
- 值为正数，表示[l_start, l_start+l_len-1]
- 值为负数，表示[l_start+l_len, l_start-1]

锁定的区域可以超过文件末尾，但l_start与l_len为负数时，与l_whence计算得出的偏移值不能超过文件起始位置，即字节0。

cmd指定对文件区域设置锁的方式

- F_SETLK：加锁(F_RDLCK/F_WRLCK)或解锁(F_UNLCK)；若该操作与其他进程对该文件区域的锁相冲突，则返回-1，并将errno设置为EACCES或EAGAIN。
- F_SETLKW：与F_SETLK相同，但与其他进程对该文件区域的锁相冲突时将阻塞，等待解锁；等待过程中若被信号中断，则返回-1，并将errno设置为EINTR。
- F_GETLK：检查是否可对文件指定区域加锁，但并不实际执行锁定操作，此时l_type值必须为F_RDLCK或F_WRLCK；若当前进程可以对文件内的指定区域加锁，则通过l_type返回F_UNLCK；若与其他进程的锁相冲突，则分别通过l_type返回锁的类型，l_whence，l_start，l_len返回锁定区域，l_pid返回锁定该文件区域的进程PID。

对文件区域解锁将立即返回，对并未加锁的区域解锁不会产生错误。

由于独占锁排斥所有其他类型的锁，因此若某进程已对某文件设置了共享锁，而其他进程请求对该文件设置独占锁时，将出现锁饥饿而可能被无限阻塞。

共享锁与独占锁之间没有优先级关系，对于多个对同一文件请求设置锁的进程，内核将按进程调度的顺序而非请求锁的顺序处理。

## 信号量与互斥量

信号量用在**多线程多任务同步**的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。

互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。比如对全局变量的访问，有时要加锁，操作完了，在解锁。

尽管两个概念有点类似，但是他们的侧重点不一样，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A，B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进行操作。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。**但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计**。

## 临界资源

临界资源是指每次仅允许一个进程访问的资源。属于临界资源的硬件有打印机、磁带机等，软件有消息缓冲队列、变量、数组、缓冲区等。诸进程间应采取互斥方式，实现对这种资源的共享。

每个进程中访问临界资源的那段代码称为临界区。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。为此，每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看它是否正被访问。如果此刻该临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：

- 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
- 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
- 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。
- 让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。

## 服务器未监听任何端口

RST是复位报文，TCP连接中出现RST的情况有如下几种：

1. 端口未打开
2. 请求超时
3. 提前关闭
4. 在一个已经关闭的socket上收到数据

UDP返回ICMP不可达

## 从代码到机器运行

gcc -o HelloWorld.c，就可以编译这段代码。根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作。

![img](https://pic3.zhimg.com/80/v2-f2b10135ed52436888a793327e4d5a4a_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-bde34df011c397ad42dc00fe6bd35226_720w.jpg)

是不是非常简单？这次我们发现读头不再来回移动了，而是靠地址总线寻找对应的“纸带格子”。读取写入数据由数据总线完成，而动作的控制就是控制总线的职责了。

### 例子

我们可以通过gcc -c -S HelloWorld得到（只能得到其汇编代码，而不能得到二进制数据）。我们用objdump -d HelloWorld程序，得到/lesson01/HelloWorld.dump，其中有很多库代码（只需关注main函数相关的代码），如下图：

![img](https://pic1.zhimg.com/80/v2-3991a042107b90612122b14596c65614_720w.jpg)

以上图中，分成四列：第一列为地址；第二列为十六进制，表示真正装入机器中的代码数据；第三列是对应的汇编代码；第四列是相关代码的注释。这是x86_64体系的代码，由此可以看出x86 CPU是变长指令集。

接下来，我们把这段代码数据装入最小电子计算机，状态如下图：

![img](https://pic3.zhimg.com/80/v2-5d4889e7bf20e670ee71cc9b6285c96e_720w.jpg)

以上，对应图中的伪代码你应该明白了：现代电子计算机正是通过内存中的信息（指令和数据）做出相应的操作，并通过内存地址的变化，达到程序读取数据，控制程序流程（顺序、跳转对应该图灵机的读头来回移动）的功能。

## Linux TCP参数设置

| **参数**                      | **描述**                                                     | **默认值**          | **优化值**           |
| ----------------------------- | ------------------------------------------------------------ | ------------------- | -------------------- |
| net.core.rmem_default         | 默认的TCP数据接收窗口大小（字节）。                          | 229376              | 256960               |
| net.core.rmem_max             | 最大的TCP数据接收窗口（字节）。                              | 131071              | 513920               |
| net.core.wmem_default         | 默认的TCP数据发送窗口大小（字节）。                          | 229376              | 256960               |
| net.core.wmem_max             | 最大的TCP数据发送窗口（字节）。                              | 131071              | 513920               |
| net.core.netdev_max_backlog   | 在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。 | 1000                | 2000                 |
| net.core.somaxconn            | 定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。 | 128                 | 2048                 |
| net.core.optmem_max           | 表示每个套接字所允许的最大缓冲区的大小。                     | 20480               | 81920                |
| net.ipv4.tcp_mem              | 确定TCP栈应该如何反映内存使用，每个值的单位都是内存页（通常是4KB）。第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力的上限；第三个值是内存使用的上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的BDP可以增大这些值（注意，其单位是内存页而不是字节）。 | 94011 125351 188022 | 131072 262144 524288 |
| net.ipv4.tcp_rmem             | 为自动调优定义socket使用的内存。第一个值是为socket接收缓冲区分配的最少字节数；第二个值是默认值（该值会被rmem_default覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是接收缓冲区空间的最大字节数（该值会被rmem_max覆盖）。 | 4096 87380 4011232  | 8760 256960 4088000  |
| net.ipv4.tcp_wmem             | 为自动调优定义socket使用的内存。第一个值是为socket发送缓冲区分配的最少字节数；第二个值是默认值（该值会被wmem_default覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是发送缓冲区空间的最大字节数（该值会被wmem_max覆盖）。 | 4096 16384 4011232  | 8760 256960 4088000  |
| net.ipv4.tcp_keepalive_time   | TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。 | 7200                | 1800                 |
| net.ipv4.tcp_keepalive_intvl  | 探测消息未获得响应时，重发该消息的间隔时间（秒）。           | 75                  | 30                   |
| net.ipv4.tcp_keepalive_probes | 在认定TCP连接失效之前，最多发送多少个keepalive探测消息。     | 9                   | 3                    |
| net.ipv4.tcp_sack             | 启用有选择的应答（1表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对CPU的占用。 | 1                   | 1                    |
| net.ipv4.tcp_fack             | 启用转发应答，可以进行有选择应答（SACK）从而减少拥塞情况的发生，这个选项也应该启用。 | 1                   | 1                    |
| net.ipv4.tcp_timestamps       | TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项。 | 1                   | 1                    |
| net.ipv4.tcp_window_scaling   | 启用RFC 1323定义的window scaling，要支持超过64KB的TCP窗口，必须启用该值（1表示启用），TCP窗口最大至1GB，TCP连接双方都启用时才生效。 | 1                   | 1                    |
| net.ipv4.tcp_syncookies       | 表示是否打开TCP同步标签（syncookie），内核必须打开了CONFIG_SYN_COOKIES项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载。 | 1                   | 1                    |
| net.ipv4.tcp_tw_reuse         | 表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 。 | 0                   | 1                    |
| net.ipv4.tcp_tw_recycle       | 能够更快地回收TIME-WAIT套接字。                              | 0                   | 1                    |
| net.ipv4.tcp_fin_timeout      | 对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。 | 60                  | 30                   |
| net.ipv4.ip_local_port_range  | 表示TCP/UDP协议允许使用的本地端口号                          | 32768 61000         | 1024 65000           |
| net.ipv4.tcp_max_syn_backlog  | 对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字。 | 2048                | 2048                 |

## 实现TCP

### 基于UDP实现

在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

- 添加seq/ack机制，确保数据发送到对端
- 添加发送和接收缓冲区，主要是用户超时重传。
- 添加超时重传机制。

详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

### 自己实现

![img](https://img-blog.csdnimg.cn/20200331162858401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg1OTI4MA==,size_16,color_FFFFFF,t_70)

- 序号：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。（第一张图中发送123序号为1，下一个报文段序号为4）
- 确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。
- 数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B。
- 6个控制位：

  - 紧急位URG：URG=1时， 标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
  - 确认位ACK：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。
  - 推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。
  - 复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。
  - 同步位SYN：SYN=1时，表明是一个连接请求/连接接受报文。
  - 终止位FIN：FIN=1时， 表明此报文段发送方数据已发完，要求释放连接。
- 窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。
- 检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段传输层协议号为6（TCP为6，UDP为17）。
- 紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数。
- 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认.....

## 系统资源无法满足TCP

socket返回错误码

| errnos        | AIX® 错误号 | HP-UX 错误号 | Solaris 错误号 | Linux 错误号 | 描述                                                         |
| :------------ | :---------- | :----------- | :------------- | :----------- | :----------------------------------------------------------- |
| EINTR         | 4           | 4            | 4              | 4            | 指定的函数被信号中断。                                       |
| EBADF         | 9           | 9            | 9              | 9            | 套接字错误。套接字可能已损坏。                               |
| EAGAIN        | 11          | 11           | 11             | 11           | 资源暂时不可用。                                             |
| EFAULT        | 14          | 14           | 14             | 14           | 地址错误。在连接时，使用了错误地址。在接收时，数据被定向到不存在的或受保护的进程地址空间部分。缓冲区无效。 |
| EBUSY         | 16          | 16           | 16             | 16           | 资源正忙。                                                   |
| EINVAL        | 22          | 22           | 22             | 22           | 传递至指定函数或套接字的无效自变量已关闭。如果存在内存覆盖或缓存溢出问题，那么可能返回 EINVAL 错误。 |
| ENFILE        | 23          | 23           | 23             | 23           | 系统中打开的文件太多。                                       |
| EMFILE        | 24          | 24           | 24             | 24           | 每进程文件描述符表已满。已超出进程的文件描述符/套接字数。    |
| ENOSPC        | 28          | 28           | 28             | 28           | 设备或系统表上未余下任何空间。                               |
| EPIPE         | 32          | 32           | 32             | 32           | 管道中断。                                                   |
| EWOULDBLOCK   | 54          | 246          | 11             | 11           | 在连接函数上，分配给 TCP/UDP 临时端口的范围已用完。（某些操作系统将同一错误返回为 EAGAIN。） |
| ENOTSOCK      | 57          | 216          | 95             | 88           | 对非套接字执行了套接字操作。                                 |
| ENOPROTOOPT   | 61          | 220          | 99             | 92           | 选项未知。                                                   |
| EADDRINUSE    | 67          | 226          | 125            | 98           | 已经在使用指定的地址。建立该连接的先前进程可能异常终止或未正确清除。 |
| EADDRNOTAVAIL | 68          | 227          | 126            | 99           | 不能从本地系统获取指定的主机名或 IP 地址。                   |
| ENETDOWN      | 69          | 228          | 127            | 100          | 网络已停止。                                                 |
| ENETUNREACH   | 70          | 229          | 128            | 101          | 没有任何至网络或主机的路由可用。                             |
| ENETRESET     | 71          | 230          | 129            | 102          | 网络在重置时删除了该连接。                                   |
| ECONNRESET    | 73          | 232          | 131            | 104          | 合作伙伴已重置连接。                                         |
| ENOBUFS       | 74          | 233          | 132            | 105          | 系统中没有足够的内存或资源可用来完成调用。                   |
| EISCONN       | 75          | 234          | 133            | 106          | 已连接该套接字。                                             |
| ENOTCONN      | 76          | 235          | 134            | 107          | 未连接套接字。                                               |
| ETIMEDOUT     | 78          | 238          | 145            | 110          | 连接已超时。                                                 |
| ECONNREFUSED  | 79          | 239          | 146            | 111          | 连接被拒绝。如果您尝试连接至数据库，请检查服务器上的数据库管理器和 TCP/IP 协议支持是否已成功启动。如果指定了 SOCKS 协议支持，那么还必须确保 SOCKS 服务器上的 TCP/IP 协议支持已成功启动。 |
| EHOSTDOWN     | 80          | 241          | 147            | 112          | 主机已当机。                                                 |
| EHOSTUNREACH  | 81          | 242          | 148            | 113          | 没有任何至主机的可用路由。                                   |

## 发送一个包，一直都没有响应，一个线程就会卡死在这里吗

当使用 read()/recv() 读取数据时：

1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。

2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。

3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。

解决

1. 套接字选项: SO_SNDTIMEO, SO_RCVTIMEO，调用setsockopt设置读/写超时时间。SO_RCVTIMEO是接收超时,SO_SNDTIMEO是发送超时。这种方式也不经常使用，因为这种方案不可移植，并且有些套接字的实现不支持这种方式。
2. select函数是在linux编程中很重要的一个函数，他有很多的功能，控制读、写、异常的集合，当然还有设置超时。

## 服务器响应慢了

### 排除本机自身原因

　　可以使用站长工具测试网站速度。[
](http://tool.chinaz.com/speedtest.aspx)

![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516091031088-952607803.png)

### 服务器性能分析

使用top命令查看服务器的资源使用情况，主要分析CPU和内存的使用情况（top 命令是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，默认5秒刷新一下进程列表，所以类似于 Windows 的任务管理器。）：

　　　　![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516092238463-1115064607.png)

第三行显示的是Cpu的使用情况，详细含义如下：

us---用户空间占用CPU的百分比、sy---内核空间占用CPU的百分比、ni---改变过优先级的进程占用CPU的百分比、id---空闲CPU百分比、wa---IO等待占用CPU的百分比、hi---硬中断（Hardware IRQ）占用CPU的百分比、si---软中断（Software Interrupts）占用CPU的百分比、st---Steal Time，分配给运行在主机上其它虚拟机的任务的实际CPU时间，一般只有在虚拟机OS。

第4行是当前的内存情况，服务器总内存8054352k，已使用2879468k，剩余5174884k，缓冲265728k。

我个人的理解是：当us的百分比小于50%时，是不需要去考虑服务器的配置问题的，如果服务器的us百分比长时间在70%以上时，可以考虑加强服务器的硬件配置。此外，还需要查看服务器的网络情况，下载一个大型文件基本就可以确定网络情况了。

### 项目本身分析

连接池，需要对连接池的配置进行分析（分析线程池的最大数量和释放时间等等）。

还有可能项目的设计方面不合理导致响应缓慢，这里就不详细说明了。

#### 虚拟机分析

使用top指令查看虚拟机的内存占用情况，有时候可以发现虽然虚拟机占用内存的百分比不大却有明显的上限值，我们就需要去查看虚拟机的配置情况。

解决方法（以tomcat为例）：　

![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516105724760-1312175352.png)

具体的数值根据实际情况而定。

### 数据库分析（MySql）

数据库的分析内容和需要考虑的方面有很多，这里只说本人遇到过的几种情况：

#### 最大连接数　　　　

show variables like '%max_connections%'; 查看最大连接数
show status like 'Threads%';当前连接的使用情况

　　![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516110529135-1479973964.png)

Threads_connected---打开的连接数

Threads_running---这个数值指的是激活的连接数，这个数值一般远低于connected数值

如果最大连接数的值太小可以根据实际情况进行修改，一般修改为1000即可，设置方法有两种：

1.临时设置，重启服务后将失效

　　　　![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516111323775-1382700176.png)

2.修改数据库配置文件，在/etc/my.cnf 文件的[mysqld]下增减一行：max_connections = 1000

#### 超时控制

mysql存在一项属性“wait_timeout”,默认值为28800秒(8小时)，wait_timeout的值可以设定，但最多只能是2147483，不能再大了。也就是约24.85天 ，可以通过show global variables like 'wait_timeout';命令来查看。

wait_timeout的含义是：一个connection空闲超过8个小时，Mysql将自动断开该connection，通俗的讲就是一个连接在8小时内没有活动，就会自动断开该连接。由于dbcp没有检验该connection是否有效，用其进行数据操作便会出现异常。

如果是由超时控制引起的问题，不建议修改wait_timeout的值，在数据库连接的url的后面加上“&autoReconnect=true&failOverReadOnly=false”即可解决。

#### DNS反向解析　　

MySQL数据库收到一个网络连接后，首先拿到对方的IP地址，然后对这个IP地址进行反向DNS解析从而得到这个IP地址对应的主机名。用主机名在权限系统里面进行权限判断。反向DNS解析是耗费时间的，有可能让用户感觉起来很慢。甚至有的时候，反向解析出来的主机名并没有指向这个IP地址，这时候就无法连接成功了。 可以在配置文件里面禁止MySQL进行反向DNS解析，只需在my.cnf的[mysqld]段落中加入如下行即可：

　　　　　　skip-name-resolve (windows与linux下一样的)

##### 表高速缓存

show global status like 'open%tables%';查看打开的表的数量：

　　![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516113228760-1132120466.png)　　　　　　

open_tables:是当前在缓存中打开表的数量。

opened_tables:是mysql自启动起，打开表的数量。

 当Opened_tables数值非常大，说明cache太小，导致要频繁地open table，可以查看下当前的table_open_cache设置：

show variables like 'table_open_cache';  查看缓存的上限值

　　![img](https://images2015.cnblogs.com/blog/1044869/201705/1044869-20170516113246932-1354351871.png)

设置table_open_cache的值有两种方式(如果是4G左右内存的服务器,建议设为2048):

1.临时设置，重启服务后将失效

set global table_open_cache=2048;

2.修改数据库配置文件

在/etc/my.cnf 文件的[mysqld]下增减一行：table_open_cache = 2048

#### 慢查询日志

记录的慢查询日志的目的是确认是否是由于某些语句执行缓慢而导致的服务器响应慢。

## 如何保证网络传输的安全性

三个方面：

1. **发送方鉴别**：确保接收到的数据，确实是由我们认为的那个人（或主机）发送来的，而不是其他人以虚假身份发送的；
2. **报文完整性**：确保我们接收到的报文就是发送方发送的初始报文，而没有被第三方进行篡改；
3. **数据机密性**：确保报文即使被其他人截获，也无法读出其中的信息，也就是要对数据加密；

### 数据机密性

#### 非对称加密

1. 发送方获取接受方的公钥，使用公钥对需要发送的数据进行加密，然后发送；
2. 接受方接收到后，使用自己的私钥进行解密，解析出数据；

#### 非对称加密 + 对称加密（多次传输）

1. 发送方随机生成一个密钥，然后获取接受方的公钥，使用公钥加密这个密钥，发送给接受方；
2. 接收方接收到加密的密钥后，使用自己的私钥解析出密钥，此时双方就完成了密钥同步；
3. 之后双方发送的所有数据，都可以使用这个密钥进行加密解密；

#### 非对称加密 + 对称加密（单次传输）

如果发送方只是需要向接收方发送一次数据，那先进行一次密钥同步可能有些浪费时间，可以使用如下方案解决：

1. 发送方随机生成一个密钥，然后使用这个密钥对数据进行加密；
2. 发送方使用接收方的公钥对数据密钥进行加密，然后将加密的数据和加密的密钥发送；
3. 接收方首先使用自己的私钥解析出密钥，然后使用解析出的密钥将数据解析出来；

### 同时解决发送方鉴别与报文完整性

1. 发送方使用一个`hash`算法（如`MD5`、`SHA-1`），计算需要发送的数据的`hash`值；
2. 使用自己的私钥，对计算出的`hash`值进行加密；
3. 将原始数据和加密后的`hash`值发送到接收方；
4. 接收方使用发送方的公钥解析出加密后的`hash`值；
5. 使用与发送方相同的`hash`算法，计算接收到的数据的`hash`值，与解析出的`hash`值进行比较；
6. 若这两个`hash`值一致，表示这个数据并没有被篡改；

### 同时解决三个问题的方案

1. 首先，对数据进行处理，也就是计算`hash`，然后使用自己的私钥加密`hash`；
2. 然后，将第一步计算出的`hash`与原始数据组合，使用非对称加密 + 对称加密的方式，进行加密，加密之后再进行发送，保证数据的隐秘性；
3. 接收方接收到数据后，对数据解密，得到原始数据和加密后的`hash`；
4. 完成发送方鉴别以及数据完整性校验；

### 解决发送方鉴别的其他方案

假设接收方和发送方有一个共享的密钥，则可以使用以下方式进行身份鉴别：

1. 发送方向接收方发送自己的身份，比如发送一个“我是xxx”；
2. 接收方为了验证不是其他人发送的虚假数据，向发送方发送一个随机数，这个随机数短时间内不会重复；
3. 发送方使用它们共享的密钥，对这个随机数加密后发回接收方；
4. 接收方接收后，使用密钥解密，如果确实是自己之前发送出去的随机数，即可确认对方身份；

### 解决数据完整性的其他方案

假设发送方和接收方有一个共享的密钥，则可以使用如下步骤保证数据完整性：

1. 发送方将原始数据与密钥拼接，然后计算拼接后的`hash`值，将这个`hash`值与原始数据一同发送；
2. 接收方接收到后，同样将原始数据和密钥拼接，并计算`hash`值，然后与发来的`hash`值比较；
3. 若`hash`值一致，可以保证这个数据没有修改，否则就是被篡改的数据；

## 路由找最短路径

因特网是全球性的网络，因特网内部又划分为多个子网，专业名称为**自治系统**（简称AS），自治系统内部有很多路由器，自治系统之间也有很多路由器。

路由器的主要工作是**为经过路由器的数据包找到一条最佳传输路径**，并将该数据有效地传送到目的站点。

路由器之间需要交换路由信息，如果每个路由器都按之间的想法去做事情，就会乱套了，所以每个路由器都得遵循协议，分别是**内部网关协议**(IGP)和**边界网关协议**（BGP）（以前用的外部网关协议（EGP）现已过时，现在用的是边界网关协议），统称为路由选择协议。

路由选择协议的作用到底是**交换路由信息**与**寻找最短路径**。

内部网关协议包括基于距离向量的路由选择协议（RIP）、链路状态路由协议（OSPF）。

**RIP的原理是怎样的？**

1. 仅和相邻路由交换信息
2. 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到那个网络应经过的下一跳路由器。”
3. 按固定时间间隔交换路由信息，例如，每隔30秒。然后路由器根据收到的路由信息更新路由表。

RIP使用何种算法寻找最短路径？

距离向量算法

什么情况下选择是用RIP协议？

算法简单，适用于相对较小的自治系统。

**OSPF原理是什么？**

1. 向本自治系统中所有路由器发送信息。
2. 发送的信息就是与本路由器相邻的所有路由器的链路状态（所谓链路就是从一个节点到相邻节点的一段物理线路），但这只是路由器所知道的部分信息。
3. 只有在链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。

OSPF协议使用何种算法寻找最短路径？

链路状态路由算法Dijkstra

什么情况下选择是用OSPF协议？

OSPF协议适用于大网络。

**外部网关协议就只有BGP协议**

## 微信抢红包算法

注意：

1. 所有人抢到金额之和等于红包金额，不能超过，也不能少于

2. 每个人至少抢到一分钱

3. 要保证所有人抢到金额的几率相等

若最开始就随机(0, 剩余金额)，越后越少

例子：(0, 100)，平均50 --> (0, 50)，平均25 --> (0, 25)，平均12.5

### 方法1：二倍均值法

剩余红包金额为M，剩余人数为N，那么有如下公式：

每次抢到的金额 = 随机区间 **（0， M / N * 2）**

这个公式，保证了**每次随机金额的平均值是相等的**，不会因为抢红包的先后顺序而造成不公平。

10个人，红包总额100元

100 / 10 * 2，第一个人随机(0, 20)，平均10元； 

90 / 9 * 2，第二个人随机(0, 20)，平均10元； 

80 / 8 * 2，第三个人随机(0, 20)，平均10元； 

...

缺点：除了最后一次，任何一次抢到的金额都小于人均金额的两倍，不是任意的随机

### 方法2：线段切割法

N个人抢总金额为M的红包，需要做N-1次随机运算，确定N-1个切割点，先分红包，后抢，抢之前定好结果

我发现的：群里人数 * 0.01 + 0.01，最后一个领红包的总是0.02

## 线程不安全

线程不安全（Thread Safe）就是在多线程环境中，多个线程在同一时刻对同一份资源（e.g. 寄存器、内存空间、全局变量、静态变量 etc.）进行写操作（读操作不会涉及线程安全的问题）时，会出现数据不一致。

>例1：线程A，线程B同时拿到全局变量i（值为0）并存储在自己的本地栈中，线程A对i加1，线程B也对i加1，那么线程A，线程B提交后，i的结果为1，而不是我们期望的结果2。
>例2：线程A，线程B同时拿到全局变量i（值为0）并存储在自己的本地栈中，线程A对i加1，线程B随后读取i，那么线程B读取的结果依然为0，而不是我们期望的结果1。这就是多线程并发导致的可见性问题。

### 线程安全的方式

1. 使用互斥锁
2. 多个线程操作同一个变量且互不干扰的场景下，可以对在每个线程中对该变量创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。
3. 使用乐观锁

## 数据库容灾

1. 数据库冷备：每天备份一次数据库，保存在磁带或光盘上

2. 双机本地热备：共享磁盘阵列，阵列做RAID（冗余校验），即一份数据存在不同盘阵上并多存几份，保证坏一个盘不影响数据读写；

3. 数据库热备：建立数据库灾备中心，与主库实时进行数据同步，同时应用系统保持文件实时同步，保证引用系统版本最新

## 微信支付输入密码

1. https协议，提供内容加密、身份认证、数据完整性校验，以解决数据传输的安全性问题。

https不安全场景：

https 完全就是建立在证书可信的基础上的，但是如果遇到中间人伪造证书，一旦客户端通过验证，安全性顿时就没了哦！平时各种钓鱼不可描述的网站，很可能就是黑客在诱导用户安装它们的伪造证书！通过伪造证书，https也是可能被抓包的。

2. 非对称加密算法

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/640d62cd472544f7835ccdd5707e8fe2~tplv-k3u1fbpfcp-watermark.awebp)

非对称加密算法不安全场景：

如果使用非对称加密算法，也需要考虑「密钥公钥如何给到对方」，如果公钥还是网络传输给对方，传输过程，被中间人拿到的话，会有什么问题呢？「他们是不是可以伪造公钥，把伪造的公钥给客户端，然后，用自己的私钥等公钥加密的数据过来？」大家可以思考下这个问题哈~

传输密码可以使用**https + 非对称加密算法**



