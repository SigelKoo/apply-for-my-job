[TOC]

# 数组中的第K个最大元素

```go
package main

import "container/heap"

func findKthLargest(nums []int, k int) int {
	h := &MyHeap{}
	heap.Init(h)
	for i := range nums {
		heap.Push(h, nums[i])
		if h.Len() > k {
			heap.Pop(h)
		}
	}
	return heap.Pop(h).(int)
}

type MyHeap []int

func (h *MyHeap) Len() int {
	return len(*h)
}

func (h *MyHeap) Less(i, j int) bool {
	return (*h)[i] < (*h)[j]
}

func (h *MyHeap) Swap(i, j int) {
	(*h)[i], (*h)[j] = (*h)[j], (*h)[i]
}

func (h *MyHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *MyHeap) Pop() interface{} {
	old := *h
	l := old.Len()
	x := old[l - 1]
	*h = old[0 : l - 1]
	return x
}
```

# 连续子数组的最大和

```go
func maxSubArray(nums []int) int {
	length := len(nums)
	dp := make([]int, length)
	dp[0] = nums[0]
	for i := 1; i < length; i++ {
		if dp[i - 1] > 0 {
			dp[i] = dp[i - 1] + nums[i]
		} else {
			dp[i] = nums[i]
		}
	}
	return max53(dp)
}

func max53(dp []int) int {
	max := dp[0]
	for i := 0; i < len(dp); i++ {
		if max < dp[i] {
			max = dp[i]
		}
	}
	return max
}
```

# 单例模式

先说一下什么是懒汉模式吧，从懒汉这两个字，我们就能知道，这个人很懒，所以他不可能在未使用实例时就创建了对象，他肯定会在使用时才会创建实例，这个好处的就在于，只有在使用的时候才会创建该实例。

**懒汉不加锁**

```go
type singleton struct {

}

var instance *singleton

func GetInstance() *singleton {
	if instance == nil {
		instance = new(singleton)
	}
	return instance
}
```

这种方法是会存在线程安全问题的，在高并发的时候会有多个线程同时掉这个方法，那么都会检测instance为nil，这样就会导致创建多个对象，所以这种方法是不推荐的，我再来看第二种写法。

**懒汉加锁**

```go
package main

import "sync"

type singleton struct {

}

var instance *singleton
var mu sync.Mutex

func GetInstance() *singleton {
	mu.Lock()
	defer mu.Unlock()
	if instance == nil {
		instance = new(singleton)
	}
	return instance
}
```

这里对整个方法进行了加锁，这种可以解决并发安全的问题，但是效率就会降下来，每一个对象创建时都是进行加锁解锁，这样就拖慢了速度，所以不推荐这种写法。

**懒汉加检查锁**

```go
package main

import "sync"

type singleton struct {

}

var instance *singleton
var mu sync.Mutex

func GetInstance() *singleton {
	mu.Lock()
	defer mu.Unlock()
	if instance == nil {
		instance = new(singleton)
	}
	return instance
}
```

因为编译器优化没有检查实例存储状态。如果使用sync/atomic包的话 就可以自动帮我们加载和设置标记。

**懒汉使用Once**

```go
package main

import "sync"

type singleton struct {

}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
	once.Do(func() {
		instance = &singleton{}
	})
	return instance
}
```

**饿汉**

```go
type singleton struct {

}

var instance = new(singleton)

func GetInstance() *singleton {
	return instance
}
```

```go
type singleton struct {

}

var instance *singleton

func init() {
	instance = new(singleton)
}

func GetInstance() *singleton {
	return instance
}
```

# 平衡二叉树

```go
func isBalanced(root *TreeNode) bool {
	if root == nil {
		return true
	}
	if !isBalanced(root.Left) || !isBalanced(root.Right) {
		return false
	}
	left := maxdepth(root.Left) + 1
	right := maxdepth(root.Right) + 1
	if abs(left - right) > 1 {
		return false
	}
	return true
}

func maxdepth(root *TreeNode) int {
	if root == nil {
		return 0
	}
	return max(maxdepth(root.Left), maxdepth(root.Right)) + 1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```

# 下一个排列

```go
func nextPermutation(nums []int) {
	if len(nums) <= 1 {
		return
	}
	i, j, k := len(nums) - 2, len(nums) - 1, len(nums) - 1
	
	for i >= 0 && nums[i] >= nums[j] {
		i--
		j--
	}

	if i >= 0 {
		for nums[i] >= nums[k] {
			k--
		}
		nums[i], nums[k] = nums[k], nums[i]
	}

	for i, j := j, len(nums) - 1; i < j; i, j = i + 1, j - 1 {
		nums[i], nums[j] = nums[j], nums[i]
	}
}
```

# 二叉树的前序遍历

```go
func preorderTraversal(root *TreeNode) []int {
    res := []int {}
	preorder(root, &res)
	return res
}

func preorder(root *TreeNode, res *[]int)  {
	if root == nil {
		return
	}
	*res = append(*res, root.Val)
	preorder(root.Left, res)
	preorder(root.Right, res)
}
```

```go
func preorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New()
    stack.PushBack(root.Right)
    stack.PushBack(root.Left)
    res:=[]int{}
    res=append(res,root.Val)
    for stack.Len()>0 {
        e:=stack.Back()
        stack.Remove(e)
        node := e.Value.(*TreeNode)//e是Element类型，其值为e.Value.由于Value为接口，所以要断言
        if node==nil{
            continue
        }
        res=append(res,node.Val)
        stack.PushBack(node.Right)
        stack.PushBack(node.Left)
    }
    return res
}
```

# 二叉树的中序遍历

```go
func inorderTraversal(root *TreeNode) []int {
    res := make([]int, 0)
    inorder(root, &res)
    return res
}

func inorder(root *TreeNode, res *[]int) {
    if root == nil {
        return
    }
    inorder(root.Left, res)
    *res = append(*res, root.Val)
    inorder(root.Right, res)
}
```

```go
//迭代法中序遍历
func inorderTraversal(root *TreeNode) []int {
    rootRes:=[]int{}
    if root==nil{
       return nil
    }
    stack:=list.New()
    node:=root
    //先将所有左节点找到，加入栈中
    for node!=nil{
        stack.PushBack(node)
        node=node.Left
    }
    //其次对栈中的每个节点先弹出加入到结果集中，再找到该节点的右节点的所有左节点加入栈中
    for stack.Len()>0{
        e:=stack.Back()
        node:=e.Value.(*TreeNode)
        stack.Remove(e)
        //找到该节点的右节点，再搜索他的所有左节点加入栈中
        rootRes=append(rootRes,node.Val)
        node=node.Right
        for node!=nil{
            stack.PushBack(node)
            node=node.Left
        }
    }
    return rootRes
}
```

# 整数替换

```go
func integerReplacement(n int) int {
	dp := make(map[int]int)
	return dfs(n, &dp)
}

func dfs(n int, dp *map[int]int) int {
	if value, ok := (*dp)[n]; ok {
		return value
	}
	if n == 1 {
		(*dp)[1] = 0
		return 0
	}
	if n % 2 == 0 {
		(*dp)[n] = dfs(n / 2, dp) + 1
	} else {
		(*dp)[n] = min(dfs(n - 1, dp), dfs(n + 1, dp)) + 1
	}
	return (*dp)[n]
}

func min(num1, num2 int) int {
	if num1 < num2 {
		return num1
	}
	return num2
}
```

# 杨辉三角

```go
func generate(numRows int) [][]int {
	res := [][]int{}
	for i := 0; i < numRows; i++ {
		tmp := []int{1}
		for j := 0; j < i; j++ {
			if j == i - 1 {
				tmp = append(tmp, res[i - 1][j])
			} else {
				tmp = append(tmp, res[i - 1][j] + res[i - 1][j + 1])
			}
			fmt.Println(tmp)
		}
		res = append(res, tmp)
	}
	return res
}
```

# LFU缓存

https://leetcode-cn.com/problems/lfu-cache/solution/460-lfu-huan-cun-by-ou-yang-jun-e76p/

# 数组中重复的数字

```go
func findRepeatNumber(nums []int) int {
    hashtable := make(map[int]bool)
    for i := 0; i < len(nums); i++ {
        if hashtable[nums[i]] {
            return nums[i]
        }
        hashtable[nums[i]] = true
    }
    return -1
}
```

# 字符串排序

1. 长度不同时，长度较短在排前面。
2. 长度相同时，按照字典顺序排列（AaBb-Zz，0-9顺序），即大写字母在小写字母前，数字排在字母后。

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	str := []string{"abc", "Abc", "123", "1", "1cb", "CBD", "abcd", "a"}
	for i := 0; i < len(str); i++ {
		for j := i + 1; j < len(str); j++ {
			if longs(str[i], str[j]) {
				str[i], str[j] = str[j], str[i]
			} else {
				continue
			}
		}
	}
	fmt.Println(str)
}

func longs(s1, s2 string) bool {
	if len(s1) < len(s2) {
		return false
	} else if len(s1) > len(s2) {
		return true
	} else {
		if compare(s1, s2) {
			return true
		}
	}
	return false
}

func compare(s1, s2 string) bool {
	if strings.Compare(s1, s2) == 0 {
		return false
	}
	b1 := []byte(s1)
	b2 := []byte(s2)
	for i := 0; i < len(b1); i++ {
		if (b1[i] >= 'A' && b1[i] <= 'Z') && (b2[i] >= 'a' && b2[i] <= 'z') {
			if b1[i] >= b2[i] - 32 {
				return true
			} else {
				return false
			}
		}
		if (b1[i] >= 'a' && b1[i] <= 'z') && (b2[i] >= 'A' && b2[i] <= 'Z') {
			if b1[i] - 32 >= b2[i] {
				return true
			} else {
				return false
			}
		}
		if (b1[i] >= 'A' && b1[i] <= 'Z') && (b2[i] >= 'A' && b2[i] <= 'Z') {
			if b1[i] > b2[i] {
				return true
			} else if b1[i] == b2[i] {
				continue
			} else {
				return false
			}
		}
		if (b1[i] >= 'a' && b1[i] <= 'z') && (b2[i] >= 'a' && b2[i] <= 'z') {
			if b1[i] > b2[i] {
				return true
			} else if b1[i] == b2[i] {
				continue
			} else {
				return false
			}
		}
		if b1[i] < b2[i] {
			return true
		} else if b1[i] == b2[i] {
			continue
		} else {
			return false
		}
	}
	return false
}
```

# 给表达式添加运算符

```go
var n, t int
var ans []string
var s string

func addOperators(num string, target int) []string {
	n = len(num)
	t = target
	ans = make([]string, 0)
	s = num
	dfs(0, 0, 0, "")
	return ans
}

func dfs(index, prev, value int, str string) {
	if index == n {
		if value == t {
			ans = append(ans, str)
		}
		return
	}
	for i := index; i < n; i++ {
		if index != i && s[index] == '0' {
			break
		}
		next, _ := strconv.Atoi(s[index : i+1])
		nextStr := s[index : i+1]
		if index == 0 {
			dfs(i+1, next, next, ""+nextStr)
		} else {
			dfs(i+1, next, value+next, str+"+"+nextStr)
			dfs(i+1, -next, value-next, str+"-"+nextStr)
			x := prev * next
			dfs(i+1, x, value-prev+x, str+"*"+nextStr)
		}
	}
}
```

# 删除链表的倒数第N个结点

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{-1, head}
    slow, fast := dummy, dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast.Next != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

# 字符串转换整数

```go
func myAtoi(s string) int {
    i := 0
    for ;i < len(s); i ++ {
        if s[i] != ' ' {
            break
        }
    }
    s = s[i:len(s)]
	ans := 0
	sign := 1
	for i, v := range s {
		if v >= '0' && v <= '9' {
			ans = ans*10 + int(v-'0')
		} else if v == '-' && i == 0 {
			sign = -1
		} else if v == '+' && i == 0 {
			sign = 1
		} else {
			break
		}
        if sign == 1 && ans > math.MaxInt32 {
            return math.MaxInt32
        }
        if sign == -1 && -ans < math.MinInt32 {
            return math.MinInt32
        }
	}
    return sign * ans
}
```

# 快速排序

```go
func quicksort(arr []int, start, end int) {
	if start < end {
		i, j := start, end
		key := arr[(start + end) / 2]
		for i < j {
			for arr[i] < key { // 一直找到大于key的
				i++
			}
			for arr[j] > key { // 一直找到小于key的
				j--;
			}
			if i <= j { // 交换arr[i]和arr[j]顺序
				arr[i], arr[j] = arr[j], arr[i]
				i++
				j--
			}
			if start < j {
				quicksort(arr, start, j)
			}
			if end > i {
				quicksort(arr, i, end)
			}
		}
	}
}
```

```go
type stack struct {
	s []*element
}

type element struct {
	l int
	r int
}

func (s *stack) push(l, r int) {
	e := element{l, r}
	s.s = append(s.s, &e)
}

func (s *stack) pop() *element {
	if len(s.s) == 0 {
		return nil
	}
	temp := s.s[0]
	s.s = s.s[1:]
	return temp
}

func quickSort(arr []int) {
	length := len(arr)
	var stack stack
	stack.push(0, length - 1)
	for {
		s := stack.pop()
		if s == nil {
			break
		}
		if s.l <= s.r {
			i := s.l
			j := s.r
			key := arr[(s.l + s.r) / 2]
			for i <= j {
				for arr[i] < key {
					i++
				}
				for arr[j] > key {
					j--
				}
				if i <= j {
					arr[i], arr[j] = arr[j], arr[i]
					i++
					j--
				}
			}
			if s.l < j {
				stack.push(s.l, j)
			}
			if s.r > i {
				stack.push(i, s.r)
			}
		}
	}
}
```

# TopN

```go
func findKthLargest(nums []int, k int) int {
	h := &MyHeap{}
	heap.Init(h)
	for i := range nums {
		heap.Push(h, nums[i])
		if h.Len() > k {
			heap.Pop(h)
		}
	}
	return heap.Pop(h).(int)
}

type MyHeap []int

func (h MyHeap) Len() int {
	return len(h)
}

func (h MyHeap) Less(i, j int) bool {
	return h[i] < h[j]
}

func (h MyHeap) Swap(i, j int)  {
	h[i], h[j] = h[j], h[i]
}

func (h *MyHeap) Push(x interface{})  {
	*h = append(*h, x.(int))
}

func (h *MyHeap) Pop() interface{} {
	old := *h
	l := len(old)
	x := old[l - 1]
	*h = old[0 : l - 1]
	return x
}
```

# 走方格的方案数

- 假设左上角的坐标位置为(n,m),右下角的坐标位置为(0,m)
- 向下走为way(n-1,m),向右边走为(n,m-1)
- 一旦m,n为0说明到了下边界和到右边界，此时只有往右走和往下走一条路

```go
package main
 
import(
    "fmt"
)
 
func main(){
    for{
        var n,m int
        c,_ := fmt.Scan(&n,&m)
        if c == 0{
            return
        }
        fmt.Println(way(n,m))
    }
}
 
func way(n,m int)int{
    // 到下边界和到右边界只有往右走和往下走一条路
    if n == 0 || m == 0{
        return 1
    }
    // 往右走 + 往下走
    return way(n-1,m) + way(n,m-1)
}
```

# 数组分组

这题不是那么容易。最开始理解错题意了，以为不符合条件的元素不要了，直接比较3的倍数的一组和5的倍数一组的和是否相等。后面看讨论区发现不符合条件的元素也要用起来，分配到3和5两组中，使最终和相等。  

那么这一题其实还是需要动态规划或者递归的。可以先分析一下，将a作为3的倍数的一组，b作为5的倍数的一组，c作为剩余元素一组。因为sum(a)和sum(b)有差，所以问题成为，如何将一个数组分成两部分，使得两部分的差为一定值。  

设sa = sum(a);  

sb = sum(b);  

sc = sum(c);  

则将数组c分成两部分，c1和c2使得（两部分和分别为sc1，sc2）：sa+sc1 = sb +sc2  

所以sc1 - sc2 = sb - sa = cha（一个定值）  

因为c1与c2所有元素和是sc：sc1 + sc2 = x + (x + cha) = sc ；即x = (sc - cha)/2。其实这里做的时候需要注意，sc-cha必须为偶数，如果不是偶数说明拆分不了两部分，直接本题答案就是false，各位可以仔细想想是不是这么回事。  

最终问题是：从数组c中选若干元素，使得和为x，能找到返回true，否则false。  

我用的是递归算法，遍历数组c每个元素，因为每个元素都有加与不加两种选择（也可以用动态规划，背包问题思想）

```go
import (
    "bufio"
    "fmt"
    "math"
    "os"
    "strconv"
    "strings"
)

func main() {
    scan := bufio.NewScanner(os.Stdin)
    for {
        scan.Scan()
        if scan.Text() == "" {
            break
        }

        scan.Scan()
        b := strings.Split(strings.Trim(scan.Text(), " "), " ")
        t := make([]int, 0)
        f := make([]int, 0)
        on := make([]int, 0)
        for _, v := range b {
            n, _ := strconv.Atoi(v)
            if n%3 == 0 {
                t = append(t, n)
            } else if n%5 == 0 {
                f = append(f, n)
            } else {
                on = append(on, n)
            }

        }
        aim := sum(on) - math.Abs(sum(f) - sum(t))
        aimi := int(aim)
        if aimi %2 != 0 {
            fmt.Println("false")
        } else  {
            if dp(on, 0, 0, aimi / 2){
                fmt.Println("true")
            } else {
                fmt.Println("false")

            }
        }

    }

}

func sum(a []int) float64 {
    s := 0
    for _, v := range a {
        s += v
    }
    return float64(s)
}

func dp(c []int, i, s , aim int) bool {
    if s== aim {
        return true
    }
    if i == len(c) {
        return s == aim
    }
    return dp(c, i + 1, s, aim) ||dp(c, i + 1, s + c[i], aim)
}

```

# LRU 缓存机制

```go
type entry struct {
    key, value int
}

type LRUCache struct {
    cap int
    cache map[int]*list.Element
    lst *list.List
}

func Constructor(capacity int) LRUCache {
    return LRUCache{capacity, map[int]*list.Element{}, list.New()}
}

func (this *LRUCache) Get(key int) int {
    element := this.cache[key]
    if element == nil {
        return -1
    }
    this.lst.MoveToFront(element)
    return element.Value.(entry).value
}

func (this *LRUCache) Put(key int, value int)  {
    if element := this.cache[key]; element != nil {
        element.Value = entry{key, value}
        this.lst.MoveToFront(element)
        return
    }
    this.cache[key] = this.lst.PushFront(entry{key, value})
    if len(this.cache) > this.cap {
        delete(this.cache, this.lst.Remove(this.lst.Back()).(entry).key)
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

