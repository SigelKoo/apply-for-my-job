# JSON & Protocol Buffers

Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。

## 优点

Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。

它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。

Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。

使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。

## 缺点

由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。

# Redis & Memcached

## 数据操作不同

与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能。Redis支持服务器端的数据操作相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，支持list、set、sorted set、hash等众多数据结构，还同时提供了持久化和复制等功能。而通常在Memcached里，使用者需要将数据拿到客户端来进行类似的修改再set回去，这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作， Redis会是更好的选择。

## 内存管理机制不同

在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。

而Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。

从内存利用率来讲，使用简单的key-value存储的话，Memcached的内存利用率更高。而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。

## 性能不同

由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。

## 集群管理不同

Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。

Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。

# COW

前面介绍了 `虚拟内存` 与 `物理内存` 的概念，接下来将会介绍 Linux `写时复制` 的原理。

前面说过，`虚拟内存` 需要与 `物理内存` 进行映射才能使用，如果不同进程的 `虚拟内存地址` 映射到相同的 `物理内存地址`，那么就实现了共享内存的机制。如下图所示：

![img](https://segmentfault.com/img/bVcRr09)

由于进程A的 `虚拟内存M` 与进程B的 `虚拟内存M'` 映射到相同的 `物理内存G`，所以当修改进程A `虚拟内存M` 的数据时，进程B `虚拟内存M'` 的数据也会跟着改变。

Linux 为了加速创建子进程过程与节省内存使用的原因，实现了 `写时复制` 的机制。

`写时复制` 的原理大概如下：

- 创建子进程时，将父进程的 `虚拟内存` 与 `物理内存` 映射关系复制到子进程中，并将内存设置为只读（设置为只读是为了当对内存进行写操作时触发 `缺页异常`）。
- 当子进程或者父进程对内存数据进行修改时，便会触发 `写时复制` 机制：将原来的内存页复制一份新的，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写。

![img](https://segmentfault.com/img/bVcRr1a)

当创建子进程时，父子进程指向相同的 `物理内存`，而不是将父进程所占用的 `物理内存` 复制一份。这样做的好处有两个：

- 加速创建子进程的速度。
- 减少进程对物理内存的使用。

如上图所示，当父进程调用 `fork` 创建子进程时，父进程的 `虚拟内存页M` 与子进程的 `虚拟内存页M` 映射到相同的 `物理内存页G`，并且把父进程与子进程的 `虚拟内存页M` 都设置为只读（因为设置为只读后，对内存页进行写操作时，将会发生 `缺页异常`，从而内核可以在缺页异常处理函数中进行物理内存页的复制）。

当子进程对 `虚拟内存页M` 进行写操作，便会触发 `缺页异常`（因为已经将 `虚拟内存页M` 设置为只读）。在缺页异常处理函数中，对 `物理内存页G` 进行复制一份新的 `物理内存页G'`，并且将子进程的 `虚拟内存页M` 映射到 `物理内存页G'`，同时将父子进程的 `虚拟内存页M` 设置为可读写。

# netstat

列出所有端口情况

```
[root@xiesshavip002 ~]# netstat -a      # 列出所有端口
[root@xiesshavip002 ~]# netstat -at     # 列出所有TCP端口
[root@xiesshavip002 ~]# netstat -au     # 列出所有UDP端口
```

列出所有处于监听状态的 Sockets

```
[root@xiesshavip002 ~]# netstat -l   # 只显示监听端口
[root@xiesshavip002 ~]# netstat -lt  # 显示监听TCP端口
[root@xiesshavip002 ~]# netstat -lu  # 显示监听UDP端口
[root@xiesshavip002 ~]# netstat -lx  # 显示监听UNIX端口
```

显示每个协议的统计信息

```
[root@xiesshavip002 ~]# netstat -s     # 显示所有端口的统计信息
[root@xiesshavip002 ~]# netstat -st    # 显示所有TCP的统计信息
[root@xiesshavip002 ~]# netstat -su    # 显示所有UDP的统计信息
```

显示 PID 和进程名称

```
[root@xiesshavip002 ~]# netstat -p
```

显示核心路由信息

```
[root@xiesshavip002 ~]# netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         gateway         0.0.0.0         UG        0 0          0 eth0
192.168.130.0   0.0.0.0         255.255.255.0   U         0 0          0 eth0
[root@xiesshavip002 ~]# netstat -rn   # 显示数字格式，不查询主机名称
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         192.168.130.1   0.0.0.0         UG        0 0          0 eth0
192.168.130.0   0.0.0.0         255.255.255.0   U         0 0          0 eth0
[root@xiesshavip002 ~]#
```

查看端口和服务

```
[root@xiesshavip002 ~]# netstat -antp | grep ssh
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      734/sshd            
tcp        0     52 192.168.130.20:22       119.129.118.189:58737   ESTABLISHED 1846/sshd: root@pts 
tcp6       0      0 :::22                   :::*                    LISTEN      734/sshd            
[root@xiesshavip002 ~]# netstat -antp | grep 22
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      734/sshd            
tcp        0     52 192.168.130.20:22       119.129.118.189:58737   ESTABLISHED 1846/sshd: root@pts 
tcp6       0      0 :::22                   :::*                    LISTEN      734/sshd            
[root@xiesshavip002 ~]#
```

# 操作系统将连接都存在哪里？

```
/proc/net

/proc/net/stat/
/proc/net/tcp
/proc/net/udp
```

# 查看线程命令

```
ps -T -p <pid>
ps -mp <pid> -o THREAD, tid, time
```

# 内存快还是磁盘快

CPU从内存或缓存中取出指令，放入指令寄存器，并对指令译码进行分解，进而对数据进行处理。这么说吧，计算机中所有的程序运行都是在内存中进行的，因此内存对计算机性能的影响非常大。数据由传输速度较慢的硬盘通过内存传送到CPU进行处理。不过内存是带电存储的(断电数据就会消失)，而且容量十分有限，所以要长时间储存程序或数据就需要使用硬盘。

