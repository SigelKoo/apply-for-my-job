#### 1

暴力法，将所有小朋友和想跟谁一组放入一个小朋友组队map，新建一个结果map数组，循环判断小朋友组队map的key和value是否已经出现在了结果map中，若出现，就将key和value放入结果map数组中某个map中，并继续判断，直到没有人继续能加入到这组。

#### 2

```go
package main

import (
	"bufio"
	"fmt"
	"github.com/liyue201/gostl/ds/queue"
	"github.com/liyue201/gostl/ds/set"
	"os"
	"strconv"
	"strings"
)

func main() {
	// 任务执行时长的数组
	task := make([]int, 0)
	// 队列存储任务执行顺序 0~N
	q := queue.New()
	input := bufio.NewScanner(os.Stdin)
	input.Scan()
	ss1 := strings.Split(input.Text(), ",")
	// 将输入按逗号分隔后一个个放入队列
	for i := 0; i < len(ss1); i++ {
		num, _ := strconv.Atoi(ss1[i])
		task = append(task, num)
		q.Push(i)
	}
	size := len(task)
	relate := make([][]int, size)
	for i := range relate {
		relate[i] = make([]int, 0)
	}
	input.Scan()
	ss2 := strings.Split(input.Text(), ",")
	// 通过逗号分隔每一组依赖，通过箭头确定谁依赖谁，通过二维数组存储依赖关系
	for i := 0; i < len(ss2); i++ {
		ss := strings.Split(ss2[i], "->")
		num1, _ := strconv.Atoi(ss[0])
		num2, _ := strconv.Atoi(ss[1])
		relate[num1] = append(relate[num1], num2)
	}
	// 通过set结构存储已执行的结构
	used := set.New()
	// 结果数组
	ans := make([]int, size)
	// 开始计时
	time := 0
	// 队列不为空的情况下
	for !q.Empty() {
		// 队列头部取出一个任务
		cur := q.Front().(int)
		q.Pop()
		// 如果依赖的二维数组中没有该任务
		if len(relate[cur]) == 0 {
			// 在已执行的set中存储该任务
			used.Insert(cur)
			// 给当前时间加上任务执行时长
			time += task[cur]
			// 将执行后的时间作为结果存储
			ans[cur] = time
		} else {
			// 找到依赖几个任务
			n := len(relate[cur])
			flag := true
			for i := 0; i < n; i++ {
				// 循环判断已执行set中是否存在该依赖，不存在的话，就break
				if !used.Contains(relate[cur][i]) {
					flag = false
					break
				}
			}
			if flag {
				// 如果存在的话，在已执行set中加入该任务
				used.Insert(cur)
				// 给当前时间加上任务执行时长
				time += task[cur]
				// 将执行后的时间作为结果存储
				ans[cur] = time
			} else {
				// 将任务重新放入队列
				q.Push(cur)
			}
		}
	}
	for i := 0; i < size; i++ {
		fmt.Print(ans[i])
		if i != size - 1 {
			fmt.Print(",")
		}
	}
}
```

#### PBFT

有3f + 1的容错性

主节点正常工作时，接收客户端的事务请求，验证request身份后，为该请求设置编号，广播pre-prepare消息

主节点作用，如果宕机、或者不发生消息、或者发送错误编号的消息、或者篡改消息，都会被其它节点感知，并触发view-change

Request

客户端C向主节点发送<消息内容m与消息摘要d, 请求具体操作, 时间戳, 客户端标识>（<REQUEST, o, t, c>）

Pre-Prepare

主节点检验并广播<<PRE-PREPARE, 视图编号, 预准备消息编号, 消息摘要>, 消息内容>（<<PRE-PREPARE, v, n, d>, m>）

Prepare

普通节点校验并向所有节点发送<PREPARE, 视图编号, 预准备消息编号, 消息摘要, 普通节点编号>（<PREPARE, v, n, d, i>）

Commit

节点i收到2f+1个Prepare消息，向所有节点发送<COMMIT, 视图编号, 预准备消息编号, 消息摘要, 普通节点编号>（<COMMIT, v, n, d, i>）

Reply

客户端收到f+1个相同的Reply消息<REPLY, 视图编号, 时间戳, 客户端标识, 普通节点编号, 操作结果>（<REPLY, v, t, c, i, r>）

#### 零知识证明

证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。例子：如何证明我是持有私钥的。让验证者使用我的公钥加密任意一段信息，将密文发给我；我将信息解密后再发给你；可以证明我是持有私钥的。区块链上可以用于隐藏转账信息。

#### 以太坊交易上链流程

假设你在自己的计算机上本地运行了一个以太坊客户端（Geth 或 Parity），你的计算机连接到了某个以太坊网络（测试网络或是主网），你有权访问该合约地址和 ABI，从而执行该交易。

如果你构建过分布式应用，应该对上述代码并不陌生。这是一个名为“Voting（投票）”的合约，已经部署在了区块链上。我们以该合约为例，执行一个叫作 voteForCandidate 的函数，输入候选人的姓名、该交易的gas上限和执行该交易的账户。从名称中可以看出，该函数能够用来为候选人投票，选票记录在区块链上。在下文，我们将尝试解构该调用，了解你在执行该 javascript 函数时会发生的一切。

##### 构建原始交易对象

voteForCandidate 函数调用首先被转化成了原始交易（rawTxn）。Web3js库被用来构建原始交易对象。

```javascript
txnCount = web3.eth.getTransactionCount(web3.eth.accounts[0])
var rawTxn = {
    nonce: web3.toHex(txnCount),
    gasPrice: web3.toHex(100000000000),
    gasLimit: web3.toHex(140000),
    to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b',
    value: web3.toHex(0),
    data: '0xc7ed014952616d6100000000000000000000000000000000000000000000000000000000'
};
```

**nonce（随机数）：**每个以太坊账户都有一个叫做 nonce 的字段，来记录该账户已执行的交易总数。Nonce 的值随着每个新交易的执行不断增加，这能让网络了解执行交易需要遵循的顺序。Nonce 也被用来进行重放保护。

**gasPrice（gas价格）：**即你愿为该交易支付的每单位 gas 的价格**。**如果你正在主网上执行交易，[ETH Gas Station](https://medium.com/@ethgasstation)上正好有一个网站，你可以参照其建议为你的交易设定 gas 价格，以便交易在一定时间内成功执行。Gas 价格目前以 GWei 为单位，其范围是0.1->100+Gwei。下文会进一步介绍 gas 价格及其影响。

**gasLimit（gas上限）：**即你愿为该交易支付的最高 gas 总额。该上限能确保在出现交易执行问题（比如陷入无限循环）之时，你的账户不会耗尽所有资金。一旦交易执行完毕，剩余所有 gas 会返还至你的账户。

**to**：即该函数调用被送往的地址。0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b 是我们的案例中投票合约的地址。

**Value（值）：**即你打算发送的以太币总量。当我们执行voteForCandidate函数时，我们根本没有发送以太币，因此 value 为零。如果你要执行一个交易，向另一个人或合约发送以太币，你会需要设置 value 值。

**data（数据）：**让我们来看看data字段是如何计算出来的。

你先从 `voteForCandidate(bytes32 candidate)`（32字节的候选人）的 [ABI](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI) 中获取函数签名，并得出它的哈希值。

```
> web3.sha3('voteForCandidate(bytes32 candidate)')
'0xc7ed014922ff9493a686391b70ca0e8bb7e80f91c98a5cd3d285778ab2e245b3'
```

取该哈希值的前4个字节，即：0xcc9ab267。

然后将参数‘Nick’转化为32字节，得到52616d6100000000000000000000000000000000000000000000000000000000

将二者结合，得到数据有效载荷。

##### 签署交易

如果你记得的话，你使用了web3.eth.accounts[0]来执行该交易。以太坊网络需要知道你确实是该账户的所有者，从而确保其他人不能以你的名义执行该交易。要向网络证明这点的方法是使用该账户的相应私钥签署交易。签署过后的交易如下图所示：

```javascript
const privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')

const txn = new EthereumTx(rawTxn)
txn.sign(privateKey)
const serializedTxn = txn.serialize()
```

##### 交易经由本地验证

签署过后的交易会提交至你的本地以太坊节点。然后你的本地节点会验证已签名的交易，确保它真的是由这个账户地址签署过的。

##### 交易被广播至网络

已签署交易经由你的geth/parity节点广播至其对等节点，这些对等节点再将该交易广播给它们的对等节点，以此类推。一旦交易被广播至网络，你的本地节点也会输出该交易的id，你可以用它来追踪你的交易的状态。该交易id就是已签署交易对象的哈希值。

```javascript
transactionId = sha3(serializedTxn)
```

如果你是在公共的以太坊网络上执行该交易的话，追踪你的交易状态的最佳方式是通过[etherscan.io](https://etherscan.io/)。如上图所示，你是否注意到了有几个节点被标记为 Etherscan 节点。Etherscan 的团队运行了几个节点，并将一个很棒的前端网络应用连接到了 Etherscan上。如果你的交易被他们的节点选中，你可以在他们的网站上查看自己的待定交易。

还要记住的一点是，并非所有节点都会接受你的交易。其中一些节点可能被设置成了只接受 gas 价格超过某一最低值的交易。如果你设置的 gas 价格低于该下限，则节点会忽略你的交易。

##### 矿工节点接受交易

正如图中所示，以太坊网络同时拥有矿工节点和非矿工节点。可能你也知道，矿工的职责是将你的交易包含到区块上。矿工是交易池的维护者，你的交易先是被添加进交易池，再由矿工进行开始评估。

![4](http://upyun-assets.ethfans.org/uploads/photo/image/00f50cee741543268b8fe370aa803a00.png)

从上图中你会注意到矿工将所有交易存储在根据 gas 价格分类的池中。gas 价格越高，该交易就越有可能被添加进下一个区块。这是矿工节点的常见设定（为得到更高的报酬进行优化）。不过，矿工可以将自己的节点设置成根据自己的喜好对交易进行分类（例如，他们为了帮助网络只挖掘gas价格低的交易）。

从上图中，你看出我们的 voteForCandidate 交易是如何沉入矿池底端的吗？一旦所有gas价格高的交易都被挖出来包含进区块之后，矿工将挖掘我们的交易。

还有要注意的一点是，矿池可以容纳的交易数是有限的。比如，一场众筹正在火热进行中或是一个非常流行的分布式应用（如加密猫）横空出世。人们提交了 gas 价格高的交易，希望矿工能最先选中他们的交易。如果 gas 价格高的交易填满了矿池，gas 价格低的交易就会被放弃。我们的候选人 Nick 在一段时间内就别想收到任何选票了。在这种情况下，我们甚至得重新广播我们的交易。

另一个能让你的交易在矿池里上升的技巧是重新提交你的交易，提高 gas 价格并维持 nonce 值不变。这样一来，当矿工接收到新交易时，gas 价格更高的新交易会覆盖之前的交易。如果改变了 nonce 值，重新提交的交易就会被认为是不同的交易（最后会为Nick举行两次投票）。

##### 矿工节点找到一个有效区块并将它广播至网络

矿工最后选中了我们的交易，与其他交易一起包含进区块。矿工只能选择一定量的交易添加进区块，因为以太坊已经设置了单个区块 gas 上限，换言之，交易的所有 gas 上限总数不能超过区块 gas 上限。你可以在 [ethstats.net](https://ethstats.net/) 上查看当前 gas 上限。

一旦矿工选择将交易包含进区块，这些交易将被验证并包含进一个待处理区块，工作量证明开始。某个矿工节点（通过解决工作量证明难题）最终会找到一个有效的区块，并将这一区块添加到区块链上。就像经由你的本地节点广播的原始交易会被其他节点接收那样，矿工节点也会将这一有效区块广播给其他节点。

##### 本地节点接收/同步新区块

最终，你的本地节点将接收这个新区块，并同步区块链在本地的副本。一旦接收到这个新区块，本地节点就会执行区块里的所有交易。

如果你使用 truffle 执行你的交易， truffle 会不断测验区块链以求确认。一旦它发现交易被确认，就会执行 then() 区块中的代码，并打印（我们每个例子的）控制台日志函数。





https://ethfans.org/posts/life-cycle-of-an-ethereum-transaction