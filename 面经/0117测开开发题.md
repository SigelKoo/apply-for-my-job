# git stash

当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。

由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。

总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。

# 游标

>当前有三张表A、B、C其中A和B是一对多关系，B和C是一对多关系，现在需要将B中A表的主键存到C中；
>常规思路就是将B中查询出来然后通过一个update语句来更新C表就可以了，但是B表中有2000多条数据，
>难道要执行2000多次？显然是不现实的；最终找到写一个存储过程然后通过循环来更新C表，
>然而存储过程中的写法用的就是游标的形式。

游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。

游标充当指针的作用。

尽管游标能遍历结果中的所有行，但他一次只指向一行。

游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。

# TCP与HTTP的长连接

TCP的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，没有断掉一方的定时发送几次心跳包。如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前连接。

HTTP的keep-alive一般我们都会带上中间的横杠，普通的HTTP连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection: keep-alive头给服务端，且服务端也接受这个keep-alive的话，这个连接就可以复用了。一个HTTP处理完之后，另外一个HTTP数据包也直接从这个连接发送。减少新建和断开TCP连接的消耗。

HTTP协议的keep-alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求/响应。

TCP的KeepAlive机制意图在于保活、心跳、检测连接错误。当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。

# 为什么要了cookie还要session

用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。全部在客户端保存，服务端无法验证，这样伪造和仿冒会更加容易。（伪造一个随机的id很难，但伪造另一个用户名是很容易的）全部保存在客户端，那么一旦被劫持，全部信息都会泄露客户端数据量变大，网络传输的数据量也会变大。

# Redis并发竞争key

1. 乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy93djNLNmo0aWJsOTByNlFEZmhISWZpY3h2THhvM0gyMXIwTHc1b2VLcG5KekZ0ZWNpY1BFMGlibUhuNkI2cXNXMGJ5QTVPNWZ2RnpnQnkxbmliTzAwMFRhbjVRLzY0MA?x-oss-process=image/format,png)

2. 适合分布式环境，不用关心 redis 是否为分片集群模式。在业务层进行控制，操作 redis 之前，先去申请一个分布式锁，拿到锁的才能操作。分布式锁的实现方式很多，比如 ZooKeeper、Redis 等。
3. 时间戳
4. 在并发量很大的情况下，可以通过消息队列进行串行化处理。生产者是申请操作的线程，消费者是执行操作的线程。

# VARCHAR与CHAR的区别

char 表示定长，长度固定，varchar表示变长，即长度可变。char如果插入的长度小于定义长度时，则用空格填充；varchar小于定义长度时，还是按实际长度存储，插入多长就存多长。

因为其长度固定，char的存取速度还是要比varchar要快得多，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar则刚好相反，以时间换空间。

对 char 来说，最多能存放的字符个数 255，和编码无关。而 varchar 呢，最多能存放 65532 个字符。varchar的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532字节。

# &与&&的区别

&：不管前面的条件是否正确，后面都执行。

&&：前面条件正确时，才执行后面，不正确时，就不执行，就效率而言，这个更好。

# 路由器和交换机分别在哪层

交换机工作在数据链路层，路由器工作网络层。

交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，所以是在数据链路层工作。

# 多线程遇到的问题

死锁

不提供数据保护，可能出现多个线程先后更改数据造成所得数据是脏数据。

# 数组 指针 引用

指针一般指的是某块内存的**地址**

引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。

**指针可以为空，引用不能为空。**

数组是同一类型一组数据的集合

# IPv4 IPv6

IPv4协议具有32位（4字节）地址长度；IPv6协议具有128位（16字节）地址长度。

IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。

IPv4协议的包头的长度为20个字节。IPv6协议的包头的长度为40个字节。

IPv6提供身份验证和加密，但IPv4不提供。

# GROUP BY  ORDER BY

ORDER BY用来对数据库的一组数据进行排序

GROUP BY指定的规则对数据进行分组

# 视频一般使用什么协议

RTP协议，基于RTCP，UDP。

可以根据RTP包的序列号来排序。

可以根据RTP包的时间戳来获得数据包的时序。

根据声音流和图像流的相对时间（即RTP包的时间戳），以及它们的绝对时间（即对应的RTCP包中的RTCP），可以实现声音和图像的同步。

接收缓冲用来排序乱序了的数据包；播放缓冲用来消除播放的抖动，实现等时播放。

# 文件系统类型

EXT4是第四代扩展文件系统是Linux系统下的日志文件系统，是ext3文件系统的后继版本。

NTFS（New Technology File System）是Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式，提供长文件名、数据保护和恢复，能通过目录和文件许可实现安全性，并支持跨越分区。

FAT32指的是文件分配表是采用32位二进制数记录管理的磁盘文件管理方式，因FAT类文件系统的核心是文件分配表，命名由此得来。FAT32是从FAT和FAT16发展而来的，优点是稳定性和兼容性好，能充分兼容Win 9X及以前版本，且维护方便。缺点是安全性差，且最大只能支持32GB分区，单个文件也只能支持最大4GB。

# SYN ACK SEQ

tcp标志位

① SYN(synchronous建立联机)

② ACK(acknowledgement 确认)

③ PSH(push传送)

④ FIN(finish结束)

⑤ RST(reset重置)

⑥ URG(urgent紧急)

# 网络波动排查

traceroute命令

traceroute也是几乎所有Linux发行版本预装的网络测试工具，用于跟踪Internet协议（IP）数据包传送到目标地址时经过的路径。traceroute先发送小的具有最大存活时间值（Max_TTL）的UDP探测数据包，然后侦听从网关开始的整个链路上的ICMP TIME_EXCEEDED响应。探测从TTL=1开始，TTL值逐步增加，直至接收到ICMP PORT_UNREACHABLE消息。ICMP PORT_UNREACHABLE消息用于标识目标主机已经被定位，或命令已经达到允许跟踪的最大TTL值。traceroute默认发送UDP数据包进行链路探测。可以通过“-I”参数来指定使用ICMP数据包进行探测。

# 局域网，不让访问某网站

路由器 DNS IP MAC封禁

# 5L与6L桶，量出3L水

| 5L          | 6L          |
| ----------- | ----------- |
| 5L（0 + 5） | 0L          |
| 0L          | 5L（0 + 5） |
| 5L（0 + 5） | 5L          |
| 4L（5 - 1） | 6L（5 + 1） |
| 4L          | 0L（6 - 6） |
| 0L（4 - 4） | 4L（0 + 4） |
| 5L（0 + 5） | 4L          |
| 3L（5 - 2） | 6L（4 + 2） |

# 11L与5L桶，量出7L水

| 11L           | 5L          |
| ------------- | ----------- |
| 11L（0 + 11） | 0L          |
| 6L（11 - 5）  | 5L（0 + 5） |
| 6L            | 0L（5 - 5） |
| 1L（6 - 5）   | 5L（0 + 5） |
| 1L            | 0L（5 - 5） |
| 0L（1 - 0）   | 1L（0 + 1） |
| 11L（0 + 11） | 1L          |
| 7L（11 - 4）  | 5L（1 + 4） |

# 7L与11L，量出2L水

| 11L           | 7L          |
| ------------- | ----------- |
| 11L（0 + 11） | 0L          |
| 4L（11 - 7）  | 7L（0 + 7） |
| 4L            | 0L（7 - 7） |
| 0L（4 - 4）   | 4L（0 + 4） |
| 11L（0 + 11） | 4L          |
| 8L（11 - 3）  | 7L（4 + 3） |
| 8L            | 0L（7 - 7） |
| 1L（8 - 7）   | 7L（0 + 7） |
| 1L            | 0L（7 - 7） |
| 0L（1 - 0）   | 1L（0 + 1） |
| 11L（0 + 11） | 1L          |
| 5L（11 - 6）  | 7L（1 + 6） |
| 5L            | 0L（7 - 7） |
| 0L（5 - 5）   | 5L（0 + 5） |
| 11L（0 + 11） | 5L          |
| 9L（11 - 2）  | 7L（5 + 2） |
| 9L            | 0L（7 - 7） |
| 2L（9 - 7）   | 7L（0 + 7） |

# 3L与5L，量出4L水

| 3L          | 5L          |
| ----------- | ----------- |
| 3L（0 + 3） | 0L          |
| 0L（3 - 0） | 3L（0 + 3） |
| 3L（0 + 3） | 3L          |
| 1L（3 - 2） | 5L（3 + 2） |
| 1L          | 0L（5 - 5） |
| 0L（1 - 1） | 1L（0 + 1） |
| 3L（0 + 3） | 1L          |
| 0L（3 - 3） | 4L（1 + 3） |

# 一根金条切7份只切两刀

1 2 4

1

2

1 + 2

4

1 + 4

2 + 4

1 + 2 + 4

# 50个桃，10个盆，每个盆数量不一样

有一盆为0

1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55

1 + 2 + 3 + 4 + 0 + 6 + 7 + 8 + 9 + 10 = 50

# 54张牌拿出多少张保证至少6张花色相同

大小王 2张

4 * 5（每个花色摸出 5 张）

再来一张1

23张

# 100个药有一个毒药，最少需要几只小白鼠

000=0
001=1
010=2
011=3
100=4
101=5
110=6
111=7

每位数表示一只老鼠，0-7表示8个瓶子。即将1，3，5，7号瓶子的药混合取样给鼠1吃，2，3，6，7号瓶子混合取样给老鼠2吃……死鼠相应的位标为1。如鼠1死了，鼠2没死，鼠3死了，那么就是101=5号瓶子有毒。N只老鼠的量程为2^N，1000只瓶子位于2^9 ~ 2^10，即10只小鼠可以测1000瓶水。