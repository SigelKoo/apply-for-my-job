# 以太坊交易执行

## 表示一个账号

`core/state/state_object.go`

```go
// Account is the Ethereum consensus representation of accounts.
// These objects are stored in the main account trie.
type Account struct {
	Nonce    uint64
	Balance  *big.Int
	Root     common.Hash // merkle root of the storage trie
	CodeHash []byte
}
```

- Nonce：每次从这个账号发出的交易都会加1，防止重放攻击
- Balance：账号的余额
- Root：如果这是一个普通账户，这个值是空值的hash。如果是一个合约账号，那么这个哈希值就是这个合约代码里面用到的存储组成的MPT树的根哈希
- CodeHash：如果是智能合约账号，那么通过这个哈希就可以在数据库中直接找到智能合约的字节码

```go
// stateObject represents an Ethereum account which is being modified.
//
// The usage pattern is as follows:
// First you need to obtain a state object.
// Account values can be accessed and modified through the object.
// Finally, call CommitTrie to write the modified storage trie into a database.
type stateObject struct {
	address  common.Address
	addrHash common.Hash // hash of ethereum address of the account
	data     Account
	db       *StateDB

	// DB error.
	// State objects are used by the consensus core and VM which are
	// unable to deal with database-level errors. Any error that occurs
	// during a database read is memoized here and will eventually be returned
	// by StateDB.Commit.
	dbErr error

	// Write caches.
	trie Trie // storage trie, which becomes non-nil on first access
	code Code // contract bytecode, which gets set when code is loaded

	originStorage  Storage // Storage cache of original entries to dedup rewrites, reset for every transaction
	pendingStorage Storage // Storage entries that need to be flushed to disk, at the end of an entire block
	dirtyStorage   Storage // Storage entries that have been modified in the current transaction execution
	fakeStorage    Storage // Fake storage which constructed by caller for debugging purpose.

	// Cache flags.
	// When an object is marked suicided it will be delete from the trie
	// during the "update" phase of the state transition.
	dirtyCode bool // true if the code was updated
	suicided  bool
	deleted   bool
}
```

以太坊世界状态的改变是通过操作 stateObject 进行的。这个结构是世界状态MPT树的操作对象。对账号余额的修改，智能合约状态的改变，回滚等操作都通过这个结构进行。

以太坊白皮书说“以太坊是一个基于交易的状态机”，状态的改变都是通过区块中的每一笔交易驱动。通过 stateObject 我们就可以快速的找到一个账号的信息。

## 表示一笔交易

`core/types/transaction.go`

```go
// Transaction is an Ethereum transaction.
type Transaction struct {
	inner TxData    // Consensus contents of a transaction
	time  time.Time // Time first seen locally (spam avoidance)

	// caches
	hash atomic.Value
	size atomic.Value
	from atomic.Value
}
```

`core/types/access_list_tx.go`

```go
type AccessListTx struct {
	ChainID    *big.Int        // destination chain ID
	Nonce      uint64          // nonce of sender account
	GasPrice   *big.Int        // wei per gas
	Gas        uint64          // gas limit
	To         *common.Address `rlp:"nil"` // nil means contract creation
	Value      *big.Int        // wei amount
	Data       []byte          // contract invocation input data
	AccessList AccessList      // EIP-2930 access list
	V, R, S    *big.Int        // signature values
}
```

- Nonce：账号随机数
- GasPrice：每个gas需要消耗多少以太坊币
- Gas：这个操作最多允许消耗的gas
- To：转账的地址或者智能合约地址
- Value：转账数量
- Data：如果是普通账户，这个payload就相当于一个备注功能，如果是合约账户那么这个Data就是在调用合约里面的方法，或者是在创建一个智能合约
- V, R, S 对交易的签名

## 交易进入mempool时的验证

`core/tx_pool.go`

```go
// TxPool contains all currently known transactions. Transactions
// enter the pool when they are received from the network or submitted
// locally. They exit the pool when they are included in the blockchain.
//
// The pool separates processable transactions (which can be applied to the
// current state) and future transactions. Transactions move between those
// two states over time as they are received and processed.
type TxPool struct {
	config      TxPoolConfig
	chainconfig *params.ChainConfig
	chain       blockChain
	gasPrice    *big.Int
	txFeed      event.Feed
	scope       event.SubscriptionScope
	signer      types.Signer
	mu          sync.RWMutex

	istanbul bool // Fork indicator whether we are in the istanbul stage.
	eip2718  bool // Fork indicator whether we are using EIP-2718 type transactions.
	eip1559  bool // Fork indicator whether we are using EIP-1559 type transactions.

	currentState  *state.StateDB // Current state in the blockchain head
	pendingNonces *txNoncer      // Pending state tracking virtual nonces
	currentMaxGas uint64         // Current gas limit for transaction caps

	locals  *accountSet // Set of local transaction to exempt from eviction rules
	journal *txJournal  // Journal of local transaction to back up to disk

	pending map[common.Address]*txList   // All currently processable transactions
	queue   map[common.Address]*txList   // Queued but non-processable transactions
	beats   map[common.Address]time.Time // Last heartbeat from each known account
	all     *txLookup                    // All transactions to allow lookups
	priced  *txPricedList                // All transactions sorted by price

	chainHeadCh     chan ChainHeadEvent
	chainHeadSub    event.Subscription
	reqResetCh      chan *txpoolResetRequest
	reqPromoteCh    chan *accountSet
	queueTxEventCh  chan *types.Transaction
	reorgDoneCh     chan chan struct{}
	reorgShutdownCh chan struct{}  // requests shutdown of scheduleReorgLoop
	wg              sync.WaitGroup // tracks loop, scheduleReorgLoop
}
```

- config：关于交易池的一些配置信息，比如： 交易池允许的最大容量、交易池允许的最低gasPrice等信息
- chainConfig：关于区块的一些全局配置信息
- gasPrice：gas费用
- chainHeadCh：区块链的head发生了改变，需要通过这个chan通知， head发生改变是因为发生了chain reorganazition
- queue：这个队列里面保存了账号不可立即执行的交易，也就是nonce不连续的交易

```go
// validateTx checks whether a transaction is valid according to the consensus
// rules and adheres to some heuristic limits of the local node (price and size).
func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error {
	// Accept only legacy transactions until EIP-2718/2930 activates.
	if !pool.eip2718 && tx.Type() != types.LegacyTxType {
		return ErrTxTypeNotSupported
	}
	// Reject dynamic fee transactions until EIP-1559 activates.
	if !pool.eip1559 && tx.Type() == types.DynamicFeeTxType {
		return ErrTxTypeNotSupported
	}
	// Reject transactions over defined size to prevent DOS attacks
	if uint64(tx.Size()) > txMaxSize {
		return ErrOversizedData
	}
	// Transactions can't be negative. This may never happen using RLP decoded
	// transactions but may occur if you create a transaction using the RPC.
	if tx.Value().Sign() < 0 {
		return ErrNegativeValue
	}
	// Ensure the transaction doesn't exceed the current block limit gas.
	if pool.currentMaxGas < tx.Gas() {
		return ErrGasLimit
	}
	// Sanity check for extremely large numbers
	if tx.GasFeeCap().BitLen() > 256 {
		return ErrFeeCapVeryHigh
	}
	if tx.GasTipCap().BitLen() > 256 {
		return ErrTipVeryHigh
	}
	// Ensure gasFeeCap is greater than or equal to gasTipCap.
	if tx.GasFeeCapIntCmp(tx.GasTipCap()) < 0 {
		return ErrTipAboveFeeCap
	}
	// Make sure the transaction is signed properly.
	from, err := types.Sender(pool.signer, tx)
	if err != nil {
		return ErrInvalidSender
	}
	// Drop non-local transactions under our own minimal accepted gas price or tip
	if !local && tx.GasTipCapIntCmp(pool.gasPrice) < 0 {
		return ErrUnderpriced
	}
	// Ensure the transaction adheres to nonce ordering
	if pool.currentState.GetNonce(from) > tx.Nonce() {
		return ErrNonceTooLow
	}
	// Transactor should have enough funds to cover the costs
	// cost == V + GP * GL
	if pool.currentState.GetBalance(from).Cmp(tx.Cost()) < 0 {
		return ErrInsufficientFunds
	}
	// Ensure the transaction has more gas than the basic tx fee.
	intrGas, err := IntrinsicGas(tx.Data(), tx.AccessList(), tx.To() == nil, true, pool.istanbul)
	if err != nil {
		return err
	}
	if tx.Gas() < intrGas {
		return ErrIntrinsicGas
	}
	return nil
}
```

- 交易的大小不超过128KB
- 转账数量不能为负
- 交易的gas数量不能超过区块最大允许的gas数量
- 验证交易签名的正确性
- 验证是否满足交易池的配置信息
- 验证nonce的正确性
- 验证账户余额是否足够
- 验证固有gas消耗满足需求

## 交易在虚拟机中执行

`core/types/transaction.go`

```go
// Message is a fully derived transaction and implements core.Message
//
// NOTE: In a future PR this will be removed.
type Message struct {
	to         *common.Address
	from       common.Address
	nonce      uint64
	amount     *big.Int
	gasLimit   uint64
	gasPrice   *big.Int
	gasFeeCap  *big.Int
	gasTipCap  *big.Int
	data       []byte
	accessList AccessList
	checkNonce bool
}
```

前面提到的`Transaction`结构在虚拟机中执行之前都会转换为 `Message` 结构:

```go
func (tx *Transaction) AsMessage(s Signer, baseFee *big.Int) (Message, error) {
	msg := Message{
		nonce:      tx.Nonce(),
		gasLimit:   tx.Gas(),
		gasPrice:   new(big.Int).Set(tx.GasPrice()),
		gasFeeCap:  new(big.Int).Set(tx.GasFeeCap()),
		gasTipCap:  new(big.Int).Set(tx.GasTipCap()),
		to:         tx.To(),
		amount:     tx.Value(),
		data:       tx.Data(),
		accessList: tx.AccessList(),
		checkNonce: true,
	}
	// If baseFee provided, set gasPrice to effectiveGasPrice.
	if baseFee != nil {
		msg.gasPrice = math.BigMin(msg.gasPrice.Add(msg.gasTipCap, baseFee), msg.gasFeeCap)
	}
	var err error
	msg.from, err = Sender(s, tx)
	return msg, err
}
```

源码`core/state_processor.go`中的 `func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) {}` 函数第一个参数block表示要在EVM中执行的区块，第二个参数stateDB是要修改的世界状态数据库， 第三个参数cfg是关于EVM的配置信息。Process函数对区块中的每一笔交易调用ApplyTransaction函数。在这个函数中为每一笔交易创建新的虚拟机执行环境。接下来的关键调用链：

```
ApplyTransaction -> ApplyMessage -> NewStateTransition -> TransitionDb
```

```go
// TransitionDb will transition the state by applying the current message and
// returning the evm execution result with following fields.
//
// - used gas:
//      total gas used (including gas being refunded)
// - returndata:
//      the returned data from evm
// - concrete execution error:
//      various **EVM** error which aborts the execution,
//      e.g. ErrOutOfGas, ErrExecutionReverted
//
// However if any consensus issue encountered, return the error directly with
// nil evm execution result.
func (st *StateTransition) TransitionDb() (*ExecutionResult, error) {
	// First check this message satisfies all consensus rules before
	// applying the message. The rules include these clauses
	//
	// 1. the nonce of the message caller is correct
	// 2. caller has enough balance to cover transaction fee(gaslimit * gasprice)
	// 3. the amount of gas required is available in the block
	// 4. the purchased gas is enough to cover intrinsic usage
	// 5. there is no overflow when calculating intrinsic gas
	// 6. caller has enough balance to cover asset transfer for **topmost** call
	...
	contractCreation := msg.To() == nil
	...
	if contractCreation {
		ret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)
	} else {
		// Increment the nonce for the next transaction
		st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)
		ret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)
	}
    ...
}
```

在这里会区别对待普通交易和和创建智能合约的交易。st.evm.Create根据参数创建智能合约，st.evm.Call根据交易信息在虚拟机中执行这笔交易。重点分析下st.evm.Call

`core/vm/evm.go`

```go
func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
	...
	evm.Context.Transfer(evm.StateDB, caller.Address(), addr, value)
	...
	if isPrecompile {
		ret, gas, err = RunPrecompiledContract(p, input, gas)
	} else {
		// Initialise a new contract and set the code that is to be used by the EVM.
		// The contract is a scoped environment for this execution context only.
		code := evm.StateDB.GetCode(addr)
		if len(code) == 0 {
			ret, err = nil, nil // gas is unchanged
		} else {
			addrCopy := addr
			// If the account has no code, we can abort here
			// The depth-check is already done, and precompiles handled above
			contract := NewContract(caller, AccountRef(addrCopy), value, gas)
			contract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), code)
			ret, err = evm.interpreter.Run(contract, input, false)
			gas = contract.Gas
		}
	}
	// When an error was returned by the EVM or when setting the creation code
	// above we revert to the snapshot and consume any gas remaining. Additionally
	// when we're in homestead this also counts for code storage gas errors.
	if err != nil {
		evm.StateDB.RevertToSnapshot(snapshot)
		if err != ErrExecutionReverted {
			gas = 0
		}
		// TODO: consider clearing up unused snapshots:
		//} else {
		//	evm.StateDB.DiscardSnapshot(snapshot)
	}
	return ret, gas, err
}
```

evm.Context.Transfer完成以太币的转账操作，然后在stateDB中找到并设置智能合约的代码，最后通过evm.interpreter.Run函数在EVM中执行智能合约的字节码， 如果执行过程中发生错误则回滚先前的操作， 返回执行结果。至此，这笔交易的执行结果就被写到了区块链中。

## 总结

以太坊中一笔交易的执行流程大致为：

例如：web3js调用智能合约函数，构建原生交易对象 -> 使用与该账户相对应的私钥签署交易 -> 已签名的交易提交给本地以太坊节点，本地验证交易 -> 签名交易通过发起人的校验节点（geth）通过p2p网络广播交易 -> 矿工节点收到交易 -> 将交易反序列化为 `Transaction` 结构 -> 将交易放到txpool，对交易验证 -> 矿工挖矿 -> 在EVM中执行这笔交易 -> 交易执行结果写入stateDB

# 区块

## 区块头

```go
type Header struct {
	ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
	UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
	Coinbase    common.Address `json:"miner"            gencodec:"required"`
	Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
	TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
	ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
	Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
	Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
	Number      *big.Int       `json:"number"           gencodec:"required"`
	GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
	GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
	Time        uint64         `json:"timestamp"        gencodec:"required"`
	Extra       []byte         `json:"extraData"        gencodec:"required"`
	MixDigest   common.Hash    `json:"mixHash"`
	Nonce       BlockNonce     `json:"nonce"`

	// BaseFee was added by EIP-1559 and is ignored in legacy headers.
	BaseFee *big.Int `json:"baseFeePerGas" rlp:"optional"`
}
```

- ParentHash：父区块的hash
- Coinbase：挖出此块的矿工地址
- UncleHash：叔块集合的RLP哈希值
- Root：状态树根节点的哈希值。状态数用来记录账号信息， 合约账户和用户账户等信息
- TxHash：交易树根节点的RLP哈希值
- ReceiptHash：收据树根节点的RLP哈希值。收据树记录交易执行过程中的一些数据
- Bloom：Bloom过滤器，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中
- Difficulty：区块的难度
- Number：区块的序号。Block的Number等于其父区块Number + 1
- Time：出块时间
- GasLimit：区块内所有Gas消耗的理论上限
- GasUsed：区块内所有Transaction执行时所实际消耗的Gas总和
- Extra：额外数据
- MixDigest：用于POW
- Nonce：用于POW 结合MixDigest生成区块哈希值

## 区块体

以太坊将一个Block中的交易集合和叔块集合单独封装到一个Body结构中，因为他们相对于Header需要更多的内存空间，在传输和验证时为了节省时间可以和Header分开进行。

```go
type Body struct {
	Transactions []*Transaction
	Uncles       []*Header
}
```

区块体中存储交易列表与叔块头

## 区块

```go
// Block represents an entire block in the Ethereum blockchain.
type Block struct {
	header       *Header
	uncles       []*Header
	transactions Transactions

	// caches
	hash atomic.Value
	size atomic.Value

	// Td is used by package core to store the total difficulty
	// of the chain up to and including the block.
	td *big.Int

	// These fields are used by package eth to track
	// inter-peer block relay.
	ReceivedAt   time.Time
	ReceivedFrom interface{}
}
```

- header：区块头

- uncles：叔块的区块头

- transactions：交易列表

- hash：Header内容的RLP哈希值。在第一次计算后会缓存到hash值里。

  ```go
  func (b *Block) Hash() common.Hash {
      if hash := b.hash.Load(); hash != nil {
          return hash.(common.Hash)
      }
      v := b.header.Hash()
      b.hash.Store(v)
      return v
  }
  
  func (h *Header) Hash() common.Hash {
  	return rlpHash(h)
  }
  
  // rlpHash encodes x and hashes the encoded bytes.
  func rlpHash(x interface{}) (h common.Hash) {
  	sha := hasherPool.Get().(crypto.KeccakState)
  	defer hasherPool.Put(sha)
  	sha.Reset()
  	rlp.Encode(sha, x)
  	sha.Read(h[:])
  	return h
  }
  ```

# 全节点与轻节点

全节点：同步所有区块链数据的节点，包括各种区块Body等等相关信息。但也是因为节点全量数据都保存的情况，我们不需要相依赖中介去进行数据的验证。

以太坊轻节点（轻客户端）：每当有区块出现在网络便下载区块头，而不是全量的情况状态，并发送客户端需要的特定状态的默克尔证明（Merkle proofs）的请求。同时在以太坊轻节点中使用分布式哈希表来追踪前缀节点，而不是直接采用LevelDB进行直接的存储。

# Merkle树

二叉树，一个根节点，一组中间节点与一组叶子节点组成。

特点：

- 最下面的叶节点包含存储数据或其哈希值
- 非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值

默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。

### 作用

1. **证明某个集合中存在或不存在某个元素**：通过构建集合的默克尔树，并提供该元素各级兄弟节点中的Hash 值，可以不暴露集合完整内容而证明某元素存在。

   另外，对于可以进行排序的集合，可以将不存在元素的位置用空值代替，以此构建稀疏默克尔树（Sparse Merkle Tree）。该结构可以证明某个集合中不包括指定元素。

2. **快速比较大量数据**：对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。

   由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。

3. **快速定位修改**：以下图为例，基于数据 D0……D3 构造默克尔树，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。

   ![img](https://files.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-M5xTVjj6plOWgHcmTHq%2Fsync%2F01dd48b2fe29d3d5ba879d8eddfe6db037b13596.png?generation=1588030734755898&alt=media)

   因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root --> N4 --> N1，最多通过 O(lgN) 时间即可快速定位到实际发生改变的数据块 D1。

### 优势

- 快速重哈希

Merkle tree的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。

- 轻节点扩展

采用Merkle tree，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

对于轻节点来说，验证一条交易只需要验证包含该交易的路径即可，并不需要把所有交易的Hash全部重新算一遍。

![img](https://pic1.zhimg.com/80/v2-1acfb4f6da08977b33ee75e349f83d88_720w.jpg)

# Merkle Patricia Trie

融合了Merkle树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

## Trie

前缀树或字典树，是一种有序树，用于保存关联数组。其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定 。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。

一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。实际上trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串。

常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。如图：

![img](https://pic4.zhimg.com/80/v2-07a263568193a61ed457ea441a69513f_720w.jpg)

### 优势

相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)，然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。

但是对于最差的情况（前缀为空串)，时间效率为O(n)，仍然需要遍历整棵树，此时效率与哈希表相同。

相比于哈希表，在前缀树不会存在哈希冲突的问题。

### 劣势

- 直接查找效率低下。前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。
- 可能会造成空间浪费。当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。

## Patricia Trie

一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。

![img](https://pic1.zhimg.com/80/v2-932c5c442939901fa4259789029eb190_720w.jpg)

## Merkle Patricia Trie

- 空节点：简单的表示空，在代码中是一个空串。
- 叶子节点：表示为 [key,value]的一个键值对，其中key是key的一种特殊十六进制编码（MP编码）， value是value的RLP编码。
- 分支节点：因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list， 前16个元素对应着key中的16个可能的十六进制字符 ， 如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值 ，即分支节点既可以搜索路径的终止也可以是路径的中间节点。
- 扩展节点：也是[key，value]的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。

### 三种编码格式

1. Raw编码（原生的字符）；
2. Hex编码（扩展的16进制编码）；
3. Hex-Prefix编码（16进制前缀编码）；

#### Raw编码

Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。

例如：一条key为"cat"，value为"dog"的数据项，其key的Raw编码就是['c', 'a', 't']，换成ASCII表示方式就是[63, 61, 74]（Hex）

#### Hex编码

Hex编码就是把一个8位的字节数据用两个十六进制数展示出来，编码时，将8位二进制码重新分组成两个4位的字节，其中一个字节的低4位是原字节的高四位，另一个字节的低4位是原数据的低4位，高4位都补0，然后输出这两个字节对应十六进制数字作为编码。Hex编码后的长度是源数据的2倍。

ASCII码：A (65)；二进制码：0100_0001；重新分组：0000_0100 0000_0001；十六进制： 4 1；Hex编码：41

若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为terminator；

若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；

['c','a','t'] -> [6,3,6,1,7,4,**16**]

#### HP编码

目的：

- 区分叶子节点和扩展节点
- 把奇数路径变成偶数路径

步骤：

- 如果有terminator（16）那么就去掉terminator。
- 根据表格给key加上prefix

```text
node type    path length    |    prefix    hexchar
--------------------------------------------------
extension    even           |    0000      0x0
extension    odd            |    0001      0x1
leaf         even           |    0010      0x2
leaf         odd            |    0011      0x3
```

如果prefix是0x0或者0x2，加一个padding nibble 0 在prefix后面，所以最终应该是 0x00 和 0x20。原因是为了保证key（path）的长度为偶数。

例子：末尾的字符“16”说明该节点为叶子结点，并且加上了0x20

```text
[ 0, f, 1, c, b, 8, 16] -> '20 0f 1c b8'
```

#### 编码转换关系

- Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；
- Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；
- HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；

![img](https://pic3.zhimg.com/80/v2-232537cfac5103618cb9b0b45e9a47e2_720w.jpg)

MPT树的特点如下:

- 叶子节点和分支节点可以保存value，扩展节点保存key；
- 没有公共的key就成为2个叶子节点；key1=[1,2,3] key2=[2,2,3]
- 有公共的key需要提取为一个扩展节点；key1=[1,2,3] key2=[1,3,3] => ex-node=[1],下一级分支node的key
- 如果公共的key也是一个完整的key，数据保存到下一级的分支节点中；key1=[1,2] key2=[1,2,3] =>ex-node=[1,2],下一级分支node的key; 下一级分支=[3],上一级key对应的value

![img](https://pic4.zhimg.com/80/v2-e2698781750973ae4a083f3dbe8bb517_720w.jpg)

过程：

```text
key  	 |  values
----------------------
a711355  |  45.0 ETH
a77d337  |  1.00 WEI
a7f9365  |  1.1  ETH
a77d397  |  0.12 ETH
```

**插入第一个<a711355, 45>，由于只有一个key，直接用leaf node既可表示**

![img](https://pic2.zhimg.com/80/v2-ed1f460bb6353d5817ce4cb24a6d5d3d_720w.jpg)

**接着插入a77d337，由于和a711355共享前缀'a7'，因而可以创建'a7'扩展节点。**

![img](https://pic3.zhimg.com/80/v2-b8117db4cafb85f52e840899ff22241e_720w.jpg)

**接着插入a7f9365，也是共享'a7'，只需新增一个leaf node**

![img](https://pic2.zhimg.com/80/v2-fb9cace75809b83abb90c79957a6d675_720w.jpg)

**最后插入a77d397，这个key和a77d337共享'a7'+'d3'，因而再需要创建一个'd3'扩展节点**

![img](https://pic2.zhimg.com/80/v2-4fcf5ab87c1b497a34f9e113a3da5be9_720w.jpg)

**将叶子节点和最后的short node合并到一个节点了，事实上源码实现需要再深一层，最后一层的叶子节点只有数据**

![img](https://pic1.zhimg.com/80/v2-345a4e2896e9605aea982b206dcbd940_720w.jpg)

```go
// nodeFlag contains caching-related metadata about a node.
type nodeFlag struct {
    hash  hashNode // cached hash of the node (may be nil)
    gen   uint16   // cache generation counter
    dirty bool     // whether the node has changes that must be written to the database
}
```

**MPT节点有个flag字，nodeFlag，记录了一些辅助数据：**

- 节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；
- 诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；
- 脏标志：当一个节点被修改时，该标志位被置为1；

**flag.hash会保存该节点采用merkle tree类似算法生成的hash。同时会将hash和源数据以<hash, node.rlp.rawdata>方式保存在leveldb数据库中。这样后面通过hash就可以反推出节点数据。具体结构如下(蓝色的hash部分就是flag.hash字段)**

![img](https://pic4.zhimg.com/80/v2-7d1caad737c77663a8ae43611eff29af_720w.jpg)

## **核心思想**

hash可以还原出节点上的数据，这样只需要保存一个root(hash)，即可还原出完整的树结构，同时还可以按需展开节点数据，比如如果只需要访问<a771355, 45>这个数据，只需展开h00, h10, h20, h30这四个hash对应的节点

