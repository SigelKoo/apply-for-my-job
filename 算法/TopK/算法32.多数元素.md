# 多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 ```
输入：[3,2,3]
输出：3
 ```

```
输入：[2,2,1,1,1,2,2]
输出：2
```

```go
func majorityElement(nums []int) int {

}
```

自己的方法

```go
func majorityElement(nums []int) int {
	var maxkey int
	maxval := 0
	a := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		a[nums[i]] += 1
	}
	for k, v := range a {
		if v > maxval {
			maxkey = k
			maxval = v
		}
	}
	return maxkey
}
```

有一种摩尔投票法，也称多数投票法，可以在任意多的候选人中，选出得票最多的那个（多数人评论只能找出票数过半的）

步骤：

1. 对抗阶段，两个候选人的票数进行两两对抗抵消
2. 计数阶段，计算对抗结果中最后留下的候选人票数是否有效


```
[2, 2, 1, 3, 1, 2, 2]
major = 2, count = 1
major = 2, count = 1 + 1 = 2
major = 2, count = 2 - 1 = 1
major = 2, count = 1 - 1 = 0
major = 1, count = 1
major = 1, count = 1 - 1 = 0
major = 2, count = 1
majoe = 2, count = 2
```

```go
func majorityElement(nums []int) int {
	major := 0
	count := 0
	
	for _, num := range nums {
		if count == 0 {
			major = num
		}
		if major == num {
			count += 1
		} else {
			count -= 1
		}
	}
	
	return major
}
```

哈哈哈，还有看到排序后取最中间的数的

```go
func majorityElement(nums []int) int {
    length := len(nums)
    sort.Ints(nums)
    return nums[length / 2]
}
```

排序方法时间慢，但空间效率高；其他两种方法，时间快，但空间效率低





