# 按序打印

我们提供了一个类：

```java
public class Foo {
  public void first() { print("first"); }
  public void second() { print("second"); }
  public void third() { print("third"); }
}
```


三个不同的线程将会共用一个 Foo 实例。

线程 A 将会调用 first() 方法
线程 B 将会调用 second() 方法
线程 C 将会调用 third() 方法
请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。

```
输入: [1,2,3]
输出: "firstsecondthird"
解释: 
有三个线程会被异步启动。
输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。
正确的输出是 "firstsecondthird"。
```

```
输入: [1,3,2]
输出: "firstsecondthird"
解释: 
输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。
正确的输出是 "firstsecondthird"。
```

```go
var secondChan = make(chan int)
var thirdChan = make(chan int)
var mainChan = make(chan int)

func first() {
	fmt.Print("first")
	secondChan <- 1
}

func second() {
	signal := <-secondChan
	fmt.Print("second")
	thirdChan <- signal
	close(secondChan)
}

func third() {
	signal := <-thirdChan
	fmt.Print("third")
	mainChan <- signal
	close(thirdChan)
}

func main() {
	funcMap := map[int]func(){1: first, 2: second, 3: third}
	inputList := [3]int{1, 2, 3}

	for _, num := range inputList {
		go funcMap[num]()
	}

	_ = <-mainChan
	close(mainChan)
}
```

```go
type Foo struct {
	one  chan int
	two  chan int
	tree chan int
}

func NewFoo() Foo {
	f := Foo{
		one:  make(chan int, 0),
		two:  make(chan int, 0),
		tree: make(chan int, 0),
	}
	return f
}

func (f Foo) One() {
	v := <-f.one
	fmt.Println("one")
	f.two <- v
}

func (f Foo) Two() {
	v := <-f.two
	fmt.Println("two")
	f.tree <- v
}

func (f Foo) Three() {
	<-f.tree
	fmt.Println("three")
}



//测试
func Test2() {
	go func() {
		f := NewFoo()
		go f.Three()
		time.Sleep(1*time.Millisecond)
		go f.Two()
		go f.One()
		f.one <-1
	}()

	time.Sleep(1 * time.Second)
}
```

