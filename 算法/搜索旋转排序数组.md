# 搜索旋转排序数组

升序排列的整数数组 nums 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

```
输入：nums = [1], target = 0
输出：-1
```

```
func search(nums []int, target int) int {

}
```

nums[0] <= target <= nums[mid] 时 high 向前规约

target <= nums[mid] < nums[0] 时 high 向前规约

nums[mid] < nums[0] <= target 时 high 向前规约

其他情况向后规约

(nums[0] <= target)， (target <= nums[i]) ，(nums[i] < nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））

所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。

使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）

```go
func search(nums []int, target int) int {
	a := 0
	b := len(nums) - 1
	for a < b {
		mid := (a + b) / 2
		if (nums[0] <= target && target <= nums[mid]) ||
			(target <= nums[mid] && nums[mid] < nums[0]) ||
			(nums[mid] < nums[0] && nums[0] <= target) {
			a = mid + 1
		} else {
			b = mid
		}
	}
	if a == b && nums[a] == target {
		return a
	}
	return -1
}
```

