# 简述数据库中的ACID分别是什么

## ACID

- 原子性（Atomicity）：事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功，要么全部失败。

- 一致性（Consistency）：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指：1.系统的状态满足数据的完整性约束（主码，参照完整性，check约束等）2.系统的状态反应数据库本应描述的现实世界的真实状态，比如转账前后两个账户的金额总和应该保持不变。

- 隔离性（Isolation）：并发执行的事务不会相互影响，其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账，最后账户的结果应该和他们按先后次序转账的结果一样。

- 持久性（Durability）：事务一旦提交，其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。

在事务的ACID特性中，C即一致性是事务的根本追求，而对数据一致性的破坏主要来自两个方面。

1. 事务的并发执行

2. 事务故障或系统故障

数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。

并发控制技术保证了事务的隔离性，使数据库的一致性状态不会因为并发执行的操作被破坏。

日志恢复技术保证了事务的原子性，使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失，保证了事务的持久性。

![img](https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103102223-1059881337.png)



C一致性案例

> A要向B支付100元，而A的账户中只有90元，并且我们给定账户余额这一列的约束是不能小于0。那么很明显这条事务执行会失败，因为90-100=-10，小于我们给定的约束了。

这个例子里，支付之前我们数据库里的数据都是符合约束的，但是如果事务执行成功了，我们的数据库数据就破坏约束了，因此事务不能成功，这里我们说事务提供了一致性的保证。然后我们再看个例子。

>A要向B支付100元，而A的账户中只有90元，我们的账户余额列没有任何约束。但是我们业务上不允许账户余额小于0。因此支付完成后我们会检查A的账户余额，发现余额小于0了，于是我们进行了事务的回滚。

这个例子里，如果事务执行成功，虽然没有破坏数据库的约束，但是破坏了我们应用层的约束。而事务的回滚保证了我们的约束，因此也可以说事务提供了一致性保证（ps：事实上，是我们应用层利用事务回滚保证了我们的约束不被破坏），最后我们再看个例子

>A要向B支付100元，而A的账户中只有90元，我们的账户余额列没有任何约束。然后支付成功了。

这里，如果按照很多人的理解，事务不是保证一致性么？直观上账户余额为什么能为负呢。但这里事务执行前和执行后，我们的系统没有任何的约束被破坏。一直都是保持正确的状态。钱的数量90-100=-10没有变化。

所以，综上。你可以理解一致性就是：应用系统从一个正确的状态到另一个正确的状态，而ACID就是说事务能够通过AID来保证这个C的过程，C是目的，AID都是手段。

## 实现原理

- 原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log
- 持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log
- 隔离性：保证事务执行尽可能不受其他事务影响；主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）
- 一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障
