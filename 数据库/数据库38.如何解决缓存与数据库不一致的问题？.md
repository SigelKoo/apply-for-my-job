# 如何解决缓存与数据库不一致的问题？

先读缓存数据，缓存数据有，则立即返回结果；如果没有数据，则从数据库读数据，并且把读到的数据同步到缓存里，提供下次读请求返回数据。

虽说这样能减轻数据库压力，但是如果修改删除数据，在多线程高并发的场景下会有可能导致缓存和数据库数据不一致问题，那该如何解决呢？

#### 场景1

问题的根源其实是读数据与写数据请求同时并发时，数据库与缓存数据已更新，但访问的数据还是老数据，出现了脏读数据，我们假设读请求流程没有问题，那就分析写请求流程的优化。

![img](https://pics1.baidu.com/feed/3c6d55fbb2fb43161944ad091306e82708f7d395.jpeg?token=13286f00a345669b95f5746d6dd6c32b&s=F6B9E76A7332B7CE4A45832602003057)

我们遇到写请求时，可用先删除缓存数据，再更新数据库，这样不管数据库更新失败还是缓存删除失败，缓存与数据库始终一致。这种方案一般可满足上万人并发操作了，因为删除缓存到更新数据库的时间可以用毫秒计算，正常的并发影响不大。

#### 场景2

上亿级并发访问，导致缓存与数据不一致。

比方：淘宝双11活动，抢购商品，商品数量为100，当前状态是数据库和缓存都是100，这时上亿账户抢购该商品，商品数量要减少。一个消费者A抢购成功，这时应该删除缓存，更新商品数量，在更新商品数量之前，又有一个消费者B来查看该商品数量，由于缓存清空，到数据库查询，该消费者查看到的是商品数量为100，并更新缓存为100，其实商品数量已经被消费者B抢购成功之后，数据库中商品数量更新为99了，缓存与数据库数据不一致。

1. 读请求只访问缓存，写请求只修改数据库和缓存

   ![img](https://pics7.baidu.com/feed/63d9f2d3572c11df6017f5f85185ccd4f503c24a.jpeg?token=d0df587fa9b9d75c10071d1720ad8ac1&s=3EA9E74A071207CA0EB6A72F0200F057)

   

   写请求修改数据库和缓存是事务性动作，如果更新数据库成功，更新缓存失败，则回滚数据库，保证缓存与数据库数据强一致。这样实现了读写分离，不仅提高了读的响应速度，由写请求负责缓存与数据库一致，只有写请求成功才会影响到缓存的内容，时效性大大增强。

2. 队列存储请求

   ![img](https://pics4.baidu.com/feed/72f082025aafa40f8e59b07098c6ad4b79f01922.jpeg?token=5a6476302e9f363ef2dbcac2802c1552&s=D6A9F74A693296CE0915022702008056)

   沿用场景一的解决方案，为解决其缺陷，添加队列，凡是遇到写请求，则将写请求放入队列中，由队列对写请求统一管理，写请求处理成功，则从队列中删除。当有一个读请求过来时，到队列查询，是否有对应的写请求，如果有则放入队列中，等待写请求执行完之后再执行读请求。为防止某个请求阻塞情况，为其设置超时机制或者过期机制。

   这种方案虽可行，但是倘若访问量大，处理器来不及处理，队列内的请求数量越来越高，则会影响查询效率。出现这种情况，就要加机器集群执行，帮忙分担压力。

