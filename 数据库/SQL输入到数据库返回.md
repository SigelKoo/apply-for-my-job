![MySQL基本架构](https://img-blog.csdnimg.cn/20181125162034829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbWVob3cxMDAy,size_16,color_FFFFFF,t_70)

1. 客户端发起连接MySQL服务的请求。
2. 连接器接受客户端的请求，验证其账号密码信息是否正确。
   - 如果正确运行登录MySQL数据库。
   - 如果不正确拒绝登录，并返回错误信息。
3. 如果开启了MySQL的查询缓存的功能，会先根据查询的SQL语句去查询缓存中查看是否有这样的SQL对应的缓存结果。
   - 如果发现缓存结果，则直接基于缓存的结果进行更新语句的操作，进入下面的第9步。
   - 如果没有缓存结果，则跳出查询缓存模块，走向解析器模块。
4. 解析器解析SQL语句是否正确，语法词法是对。
   - 如果词法或者语法有问题，则返回错误信息给客户端。
   - 如果词法语句正确，则继续往后面的组件“预处理器”中走。
5. 预处理器会根据验证后SQL语句生成语法树。
6. 查询优化器根据预处理生成的语法树，生成一个最优的执行计划。
7. 执行器根据优化器提供的执行计划去执行调用存储引擎层的接口执行SQL语句。
8. 存储引擎层接受到执行器的请求后，去查询缓存中去查询是否有对应的数据。
   - 如果有对应的数据则直接返回给Server层的执行器。
   - 如果没有对应要查询的数据，则根据对应的执行计划去觉得如何去磁盘中扫描对应要查询的数据。这里查询的时候，可能使用到索引，也可能不使用索引，具体就看执行计划是怎么样的。
   - 这里的查询缓存并不是Server层的查询缓存，而是存储引擎内部的查询缓存。它是有每一个存储引擎自己来实现的。
9. 执行器接受存储引擎层的结果，进行更新语句的操作，然后把更新后的数据，发送给存储引擎层。
10. 存储引擎层接收到执行器发送过来的更新数据后，做了如下几个动作
    1. 首选去更新缓存中的数据，避免后续有再次查询此次被修改的数据的时候，从缓存中返回给执行器的数据是旧的数据。
    2. 在日志缓存中记录redolog，并且把redolog的状态标记为待提交prepare状态。
    3. 返回消息给执行器，告知上面的操作已经完成。
11. 执行器在收到存储引擎层的更新消息后，做了如下几个动作
    1. 在binlog日志中记录此次的修改语句，便于以后通过binlog恢复数据的时候，不丢失此次修改操作。
    2. 发型消息给存储引擎层，告诉它可以把redolog的状态有prepare改为commit状态。
12. 存储引擎层接收到执行器的消息后，做了如下几个动作
    1. 更新日志缓存中的redolog的状态为commit状态。
    2. 发送消息通知执行器，redolog已经提交。
13. 执行器接收到存储引擎层的消息后，通知客户端，更新成功。至此，整个更新语句就执行完成了。

