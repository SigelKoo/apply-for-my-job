# 有一堆数据和两台服务器，如何保证数据均匀的存储在这两台服务器上？

方案1. 拿到一个数据，计算hash(key) % 2，如果等于0， 存到redis1中，否则存到redis2中

问题：扩容集群，增加redis3，要hash(key) % 3，要重新将原有数据重新分布

解决：使用hash一致性算法

使用hash一致性算法主要解决是当集群中有机器发生变动，不至于发生大量的数据移动问题。

# hash一致性算法原理

### 原理

有一个hash环，上面分布了2^32次方个点（0~2^32 - 1）

1. 三台redis服务器，计算hash(ip + 编号) % 2 ^ 32， 在环上一定能找到某个点

```
|------|
2      1
|      |
|---3--|
```

2. 数据应该存储在哪里，计算hash(key) % 2 ^ 32，在环上一定能找到某个点
3. 数据顺时针行走，遇到第一台服务器，就存储在某台服务器上
4. 新增一台redis4服务器，若redis4在redis1和redis3之间，只用将redis1到redis4之间的数据移动到redis4上（3中的数据不删除，数据有重叠，但是多一点也有备份）

```
|------|
2      1
|      |
|---3--4
```

### 为什么是2 ^ 32次方？

因为点越多，发生数据倾斜的概率越低

### 删除一台服务器怎么办？

将redis3进行移除，只用移动redis1到redis3中数据进行变动

```
|------|
2      1
|      |
|---3--|
```

```
|------|
2      1
|      |
|------|
```

# 带来数据倾斜的问题

数据倾斜问题：

1. 存储框架数据倾斜：一个存储设备存储了大量数据，其他存储设备存储少量数据
2. 计算框架数据倾斜：一个计算设备做了大量计算，其他计算设备做了少量计算

两个redis服务器节点离得很近就会导致数据倾斜

解决：

### 使用虚拟节点

将每台redis服务器虚拟成2个redis节点

```
|------|
1_1    1_0
|      |
|2_1---2_0
```

虚拟多少节点，看经验值，10台redis服务器，可以虚拟100-200节点，保证环上有1000-2000个虚拟节点；5台redis服务器，可以虚拟200-400节点，保证环上有1000-2000个虚拟节点

# 一致性哈希和哈希槽对比

## 一致性哈希

一致性hash是一个**0-2^32**的闭合圆，占用4个字节（拥有2^23个桶空间，每个桶里面可以存储很多数据，可以理解为s3的存储桶）所有节点存储的数据都是不一样的。计算一致性哈希是采用的是如下步骤：

1. 对节点进行hash，通常使用其节点的ip或者是具有唯一标示的数据进行hash(ip)，将其值分布在这个闭合圆上。
2. 将存储的key进行hash(key)，然后将其值要分布在这个闭合圆上。
3. 从hash(key)在圆上映射的位置开始顺时针方向找到的一个节点即为存储key的节点。如果到圆上的0处都未找到节点，那么0位置后的顺时针方向的第一个节点就是key的存储节点。

添加节点带来的影响

一致性hash的分布情况，箭头指向key的分布情况。

![img](https://upload-images.jianshu.io/upload_images/15579250-f49fddae261ec702.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

如果现在node2和node4节点中间增加一个node5节点，那么在node4和node2之间的这些数据要存储的节点就会有所变化。在图中的黄色区域的数据将会从原来的node4节点挪到node5节点。

![img](https://upload-images.jianshu.io/upload_images/15579250-66fd6ec17a466110.png?imageMogr2/auto-orient/strip|imageView2/2/w/704/format/webp)

**删除节点带来的影响**
以图1为基准，删除了node2节点后，原本在node2节点上的数据就会被重新定位node4上。这样就产生一个影响：原来node2的数据转移到node4上，这样node4的内存使用率会骤增，如果node2上存在热点数据，node4会扛不住甚至会可能挂掉，挂掉之后数据又转移给node3,如此循环会造成所有节点崩溃，也就是前面所说的雪崩的情况。

![img](https:////upload-images.jianshu.io/upload_images/15579250-1d8f855a7c595f07.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

**节点太少造成的影响**
节点太少的话可能造成数据倾斜的情况，如图中中只有俩节点，可能会造成大量数据存放在node A节点上，而node B节点存储很少的数据。

![img](https:////upload-images.jianshu.io/upload_images/15579250-d8a2b8e6e867c936.png?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp)

**虚拟节点**
为了解决雪崩现象和数据倾斜现象，提出了虚拟节点这个概念。就是将真实节点计算多个哈希形成多个虚拟节点并放置到哈希环上，**定位算法不变，只是多了一步虚拟节点到真实节点映射的过程**

以雪崩现象来说明：如下图节点real1节点又俩个虚拟节点v100和v101，real2有俩个虚拟节点v200和v201，real3节点有v300和v301俩个虚拟节点。



![img](https:////upload-images.jianshu.io/upload_images/15579250-66687a60a48e97e8.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)

当real1节点挂掉后，v100和v101节点也会随即消失，这时k1数据就会被分配到v301上，k4就会被分配到了v200上，这就解决了雪崩的问题，当某个节点宕机后，其数据并没有全部分配给某一个节点，而是被分到了多个节点。

![img](https:////upload-images.jianshu.io/upload_images/15579250-0556e3cc43e244f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1146/format/webp)

正因为加入了虚拟节点机制，数据倾斜的问题也随之解决

## 哈希槽

集群：是一个提供多个Redis（分布式）节点间共享数据的程序集。

集群部署：Redis 集群的键空间被分割为 16384 hash个槽（slot）， 集群的最大节点数量也是 16384 个

关系:cluster>node>slot>key

![img](https://img-blog.csdn.net/20180103174558651)

Redis Cluster在设计中没有使用一致性哈希（Consistency Hashing），而是使用数据分片引入哈希槽（hash slot）来实现；

一个 Redis Cluster包含16384（0~16383）个哈希槽，存储在Redis Cluster中的所有键都会被映射到这些slot中，集群中的每个键都属于这16384个哈希槽中的一个，集群使用公式slot=CRC16(key)/16384来计算key属于哪个槽，其中CRC16(key)语句用于计算key的CRC16 校验和。

按照槽来进行分片，通过为每个节点指派不同数量的槽，可以控制不同节点负责的数据量和请求数。

![img](https://img-blog.csdn.net/20180103174652115)

当前集群有3个节点,槽默认是平均分的：

节点 A （6381）包含 0 到 5499号哈希槽。
节点 B （6382）包含5500 到 10999 号哈希槽。
节点 C （6383）包含11000 到 16383号哈希槽。

这种结构很容易添加或者删除节点，比如如果我想新添加个节点D，我需要从节点 A、B、C中的部分槽到D上，如果我像移除节点A，需要将A中得槽移到B和C节点上，然后将没有任何槽的A节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。

## 数据迁移

数据迁移可以理解为slot(槽)和key的迁移，这个功能很重要，极大地方便了集群做线性扩展，以及实现平滑的扩容或缩容。

现在要将Master A节点中编号为1、2、3的slot迁移到Master B节点中，在slot迁移的中间状态下，slot 1、2、3在Master A节点的状态表现为MIGRATING（迁移），在Master B节点的状态表现为IMPORTING（入口）。

![img](https://img-blog.csdn.net/20180103174740149)

此时并不刷新node的映射关系。

## 键空间迁移

键空间迁移是指当满足了slot迁移前提的情况下，通过相关命令将slot 1、2、3中的键空间从Master A节点转移到Master B节点。此时刷新node的映射关系。

![img](https://img-blog.csdn.net/20180103174824673)

复制&高可用:
集群的节点内置了复制和高可用特性。
