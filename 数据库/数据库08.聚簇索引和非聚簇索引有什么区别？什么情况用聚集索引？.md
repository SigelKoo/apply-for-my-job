# 聚簇索引和非聚簇索引有什么区别？什么情况用聚集索引？

### 区别

**聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据

**非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

聚簇索引和非聚簇索引的区别取决于数据与索引是否存放在一起

**在innodb中**，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。**辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找**。

innodb只能有一个聚簇索引，向innodb插入数据时必须要包含一个索引的key值，若建表时没有索引，可以是主键->唯一键->自生成的6字节的rowid。多个聚簇索引数据要存放多份，10个聚簇索引要存十份，空间冗余，可以存在很多非聚簇索引。

![img](https://oscimg.oschina.net/oscnet/ce9bedd0dc9013e14e5f450e2149704bef5.jpg)

1. InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
2. 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

**聚簇索引具有唯一性**，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。

**表中行的物理顺序和索引中行的物理顺序是相同的**，**在创建任何非聚簇索引之前创建聚簇索引**，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一且非空的索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键（类似oracle中的RowId）**来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。

MyISAM使用的是非聚簇索引，**非聚簇索引的两棵B+树看上去没什么不同**，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于**索引树是独立的，通过辅助键检索无需访问主键的索引树**。

![img](https://oscimg.oschina.net/oscnet/59066cb190ec7579c34e2cd77a1f47e8b68.jpg)

**聚簇索引的优势：**

每次使用辅助索引检索都要经过两次B+树查找，看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？

1. 由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

2. 辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

   注：我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的缓存里，才会触发新的IO操作。

3. 因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）

4. 不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

### 聚簇索引缺点

1. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键
2. 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。
3. 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

| 情景               | 使用聚簇索引 | 使用非聚簇索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | √            | √              |
| 返回某范围内的数据 | √            | ×              |
| 一个或极小不同值   | ×            | ×              |
| 小数目的不同值     | √            | ×              |
| 大数目的不同值     | ×            | √              |
| 频繁更新的列       | ×            | √              |
| 外键列             | √            | √              |
| 主键列             | √            | √              |
| 频繁修改索引列     | ×            | √              |

**为什么主键通常建议使用自增id**

**聚簇索引的数据的物理存放顺序与索引顺序是一致的**，即：**只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的**。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

### 使用情况

1. 含有大量非重复值的列。
2. 使用BETWEEN,>,>=,<或<=返回一个范围值的列
3. 被连续访问的列
4. 返回大型结果集的查询
5. 经常被使用连接或GROUP BY子句的查询访问的列

#### 回表、索引覆盖、最左匹配、索引下推

例：一个table，四个字段id，name，age，gender，id主键，name索引列

```sql
SELECT * FROM table WHERE name = zhangsan
```

先根据name查询id，再根据id查询整行的记录，走了两棵B+树，这种现象叫回表，当根据普通索引查询到聚簇索引的key值之后，再根据key值在聚簇索引中获取所有行的记录。

如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做**回表**。

```sql
SELECT id, name FROM table WHERE name = zhangsan
```

根据name可以直接查询到id，name两个列的值，直接返回即可，不需要从聚簇索引中查询任何数据，此时叫做索引覆盖

```sql
SELECT * FROM table WHERE age = 5
```

不需要回表，age没有对应到索引值，不涉及到回表过程

```sql
SELECT * FROM table WHERE name = zhangsan AND age = 5
```

在没有索引下推的MySQL5.6版本之前，我们在索引内部首先通过name进行查找，在联合索引name，age树形查询结果可能存在多个，然后再拿着id值去回表查询，整个过程需要回表多次。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xMC8xNmVlZDY2N2YzOGZkM2Vl?x-oss-process=image/format,png)

在拥有索引下推的MySQL5.6版本之后，我们是在索引内部就判断age是否等于5，对于不等于5跳过。因此在联合索引name,age索引树只匹配一个记录，此时拿着这个id去主键索引树种回表查询全部数据，整个过程就回一次表。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xMC8xNmVlZDY2YWUwZDI2OThh?x-oss-process=image/format,png)

索引下推，SQL语句不用调整

```sql
SELECT * FROM table WHERE name = ? AND age = ?
```

在没有索引下推之前，先根据name从存储引擎中获取符合规则的数据，然后在server层对age进行过滤

有索引下推之后，根据name，age两个条件来从存储引擎中获取对应的数据

##### 一些小问题

创建表带索引SQL语句

```sql
alter table test add index idx(name);
```

设置主键要不要自增？

id最好自增，添加时因为B+树直接向后存储，不需要调整表，磁盘效率会变高

一般两种创建索引方式，添加数据时伴随索引/导入数据后，添加索引。并发请求不高，可以伴随索引添加数据，如果并发请求高，关闭索引提升数据。

刚开始没有主键，后面建立主键，聚簇索引会改变吗？会改变，变为主键。

