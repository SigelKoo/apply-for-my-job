# 生成分布式ID的方法

- 数据库自增ID
- 数据库水平拆分，设置初始值和相同的自增步长
- 批量申请自增ID
- UUID生成
- Redis的方式
- 雪花算法

## 数据库自增ID

在创建表的时候，指定主键auto_increment（自增）便可以实现

## 数据库水平拆分，设置初始值和相同的自增步长

「数据库水平拆分，设置初始值和相同的自增步长」是指在DB集群的环境下，将数据库进行水平划分，然后每个数据库设置「不同的初始值」和「相同的步长」，这样就能避免ID重复的情况

![1.png](http://dockone.io/uploads/article/20200720/415a500527a3c64743dca3d628f89961.png)

```
set @@auto_increment_offset = 1;     // 设置初始值
set @@auto_increment_increment = 2;  // 设置步长
```

扩容的情况是这种方法的一个缺点，上面我说的步长一般设置为数据库的数量，这是在确保后期不会扩容的情况下，若是确定后期会有扩容情况，在前期设计的的时候可以将步长设置长一点，「预留一些初始值给后续扩容使用」。

总之，这种方案还是优缺点的，缺点就是：「后期可能会面对无ID初始值可分的窘境，数据库总归是数据库，抗高并发也是有限的」。

## 批量申请自增ID

「批量申请自增ID」的解决方案可以解决无ID可分的问题，它的原理就是一次性给对应的数据库上分配一批的ID值进行消费，使用完了，再回来申请。

![2.png](http://dockone.io/uploads/article/20200720/bd156d3ade33cb0c6512b93ee634d075.png)

在设计的初始阶段可以设计一个有初始值字段，并有步长字段的表，当每次要申请批量ID的时候，就可以去该表中申请，每次申请后「初始值=上一次的初始值+步长」。

这样就能保持初始值是每一个申请的ID的最大值，避免了ID的重复，并且每次都会有ID使用，一次就会生成一批的id来使用，这样访问数据库的次数大大减少。

## UUID生成

UUID的核心思想是使用「机器的网卡、当地时间、一个随机数」来生成UUID。

使用UUID的方式只需要调用UUID.randomUUID().toString()就可以生成，这种方式方便简单，本地生成，不会消耗网络。

当时简单的东西，出现的问题就会越多，不利于存储，16字节128位，通常是以36位长度的字符串表示，很多的场景都不适合。

可以通过「当前的时间戳及机器mac地址」来生成，可以确保生成的UUID全球唯一。

## Redis的方式

Redis本身有incr和increby这样自增的命令，保证原子性，生成的ID也是有序的。

## 雪花算法

![3.png](http://dockone.io/uploads/article/20200720/2a152ac58344b739eb09671be7872e87.png)

第一位作为标识位，占用1bit，其值始终是0，没有实际作用。 

41bit是时间戳，毫秒级位单位，注意这里的时间戳并不是指当前时间的时间戳，而是值之间差（「当前时间-开始时间」）。开始时间一般是指ID生成器的开始时间，是由我们程序自己指定的。

后面的10bit：包括5位的「数据中心标识ID（datacenterId）和5位的机器标识ID（workerId）」，可以最多标识1024个节点（1<<10=1024）。

最后12位是序列号，12位的计数顺序支持每个节点每毫秒差生4096序列号（1<<12=4096）。

雪花算法使用数据中心ID和机器ID作为标识，不会产生ID的重复，并且是在本地生成，不会消耗网络，效率高，有数据显示，每秒能生成26万个ID。

雪花算法的计算依赖于时间，若是系统时间回拨，就会产生重复ID的情况。在雪花算法的实现中，若是其前置的时间等于当前的时间，就抛出异常，也可以关闭掉时间回拨。

# Redis如何实现分布式锁？

SETNX是SET if Not eXists（如果不存在，则 SET）的简写，设置成功就返回1，否则返回0。

![img](https://segmentfault.com/img/remote/1460000038988092)

key没有过期时间，这样一来，除非手动删除key或者获取锁后设置过期时间，不然其他线程永远拿不到锁。

给key加个过期时间总可以吧，直接让线程获取锁的时候执行两步操作：

```
`SETNX Key 1`
`EXPIRE Key Seconds`
```

因为获取锁和设置过期时间分成两步了，不是原子性操作，有可能**获取锁成功但设置时间失败**

SETEX，用法SETEX key seconds value。将值 value 关联到 key，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在，SETEX 命令将覆写旧值。

![img](https://segmentfault.com/img/remote/1460000038988090)

## 释放锁

释放锁的命令就简单了，直接删除key就行，但我们前面说了，因为分布式锁必须由锁的持有者自己释放，所以我们必须先确保当前释放锁的线程是持有者，没问题了再删除，这样一来，就变成两个步骤了，似乎又违背了原子性了，怎么办呢？

用lua脚本把两步操作做拼装，就好像这样：

```
`if redis.call("get",KEYS[1]) == ARGV[1]`
`then`
 `return redis.call("del",KEYS[1])`
`else`
 `return 0`
`end`
```

KEYS[1]是当前key的名称，ARGV[1]可以是当前线程的ID(或者其他不固定的值，能识别所属线程即可)，这样就可以防止持有过期锁的线程，或者其他线程误删现有锁的情况出现。