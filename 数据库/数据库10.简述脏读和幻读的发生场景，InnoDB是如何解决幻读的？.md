# 简述脏读和幻读的发生场景，InnoDB是如何解决幻读的？

有以下SQL语句：

```
mysql> create table city(
    -> id int(10) auto_increment,
    -> name varchar(30),
    -> primary key (id)
    -> )engine=innodb charset=utf8mb4;

insert into city(name) values('武汉市');

mysql> select * from city;
+----+-----------+
| id | name |
+----+-----------+
| 1 | 武汉市 |
+----+-----------+
```

#### 脏读（Dirty Read）

一个事务读到了另一个未提交事务修改过的数据

![从根上理解MySQL事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/04/32495/Wcv8DTijTL.png!large)

会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现）

#### 不可重复读（Non-Repeatable Read）

一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现），由**update、delete**引起。

![从根上理解 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/YdNemia6wc.png!large)

会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。

#### 幻读（Phantom）

一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现），由**insert**引起。

![从根上理解 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/04/32495/0sCtxw1Jno.png!large)

会话A开启一个事务，查询id>0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id>0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。

### InnoDB是如何解决幻读的

数据库有两种读，两种读出的数据版本不一样，所以也称为MVCC，即多版本并发控制

- 快照读

  ```sql
  select * from where xxx  --这种形式的都是快照读
  ```

- 当前读

  ```sql
  update, insert, delete, select xx from xx for update, lock in share mode --都是当前读
  ```

  当前读会等待，不会返回数据的历史版本

MySQL解决方案

- 多版本并发控制（MVCC，快照读）
- next-key锁（当前读）

MVCC是多版本并发控制实现，通过保存数据在某个时间点的快照来实现的。一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。

next-key

InnoDB是一个支持行锁的存储引擎，有三种排它锁（X锁）：

- Record Lock：行锁，单个行记录上的锁。
- Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止幻读、防止间隙内有新数据插入、防止已存在的数据更新为间隙内的数据。
- Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。InnoDB默认加锁方式是next-key 锁。

next-key 锁是mysql默认的锁，是记录锁和在此索引记录之前的gap上的锁的结合，这个锁的作用是为了防止幻读，导致主从复制的不一致。

比如有一个表，id列上有90,100,102。

当我们执行select * from order where id=100 for update 时，mysql会锁住90到102这个区间。当我们执行 select * from order where id >100 for update时，这时next-key锁就派上用场了。

索引扫描到了100和102这两个值，但是仅仅锁住这两个值是不够的，因为当我们在另一个会话插入id=101的时候，就有可能产生幻读了。所以mysql必须锁住[100,102)和[102,无穷大）这个范围，才能保证不会出现幻读。



