# 左连接和右连接区别

我们来举个例子。天庭上面有一个管理系统：管理系统有个主表：主表记录着各个神仙的基本信息（我们把它当成表A）。还有个表记录着他们这个神仙的详细信息（我们把它当成表B）。

| IDA  | NAME         | position |
| :--- | :----------- | :------- |
| 1    | 李靖         | 托塔天王 |
| 2    | 值年神李丙   | 四值功曹 |
| 3    | 增长天王     | 四大天王 |
| 4    | 青龙孟章神君 | 四方神   |

表B的信息为（此神仙有无犯过天条）

| IDB  | Name | THINGS       |
| :--- | :--- | :----------- |
| 1    | NO   |              |
| 3    | YES  | 上班玩忽职守 |
| 4    | NO   |              |
| 5    | NO   |              |
| 6    | YES  | 调戏嫦娥妹妹 |

刚好赶上天庭蟠桃会，王母就让你统计下，参加蟠桃会的人有无犯事的记录，有的话就取消他参加宴会的资格。

#### 使用左连接

```sql
select A.* ,B.* from A left outer join B on (A.IDA = B.IDB)
```


| IDA  | NAME         | position | IDB  | Name | THINGS       |
| :--- | :----------- | :------- | :--- | :--- | :----------- |
| 1    | 李靖         | 托塔天王 | 1    | NO   |              |
| 2    | 值年神李丙   | 四值功曹 | NULL | NULL | NULL         |
| 3    | 增长天王     | 四大天王 | 3    | YES  | 上班玩忽职守 |
| 4    | 青龙孟章神君 | 四方神   | 4    | NO   |              |

结果就如同这样，表B中的IDB=5和6这条数据没有展示出来。且IDA=2这条数据在表B中取null，左连接取的就是FROM后面该表中的所有数据作为查询结果。

#### 使用右连接

```sql
select A.* ,B.* from A right outer join B on (A.IDA = B.IDB)
```

| IDA  | NAME         | position | IDB  | Name | THINGS       |
| :--- | :----------- | :------- | :--- | :--- | :----------- |
| 1    | 李靖         | 托塔天王 | 1    | NO   |              |
| 3    | 增长天王     | 四大天王 | 3    | YES  | 上班玩忽职守 |
| 4    | 青龙孟章神君 | 四方神   | 4    | NO   |              |
| NULL | NULL         | NULL     | 5    | NO   |              |
| NULL | NULL         | NULL     | 6    | YES  | 调戏嫦娥妹妹 |

这个时候王母一看。什么，居然有人调戏 嫦娥，而且还查不到这个人？王母就会大发雷霆然后限你一天之内找到这个人。

### 使用内连接

使用内连接与自然连接得到结果相同

```sql
select * from A,B where A.IDA = B.IDB
```

| IDA  | NAME         | position | IDB  | Name | THINGS       |
| :--- | :----------- | :------- | :--- | :--- | :----------- |
| 1    | 李靖         | 托塔天王 | 1    | NO   |              |
| 3    | 增长天王     | 四大天王 | 3    | YES  | 上班玩忽职守 |
| 4    | 青龙孟章神君 | 四方神   | 4    | NO   |              |

>左连接：左边有的，右边没有的为null
>
>右连接：左边没有的，右边有的为null
>
>内连接：显示左边右边共有的

#### 一些小问题

```sql
SELECT * FROM A LEFT JOIN B ON A.id= B.id AND A.`name` = B.`name`  
```

会查询出 A 表中所有的数据消息和满足 B 表中的数据 

更改为

```sql
SELECT * FROM A LEFT JOIN B ON A.id= B.id WHERE A.`name` = B.`name`
```

会查询出同时满足 A 表和 B 表中的数据

>  SQL 中的 ON 和 WHERE 的 区别
>
> 数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户
>
> 在使用LEFT JOIN时，ON和WHERE条件的区别如下：
>
> 1. ON条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录
> 2. WHERE条件是在临时表生成好后，再对临时表进行过滤的条件，这时已经没有LEFT JOIN的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉



> **on和where**
>
> 所有的查询都回产生一个中间临时报表，查询结果就是从返回临时报表中得到。on和where后面所跟限制条件的区别，主要与限制条件起作用的时机有关，on根据限制条件对数据库记录进行过滤，然后生产临时报表；而where是在临时报表生产之后，根据限制条件从临时报表中筛选结果。
>
> 总结：在左外连接中，on会返回左表中的所有记录；而where中，此时相当于inner join，只会返回满足条件的记录。
> 速度：因为on限制条件发生时间较早，产生的临时报表数据集要小，因此on的性能要优于where。

>**having和where**
>
>having和where的区别也是与限制条件起作用时机有关，having是在聚集函数计算结果出来之后筛选结果，查询结果只返回符合条件的分组，having不能单独出现，只能出现在group by子句中。而where是在计算之前筛选结果，如果聚集函数使用where，那么聚集函数只计算满足where子句限制条件的数据。
>
>总结：where即可以和select等其他子句搭配使用，也可以和group by子句搭配使用，where的优先级要高于having。
>速度：因为where在聚集函数之前筛选数据，having在计算之后筛选分组，因此where的性能要优于having。