# 进程通信中的管道实现原理是什么？

从技术上讲，自从可以在进程间传递描述符后，管道也能用于无亲缘关系的进程间。然而通常的说，管道通常用于具有共同祖先的进程间通信。

![preview](https://pic1.zhimg.com/v2-c041258f7943d00212d5b19baa0a86a4_r.jpg)

## 管道的特点

（1）只能用于具有共同祖先的进程（具有亲缘关系的进程）之间通信，当然除了命名管道，命名管道有一个路径名与之关联，命名管道允许无亲缘关系的进程访问同一个FIFO；通常，一个管道由一个进程创建，然后该进程调用fork，此后，父子进程之间就可应用该管道

（2）管道的进程间通信是基于字节流的

（3）管道是基于文件形式的，自带同步互斥机制，并且只能进行单向传输

（4）一般而言，进程退出，管道释放，所以管道的生命周期是随进程的

## 管道

所有样式的Unix提供管道。它由pipe函数创建，提供一个单路（单向）数据流。


![img](https://pic3.zhimg.com/80/v2-3ed2a3744148fe67eb822a0b33bcd7f6_720w.jpg)

调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过pipefd参数传出给用户程序两个文件描述符，pipefd[0]指向管道的读端，fpipefd[1]指向管道的写端。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0])或者write(filedes[1])向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。

## 用途

### 父进程fork出子进程

管道的经典用途是以下方式为两个不同进程（一个是父进程一个是子进程）提供进程间通信手段。首先，由一个进程（它将成为父进程）创建一个管道后调用fork派生一个自身的副本，如下图所示：



![img](https://pic1.zhimg.com/80/v2-9204e51412b9cb5c215cefd32f430680_720w.jpg)



父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。那么这样在父进程和子进程中都有两个文件描述符分别指向管道的写端和读端。父进程和子进程都能对管道进行读写操作。

### 父进程关闭fd[0] 子进程关闭fd[1]



![img](https://pic3.zhimg.com/80/v2-6ede73206f8f19a8c031694fde43ea66_720w.jpg)



父进程关闭在这个管道的读出端fd[0]，子进程关闭这个管道的写入端fd[1]。这就在父进程和子进程之间提供了一个单向数据流。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。

# 命名管道（FIFO）

我们无法在无亲缘关系的两个进程之间创建一个管道并将它作为IPC通道（不考虑描述符的传递）。管道的缺点就是只能在有亲缘关系的进程间进行通信，针对这个缺陷，又提出来了命名管道（FIFO）的概念。FIFO不同于管道之处在于它提供一个路径名与之关联,以FIFO的文件形式存储于文件系统中。**命名管道是一个设备文件，因此，即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。**

**FIFO指的就是先进先出（first in,first out）**，Unix中的FIFO类似管道。他是一个单向（半双工）的数据流。不同于管道的是，每个FIFO有一个路径与之相连，从而允许无亲缘关系之间的进程访问同一个FIFO。FIFO也称为有名管道（named pipe）。

![img](https://pic4.zhimg.com/80/v2-5ab6e20896bf59f7973f688801351c3b_720w.jpg)

其中pathname是一个普通的Unix路径名，它是该FIFO的名字。

mode参数指的是文件权限位，类似于open的第二个参数。

在创建一个FIFO后，它必须或者打开来读或者来写，所用的可以是open函数，也可以是某个标准I/O打开函数，列如fopen。FIFO不能打开来既可以读又可以写，因为他是半双工的。对管道或者FIFO的write总是向末尾添加数据，对他们的read总是从开头添加数据。如果对管道或者FIFO调用lseek，这就返回错误。

# 命令管道和管道的区别

命名管道创建完成后就可以使用，其使用方法与管道一样；
区别在于：
（1）命名管道使用之前需要使用open()打开。这是因为：命名管道是设备文件，它是存储在硬盘上的，而管道是存在内存中的特殊文件。
（2）但是需要注意的是，命名管道调用open()打开有可能会阻塞，但是如果以读写方式（O_RDWR）打开则一定不会阻塞；
（3）命名管道以只读（O_RDONLY）方式打开时，调用open()的函数会被阻塞直到有数据可读；
（4）命名管道如果以只写方式（O_WRONLY）打开时同样也会被阻塞，知道有以读方式打开该管道。
