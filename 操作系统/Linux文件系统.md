## 硬盘的物理结构

### 硬盘结构概述

![clipboard.png](https://segmentfault.com/img/bVbdD1V?w=1290&h=818)

其中：

- 每个盘片有两面，两面都可以存储数据。
- 每个盘面都有一个磁头，用于存取数据。
- 所有磁头都是固定的，一起做物理移动。但是每次只有一个磁头执行存取数据的任务，选择使用哪个磁头是由系统控制的。磁头间的切换非常迅速，而磁头摆动寻道则比较慢。
- 磁头摆动，找到要读取数据所在的磁道；盘片通过转动，将数据“送到”磁头下。

### 磁头数、磁道、柱面、扇区

![clipboard.png](https://segmentfault.com/img/bVbdD2Z?w=868&h=408)

- **磁头数：** 每个盘面都有一个磁头，因此`磁头数 = 盘面数`。
- **磁道：** 上以盘片轴心为圆心，不同半径的同心圆称为磁道，磁道不是真正肉眼可看见的一道一道“坑”，而是被磁盘上被磁化的区域，磁道之间有一定的间隙，以免磁道之间磁介质相互影响。
- **扇区：** 每个磁道被等分为若干个弧段（扇区），每个扇区可以存放512个字节的数据。**扇区是磁盘驱动器向磁盘读写数据的最小单元。**
- **柱面：** 不同盘片半径相同的磁道组成的一个“柱面”。

## CHS编号

所谓硬盘的CHS，即Cylinder（柱面）、Head（磁头）、Sector（扇区）。每个柱面、磁头、扇区都有自己的编号。

### 磁道编号规则

- **磁头编号：** 从上到下，分别为磁头0号，磁头1号......
- **柱面编号：** 最外圈的柱面编号为0，往里依次递增1，2，3.....

### 扇区编号规则

每个磁道都可以被分为若干个扇区，假设有18个扇区，编号依次为1，... 18。这里的1...18在一个磁道中是唯一的，但不同磁道之间会重复。因此，要确定一个扇区在硬盘（多个盘片）中的具体位置，则需要结合`柱面号/磁头号/扇区号`来确定——`绝对扇区编号`，或者是为整个硬盘的所有扇区分配一个唯一的编号——`DOS扇区编号`（也称为`相对扇区编号`或逻辑扇区编号）。

- **绝对扇区：** 由`柱面号/磁头号/扇区号`唯一确定。
- **DOS（Disk Operating System）扇区（逻辑扇区）：** 磁盘操作系统为了管理方便，会将*柱面号/磁头号/扇区号*确定的扇区编号转换为易于管理和计算的单一数字编号，称为相对扇区编号或逻辑扇区编号。DOS扇区编号是从柱面0/磁头0/扇区1开始的，编号为0，依次递增，即柱面0/磁头0/扇区18的DOS扇区编号为18；柱面0/磁头1/扇区1的DOS扇区编号为19...。每个分区的第一个扇区的逻辑扇区编号为0。

### 通过CHS计算硬盘容量

硬盘存储容量＝磁头数×柱面数×每个磁道扇区数×每个扇区字节数

## 磁盘存储划分

### 第一个扇区存储的数据

硬盘的第一个扇区（逻辑编号为0）可以说是整个硬盘最重要扇区了，它主要存储两大信息：

- **主引导分区（Master Boot Record，MBR）：** 存放引导加载程序，大小为446字节。
- **分区表（partition table）：** 记录整块硬盘分区的状态，占64字节。

### 硬盘分区

分区的最小单位为`柱面（Cylinder）`，也就是说，分区其实就是指定从第几个柱面到第几个柱面属于哪个区。

假设硬盘有400个柱面，平均分为4个区（C、D、E、F盘），则第四个分区F的柱面范围是第301号到第400号柱面。

分区表中，记录的就是就是每个分区的起始柱面号和结束柱面号。因为分区表只有64字节，因此最多只能容纳4个分区的记录（硬盘默认），要想分更多的去，则需要通过扩展分区来创建`逻辑分区`。

## 开机流程

1. 加载BIOS：

    

   BIOS（Base Input Output System，基本输入输出系统，读做/'baious/）是硬件厂商写入到主板ROM里的一个程序，电脑开机时，会最先执行BIOS。开机后，进入BIOS界面，如下：

   ![clipboard.png](https://segmentfault.com/img/bVbdEpo?w=810&h=598)

2. **MBR：** BIOS在执行的过程中，会根据用户设置（即在BIOS的Boot界面选择的优先启动项，U盘/硬盘/光驱），如果硬盘的优先级最高，则计算机会从硬盘的第一个扇区的MBR中的读取`引导加载程序（Boot Loader）`。和**BIOS**一样，主引导分区MBR是硬件本身会支持的东西。

3. **引导加载程序：**`引导加载程序（Boot Loader）`是用于读取操作系统内核文件的一个小软件，不同的操作系统有各自的引导加载程序。每个分区都可以有自己的文件系统，有自己的`引导扇区`，在启动的过程中，用户可以选择是直接加载引导程序所在分区的操作系统，还是将引导加载功能交给各分区引导扇区中的加载程序。boot loader的功能主要有：

   - 提供菜单：让用户选择不同的开机选项，是多重引导的重要功能。
   - 载入内核文件：直接指向可开机的程序区段，开始操作系统。
   - 转交其他loader: 将引导加载功能转交给其他loader负责。

4. **操作系统内核文件：**最后，引导加载程序加载操作系统的内核文件，启动操作系统！

### 要点

1. 每个分区都有自己的引导扇区（boot sector）。
2. 实际可开机的操作系统内核文件是存放在各个分区内的，如在C盘安装Windows系统，在D盘安装Linux操作系统。
3. 引导加载程序（boot loader）只会认识自己所在分区内的可开机内核文件，以及其他boot loader（相当于一个指针，指向其他loader）。
4. loader可以直接指向或者间接地讲管理权交给其他loader。
5. 一点经验：如果要安装多系统，最好先安装Windows，后安装Linux。因为Windows会强制覆盖MBS，也就是说，如果你先装Linux再装Windows，MBR中就只有Windows的相关选项（Linux的被覆盖掉了）。而Linux则不会强制覆盖MBR，你可以选择将Linux的引导程序安装在MBR或者其所在分区的引导扇区中；你也可以在Linux的引导程序中设置Windows的开机选项。

## 磁盘存储数据的形式

磁盘以`二进制`的形式存储数据。我们平时编程过程中读写文件模式可能有文本形式/二进制形式，文件也有文本文件、音频文件、图片文件...等各种不同类型的文件，但这些文件在磁盘上都是以二进制的方式存储。

可以想像一下，二进制中的0，对应磁盘上的一个“凹”点，1对应磁盘上的一个“凸”点。（只是形象比喻，不是真的凹凸）。

## 文件（目录）存储方式

linux中，磁盘（硬盘）上的存储划分如下图所示：

![clipboard.png](https://segmentfault.com/img/bVbdHKE?w=1446&h=436)

- **MBR：** 主引导分区。
- **自举块（引导分区Boot Sector）：**分区中文件系统自身引导程序存放的地方。
- **超级块（Super block）：** 记录整个文件系统相关的信息的地方，它记录的信息主要有：block与inode的总量、使用量、剩余量，文件系统的挂载时间，最近一次写入数据的时间等。
- **柱面组（块组）** 每个柱面为一个柱面组（组号与柱面号一致），一个分区包含多个柱面。
- **配置信息**：不详。
- **i节点位图（inode bitmap）：**每个inode结点对应位图中的一个位（这样一个字节可表示8个inode的使用情况），每个位值为0或1，表示该位所处下标对应的inode有没有被使用。
- **块位图（block bitmap）：**每个数据块或目录块都对应着块位图中的一个位，位的下标和块编号一一对应，每个位的值为0或1，表示该块是否已被使用。
- **i节点表（数组）（inode table）：**每个文件或者目录都有对应的一个inode，inode放在inode table中，包括inode的编号及其对应的信息。
- **i节点（inode）：** 存储文件相关信息（不包括文件名）。
- **数据块（data block）：** 存储文件具体内容。
- **目录块：** 特殊一点的数据块，存放`inode编号--文件（目录）名`。

#### inode详解

inode的主要记录了文件的属性以及该文件实际数据是放在哪几号数据块（或目录块）中，具体包含以下信息：

- 文件的访问模式（r/w/x）
- 文件所有者和组（owner/group）
- 文件大小
- 文件创建或状态改变的时间（ctime）
- 最近一次的读取时间（atime）
- 最近修改的时间（mtime）
- 定义文件特性的标志（flag）
- 文件真正内容指向的数据块（pointer）

另外，inode的特征有：

- inode的数量和大小在磁盘格式化的时候就已经固定了，除非再次格式化重新设置，否则不可改变。
- 每个inode的大小均为128Bytes。
- 每个文件仅占用一个inode。
- 文件系统能够创建（存储）的文件数量和inode的数量有关，也和磁盘大小（数据块数量）有关。
- 系统读取文件时，需要先找到inode，分析inode记录的权限与用户是否符合，若符合才可以开始实际读取数据块中的内容。
- 为了解决inode数量可能不够用的问题，操作系统将inode记录block号的区域定义为12个直接、1个间接、1个双间接、1个三间接的记录区。
- 文件IO编程中常说的文件句柄，其实就是inode编号。

## 文件读取过程

已读取文件`/var/log/message`为例，讲解读取文件messages时，从磁盘中查找/读取文件内容的过程。

![clipboard.png](https://segmentfault.com/img/bVbdHN9?w=1758&h=702)

1. 首先系统通过挂载信息（在超级块中，位置固定）找到根目录(/)的inode编号，根目录对应的inode是固定的（通常为2号）。
2. 根据根目录的inode编号（2号），在inode table中找到对应的inode信息，从inode信息中找到存储根目录信息的目录块编号，根据编号找到数据块，如图中标记为‘/’的方格，该目录块存储的信息如图中的dentry所示。
3. 从目录块中存储的信息中，找到文件名（目录名）为var所对应的inode编号（2667711）。
4. 在inode table中找到编号为2667711的inode信息，从该inode信息中，找到var目录存放的数据块。从var数据块存储的信息中，找到log目录对应的inode编号（267850）。
5. 重复上述步骤，直至找到message文件对应的inode结点，根据inode结点中记录的message文件内容对应的数据块，从数据块中读取内容。

## 扇区、块（簇/数据块）、页

在操作系统数据交互过程中，经常听到`扇区、块（簇/数据块）、页`这几种单位，他们在数据交互过程中的意义为：

- **扇区：** 磁头从磁盘中读取数据的最小单位，即磁头每次从磁盘中读取数据，都是一个扇区一个扇区读的。
- **块（簇）：** 操作系统与磁盘（硬盘）交互的最小数据单元（在linux系统中称为块，在windows系统中称为簇）。操作系统从硬盘中拿一**块**数据，即完成一次磁盘IO。块（数据块）的大小在硬盘格式化时被指定，一般有1K，2K，4K（最常用）。如果块的大小设置为4K，那么磁盘要读取8个扇区之后，才将数据块传给操作系统。另外，数据块也是DOS下数据存储的最小单元。例如，如果一个文件的大小为1K，而块的大小为4K，那么该文件还是会占用一个块，块中剩下的3K被空闲出来，不能用于存储其他数据。因此，设置块的大小时，需要考虑要存储文件的大小。
- **页：** 操作系统访问内存时的最小单元，一般系统页的大小为4K（或者更大）。操作系统访问内存中的数据时，如果发现内存中没有哪个`页`可以提供该数据，那么会发生缺页，系统通过页替换（从硬盘中读取数据）的方式，将数据从硬盘读取到内存页中，再返回给调用者。

总的说来，主要就是不同系统、设备间数据交互时，使用了不同的机制和概念。其中磁盘内部（磁盘驱动程序从磁盘）读取数据时，以扇区为单位；操作系统从磁盘读取数据时，以块为单位；操作系统从内存读取数据时，以页为单位。

## 操作系统对文件存取操作的优化

并非每次读、写文件操作都会真正地从磁盘读出或写入，那样性能难以接受。为此操作系统使用了一系列机制，提升了文件IO的性能。

#### 缓存

不管是硬盘还是操作系统，都会对从磁盘片中读取的数据进行缓存。硬盘中的缓存一般会比较小，如十几M，操作系统中的缓存则可能大很多。系统会将常用的文件数据放到主存储器的缓冲区，以加速文件系统的读写。一般情况下，只要系统的内存够用，系统会尽可能多的将磁盘中常用的文件缓存到内存中，直至内存耗尽（这是正常现象）。比如，如果你发现在电脑上读取文件的速度达到了2G每秒，那肯定不是真的从磁盘读取的，而是从缓存读取的。所以要测试磁盘真正的读数据的速度，需要先清空系统的缓存。

#### 异步处理

当系统加载一个文件到内存后，如果该文件没有被改动过，则在内存区段的文件数据会被标记为`clean`，如果是被改动了，则会标记为`dirty`。此时所有的文件操作还是在内存中进行，并没有写入到磁盘中。系统会不定时的将内存中设置为`dirty`的数据写回到磁盘，以保持磁盘与内存数据的一致性。这个过程是异步的。你也可以`sync`命令，将内存中的数强制写回到硬盘。

另外，要注意的是，在正常关机的情况下，关机命令会主动调用sync来将内存中的数据写入到磁盘内，但是如果非正常关机（如断电、死机），由于数据没有来得及写入到磁盘，因此重新启动可能会花费很长的时间进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损坏）。

