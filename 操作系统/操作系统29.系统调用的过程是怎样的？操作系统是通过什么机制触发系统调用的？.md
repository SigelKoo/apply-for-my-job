# 系统调用的过程是怎样的？操作系统是通过什么机制触发系统调用的？

### 在用户空间中的处理过程

当read系统调用调用发生时，库函数在保存read系统调用号以及参数后，陷入0x80 中断。这时库函数工作结束。Read系统调用在用户空间中的处理也就完成了。Linux 系统调用（SCI，system call interface）的实现机制实际上是一个多路汇聚以及分解的过程，该汇聚点就是0x80 中断这个入口点（X86 系统结构）。也就是说，所有系统调用都从用户空间中汇聚到 0x80中断点，同时保存具体的系统调用号。当 0x80 中断处理程序运行时，将根据系统调用号对不同的系统调用分别处理（即调用不同的内核函数处理）。

### 在内核空间中的处理过程

0x80中断处理程序接管执行后，先检察其系统调用号，然后根据系统调用号查找系统调用表，并从系统调用表中得到处理 read 系统调用的内核函数sys_read ，最后传递参数并运行 sys_read 函数。至此，内核真正开始处理 read系统调用（sys_read 是 read 系统调用的内核入口）。

### 在内核空间中处理的层次模型

#### 操作系统处理磁盘读请求的过程：

![image.png](https://bbs-img.huaweicloud.com/data/attachment/forum/202001/02/134449w3hw2y4nkoodtbfv.png)

1. 虚拟文件系统层：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，所以可以把设备抽象成文件，使得操作设备就像操作文件一样简单。

2. 具体的文件系统层：每种具体的文件系统都定义了自己的操作集合。

3. 磁盘缓存层：引入磁盘缓存层的目的是为了提高操作系统对磁盘访问的性能。Cache层在内存中缓存了磁盘上的部分数据，当数据的请求到达时，如果在cache中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。

   磁盘缓存（磁盘快取）：磁盘的缓存，实际上就是将下载到的数据先保存于系统为软件分配的内存空间中（这个内存空间又被称为内存池，使用的材料为DRAM），当保存到内存池中的数据达到一个程度时，便将数据保存到硬盘中。这样可以减少实际的磁盘操作，有效的保护磁盘免于重复的读写操作而导致的损坏。磁盘缓存是为了减少CPU透过I/O读取磁盘机的次数，提升磁盘I/O的效率，用一块内存来储存存取较频繁的磁盘内容；因为内存的存取是电子动作，而磁盘的存取是I/O动作，感觉上磁盘I/O变得较为快速。

   内存缓存：内存的缓存，它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。当CPU处理数据时，它会先到cache中去寻找，如果数据因之前的操作已经读取而被暂存其中，就不需要再从随机存取存储器中读取数据，以达到让数据访问的速度适应CPU的处理速度。其原理基于局域性，即一定程序执行时间和空间内，被访问的代码集中于一部分。

4. 通用块层：接收上层发出的磁盘请求，并最终发出IO请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。

5. IO调度层：接收通用块层发出的IO请求，缓存请求并试图合并相邻的请求（如果这两个请求的数据在磁盘上是相邻的）。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的IO请求。

6. 块设备驱动层：驱动层中的驱动程序对应具体的物理块设备。它从上层中取出IO请求，并根据该IO请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。

7. 物理块设备层：设备层中都是具体的物理设备。定义了操作具体设备的规范。

函数调用图：

​    ![image.png](https://bbs-img.huaweicloud.com/data/attachment/forum/202001/02/134647wjrjfngy4bliybae.png)

