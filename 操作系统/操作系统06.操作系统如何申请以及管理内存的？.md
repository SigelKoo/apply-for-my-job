# 操作系统如何申请以及管理内存的

## 操作系统申请内存

![img](https://img-blog.csdn.net/20171027133933148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM2MTQ1NTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

#### brk系统调用

brk是将数据段(.data)的最高地址指针_edata往高地址推

##### 情况1

malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：

![img](https://pic3.zhimg.com/80/v2-79b4a90a85756b3c9fbb3f1f8613059a_720w.jpg)

#### mmap系统调用

mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存

##### 情况2

malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配（对应独立内存，而且初始化为0）

![img](https://pic4.zhimg.com/80/v2-f3a3dc92acc7f0aa5ef700bb61c29a93_720w.jpg)

##### 情况3

调用free

![img](https://pic1.zhimg.com/80/v2-a3ff41a835531fbf3703fa10bd45696c_720w.jpg)

## 操作系统管理内存

### 内存空间的分配与回收

操作系统记录哪些内存区域已经被分配，哪些还处于空闲

当进程运行结束后，如何将进程占用的内存空间回收

一个进程可以放在内存中很多位置，应该放在哪里

#### 连续分配管理方式

- 单一连续分配

  在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。

  内存中只能有一道用户程序，用户程序独占整个用户区空间。

  优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护

  缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。（适用于早期操作系统）

- 固定分区分配

  将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。固定分区分配有分区大小相等和分区大小不等两种。

  分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）

  分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

  优点：实现简单，无外部碎片。
  缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。

- 动态分区分配

  动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

  系统要用什么样的数据结构记录内存的使用情况？

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210213201514821.png)

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210213201605871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoYW5neGluZ3lh,size_16,color_FFFFFF,t_70)

  当很多个空间分区都能满足需求时，应该选择哪个分区进行分配？

  动态分区分配算法：

  - **首次适应算法**

    算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

    如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表)，找到大小能满足要求的第一个空闲分区。

    优点：实现简单

    缺点：会有内存碎片化问题, 而且每次找到合适位置效率低

  - **最佳适应算法**

    算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
    如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
    缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。

  - **最坏适应算法**

    算法思想：为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

    如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

    缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。

  - **邻近适应算法**

    算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

    如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210213202112575.png)

    首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）

    邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）综合来看，四种算法中，首次适应算法的效果反而更好。

  如何进行分区的分配与回收操作？情况1：回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个；情况2：回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个；回收区的前后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个；回收区的前后都没有相邻的空闲分区，新增一个表项。

  动态分区分配没有内部碎片，但是有外部碎片。

  内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。

  外部碎片，是指内存中的某些空闲分区由于太小而难以利用。

  如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑技术来解决外部碎片。

#### 非连续分配管理方式

##### 基本分页存储管理

将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号**从0开始**。

将进程的逻辑地址空间也分为**与页框大小相等**的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是**从0开始**。
（注：进程的最后一个页面可能没有一个页框那么大。因此，**页框不能太大，否则可能产生过大的内部碎片**）

操作系统**以页框为单位为各个进程分配内存空间**。进程的每个页面分别放入一个页框中。也就是说，**进程的页面与内存的页框有一一对应**的关系。各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

###### 页表

操作系统会为每个进程建立一张页表，用来记录本进程内每个页面在内存中存放的位置；

1. 一个进程对应一张页面
2. 进程的每一页应用一个页表项
3. 每个页表项由页号和块号组成
4. 页面记录进程页面和实际存放的内存的内存块之间的对应关系
5. 每个页表项的长度是相同的，页号是隐含的

![image.png](https://img-blog.csdnimg.cn/img_convert/633593a3f8b3eab5e62269c5860675c9.png)

![image.png](https://img-blog.csdnimg.cn/img_convert/a1213a8188f901d4e148e8075c2c5f2f.png)

###### 基本地址变换机构

基本地址变换机构是用于实现逻辑地址到物理地址转换的一组硬件机构。 基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。
通常会在系统中设置一个页表寄存器PTR，存放页表在内存中的起始地址F和页表长度M。其中页表长度是指这个页表中总共有几个页表项，即总共有多少页；页表项长度是指每个页表项占多大的存储空间；页面大小指一个页面占多大的存储空间；
进程未执行时，页表的起始地址和页表长度放在进程控制块PCB中；当进程被调度时，操作系统内核会把他们放到页表寄存器中。

![image.png](https://img-blog.csdnimg.cn/img_convert/bc3834a8f816e91de4117250e64fbea5.png)

###### 具有快表的地址变换机构

快表，又称为联想寄存器TLB，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

- 因为局部性原理，一般来说快表的命中率可以达到90%以上。

![image.png](https://img-blog.csdnimg.cn/img_convert/e6737d9a6e48897ca79f07c5af6dbb92.png)

##### 基本分段存储管理

进程的地址空间，按照程序程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址。

内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各个段之间可以不相邻。

![image.png](https://img-blog.csdnimg.cn/img_convert/9b5ba02769075eabe2bde99d6c0c0495.png)

![image.png](https://img-blog.csdnimg.cn/img_convert/421195017b6d36291a8cbba7415b8807.png)

![image.png](https://img-blog.csdnimg.cn/img_convert/7b9467c2336cf9de7ab193c149d3834f.png)

##### 页式与段式区别

- 分页是系统行为，对用户不可见；
  分段是对用户可见的，用户编程时需要显式的给出段名。
- 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址；
  分段的用户进程地址空间是二维的，程序员在标识一个地址时，纪要给出段名，也要给出段内地址；
- 分段比分页更容易实现信息的共享和保护。因为可以显式的按段进行共享。
- 分段和分页访问一个逻辑地址都需要两次访存；分段存储中也可以引入快表；

![image.png](https://img-blog.csdnimg.cn/img_convert/7743f9aee5eafa05d1c5e30bbb9996bc.png)

##### 段页式存储管理

综合了分页式和分段式的优缺点；

将进程按照逻辑模块分段，再将各段分页，再将内存空间分为大小相同的内存块，然后进程内各个分页装入各个内存块中。

![image.png](https://img-blog.csdnimg.cn/img_convert/ffaf44f7b04b25d197aa6244d3fe4a6b.png)

![image.png](https://img-blog.csdnimg.cn/img_convert/df60269b47ddcdfcc036ff0f4de17c75.png)

### 提供某种技术从逻辑上对内存空间进行扩充

GTA超过60GB，电脑内存才为4GB，如何将游戏顺利运行

- 覆盖技术：解决程序大小超过物理内存总和的问题，将程序分为多个段。内存中分为一个“固定区”和若干个“覆盖区”。常用的段常驻内存“固定区”，运行结束前不再调出；不常用的段在需要时调入内存“覆盖区”，需要时调入内存，不需要时调出内存。必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。
- 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存（保留进程的PCB），把内存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。
  - 应该在外存（磁盘）的什么位置保存被换出的进程？具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的I/O速度比文件区的更快。
  - 什么时候应该交换？交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。
  - 应该换出哪些进程？**可优先换出阻塞进程**；**可换出优先级低的进程**；**为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间**…（PCB会常驻内存，不会被换出外存）

### 提供地址转换功能，负责程序的逻辑地址和物理地址的转换

编程时，程序员应关注于指令、数据的逻辑地址，操作系统应负责逻辑地址到物理地址的转换（地址重定位）

- 绝对装入——编译时产生绝对地址——单道程序阶段
- 可重定位装入——装入时将逻辑地址转换为物理地址——早期的多道批处理操作系统
- 动态运行装入——运行时将逻辑地址转换为物理地址，需设置**重定位寄存器**——现代操作系统

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210213203317828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoYW5neGluZ3lh,size_16,color_FFFFFF,t_70)

![image.png](https://img-blog.csdnimg.cn/img_convert/bc3834a8f816e91de4117250e64fbea5.png)

![image.png](https://img-blog.csdnimg.cn/img_convert/7b9467c2336cf9de7ab193c149d3834f.png)

![image.png](https://img-blog.csdnimg.cn/img_convert/df60269b47ddcdfcc036ff0f4de17c75.png)

### 提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰

防止进程访问内存中任何位置

- 在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。
- 采用重定位寄存器和界地址寄存器进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址

### 小计

非连续页式：逻辑地址计算得到页号和页内偏移量，通过页表寄存器找到页表，页表找到页号对应的页框号，页框号+页内偏移量的到物理地址。

非连续段式：逻辑地址计算得到段号和段内地址，通过段表寄存器找到段表，段表找到段长和基址，判断段内地址是否超过段长，段基址+段内地址得到物理地址。

非连续段页式：逻辑地址计算得到段号、页号、页内偏移量，通过段表寄存器找到段表，段表找到页表长度和页表存放块号，检查页号是否越界，根据页表找到页框号，页框号+页内偏移量的到物理地址。

连续：重定位寄存器记录物理地址和逻辑地址。