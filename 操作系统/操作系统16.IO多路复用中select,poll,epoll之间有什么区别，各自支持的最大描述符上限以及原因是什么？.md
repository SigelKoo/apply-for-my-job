# IO多路复用中select,poll,epoll之间有什么区别

### IO多路复用

#### BIO的缺陷

BIO中的B是Blocking阻塞的意思

使用`bind`绑定端口号之后会监听`listen`该端口，等待`accept`事件，`accept`会阻塞当前线程

当我们收到`accept`事件的时候，程序就会拿到客户端与当前服务端连接的`socket`

针对`socket`我们可以进行读写，但是`socket`读写都是会阻塞当前线程的。

一般我们会有使用多线程方式进行c/s交互，但是这样很难做到C10K（1W个客户端就需要和服务端用1W个线程支持，这样的话CPU肯定就爆炸了，同时线程上下文切换也会把机器负载给拉飞。）

#### NIO解决C10K问题

站在java角度去看，NIO包提供了一套非阻塞的接口，这样就不需要我们为每一个C/S长连接保留一个单独的处理线程了。

NIO API具有非阻塞的特性了，就可以用1个线程去检查n个socket。在 java 层面，nio提供了一个这样的选择器`selector`

然后我们需要把需要检查的`socket`注册到这个`selector`中，然后主线程阻塞在`selector`的`select`方法中。

当选择器发现某个`socket`就绪了，会唤醒主线程，然后可以通过`selector` 获取就绪状态的`socket` 进行相应的处理。

其实这里selector里面是native api，底层Jvm是调用系统调用去实现的。

