IO多路复用中select,poll,epoll之间有什么区别

### select

##### 函数格式

```c
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);
```

##### 两个结构体

1. struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即socket文件句柄集合。fd_set集合可以通过一些宏由人为来操作，比如清空集合`FD_ZERO(fd_set *)`，将一个给定的文件描述符加入集合之中`FD_SET(int, fd_set*)`，将一个给定的文件描述符从集合中删除`FD_CLR(int, fd_set*)`，检查集合中指定的文件描述符是否可以读写 `FD_ISSET(int, fd_set* )`。

2. struct timeval是一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个是毫秒数。

   ```c
   struct timeval {
       long tv_sec;     /* seconds */
       long tv_usec;    /* and microseconds */
   };
   ```

##### 参数

int maxfdp是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1。

fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，若超出 timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。

fd_set *writefds 是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出 timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。

fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常。

struct timeval *timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态，第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

##### 返回值

负值：select错误  

正值：某些文件可读写或出错  

0：等待超时，没有可读写或错误的文件

##### 流程

1. 通过FD_SET将服务器的socket描述符添加到fd_set中
2. 通过FD_ISSET判断服务器socket描述符状态，如果为可读，则代表有客户端接入。此时进行socket连接，并得到客户端连接的socket描述符
3. 将客户端连接的socket描述符保存在clientSockFds中
4. 通过FD_SET将客户端的socket描述符添加到fd_set中
5. 在handle函数中遍历clientSockFds中所有的客户端socket描述符，并通过FD_ISSET判断客户端是否发送数据

### 劣势

![img](https://img2018.cnblogs.com/blog/1183125/201809/1183125-20180916151840053-1632130815.png)

1. 使用copy_from_user从用户空间拷贝fd_set到内核空间
2. 注册回调函数__pollwait
3. 遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）
4. 以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。
5. __pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk->sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。
6. poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。
7. 如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。
8. 把fd_set从内核空间拷贝到用户空间

select的几大缺点：

1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

3. select支持的文件描述符数量太小了，默认是1024/2048

### epoll区别

对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。

对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。

对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048，举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

总结：

1. select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

2. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

### epoll

##### 函数

```c
int epoll_create(int size); 
```

创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大。这个参数不同于 select() 中的第一个参数，给出最大监听的 fd+1 的值。需要注意的是，当创建好 epoll 句柄后，它就是会占用一个 fd 值，在 linux 下如果查看 /proc/ 进程 id/fd/ ，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致 fd 被耗尽。 

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
```

epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。 

int epfd 参数是 epoll_create() 的返回值， 

int op参数表示动作，用三个宏来表示： 

- EPOLL_CTL_ADD ：注册新的 fd 到 epfd 中； 
- EPOLL_CTL_MOD ：修改已经注册的 fd 的监听事件； 
- EPOLL_CTL_DEL ：从 epfd 中删除一个 fd ； 

int fd参数是需要监听的 fd ， 

struct epoll_event *event参数是告诉内核需要监听什么事， struct epoll_event 结构如下： 

```c
struct epoll_event {
    __uint32_t events; /* Epoll events */ 
    epoll_data_t data; /* User data variable */ 
}; 
```

events 可以是以下几个宏的集合： 

EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）； 

EPOLLOUT ：表示对应的文件描述符可以写； 

EPOLLPRI ：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； 

EPOLLERR ：表示对应的文件描述符发生错误； 

EPOLLHUP ：表示对应的文件描述符被挂断； 

EPOLLET ：将 EPOLL 设为边缘触发 (Edge Triggered) 模式，这是相对于水平触发 (Level Triggered) 来说的。 

EPOLLONESHOT ：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里 

```c
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
```

等待事件的产生，类似于 select() 调用。参数 events 用来从内核得到事件的集合，maxevents 告之内核这个 events 有多大，这个 maxevents 的值不能大于创建 epoll_create() 时的 size ，参数 timeout 是超时时间（毫秒， 0 会立即返回， -1 将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回 0 表示已超时。 epoll有两种工作方式：

LT level triggered 水平触发模式

同时支持阻塞和非阻塞的socket。在这种模式中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行I/O操作，如果你不做任何操作，还是会继续通知你。（没处理这个流还是一直通知你）

ET edge triggered 边缘触发模式

只支持非阻塞的socket。效率比LT高。这种工作模式下，当从epoll_wait调用获取到事件后，如果没有把这次事件对应的套接字处理完，那么在这个套接字中没有心的时间再次到来时，ET模式下是无法再次从epoll_wait调用中获取这个事件的。而LT只要有数据就总可以获取。