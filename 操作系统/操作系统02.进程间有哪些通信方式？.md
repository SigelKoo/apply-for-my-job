# 进程间有哪些通信方式？

进程通信就是指进程之间的信息交换。

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法。

### 共享存储

两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。

操作系统只负责提供共享空间和同步互斥工具（如P、V操作）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201115172250977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMDQwNTU5,size_16,color_FFFFFF,t_70#pic_center)

- 基于数据结构的共享

  比如共享空间里只能放个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式

- 基于存储区的共享

  在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式

共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。

采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。

mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write()等操作。

（1）使用普通文件提供的内存映射：适用于任何进程之间；此时，需要打开或创建一个文件，然后再调用mmap()；典型调用代码如下： 

```c
fd=open(name, flag, mode);
if(fd<0)
        ...
        
	ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 
```
通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，我们将在范例中进行具体说明。 

（2）使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。


### 消息传递

进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201115172725164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMDQwNTU5,size_16,color_FFFFFF,t_70#pic_center)

- 直接通信方式，消息放入接收方的**消息队列**中
- 间接通信方式，消息先发到中间体（信箱）

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为是一个管道，接收进程可以独立地接收含有不同管道的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。消息队列与命名管道一样，每个数据块都有一个最大长度的限制。我们可以将每个数据块当作是一种消息类型（频道），发送和接收的内容就是这个类型（频道）对应的消息（节目），每个类型（频道）相当于一个独立的管道，相互之间互不影响。

![img](https://pic3.zhimg.com/80/v2-2c36c9f13e6e7c3f1e01543c839bd306_720w.jpg)

消息队列可以是一种消息链表。有足够的权限的线程可以往队列中放置消息，有足够读权限的线程可以从队列中取走消息。每个消息都是一个记录，它由发送者赋予一个优先级。在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。这根管道和FIFO是相反的，对于后者来说，除非读出者已经存在，否则现有写入者是没有意义的。

一个进程可以往某个队列中写入一些消息，然后终止，再让另外一个进程在以后某个时刻读出这些消息。我没说过消息队列具有随内核的持续性，这跟管道和FIFO不一样，当一个管道和FIFO的最后一次关闭发生时，仍然在该管或FIFO上的数据将被丢弃。

![img](https://pic2.zhimg.com/80/v2-5d04df079694ac7df5a2246904614825_720w.jpg)

### 消息队列和管道的对比

1. 匿名管道是跟随进程的，消息队列是跟随内核的，也就是说进程结束之后，匿名管道就死了，但是消息队列还会存在（除非显示调用函数销毁）

2. 管道是文件，管道内容是存放在内存上的，磁盘上的仅仅只是标识，消息队列是数据结构，存放在内存，访问速度快

3. 管道是数据流式存取，消息队列是数据块式存取

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);# 控制消息队列函数
int msgget(key_t key, int msgflg); # 创建消息队列，key值唯一标识该消息队列
int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);# 接收消息
int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);# 发送消息
```

### 管道通信

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201115172511529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMDQwNTU5,size_16,color_FFFFFF,t_70#pic_center)

1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。

2. 各进程要互斥地访问管道。

3. 数据以字符流的形式写入管道，当管道写满时，写进程的 write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。

4. 如果没写满，就不允许读。如果没读空，就不允许写。

5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

### 客户机服务器系统

- 套接字

  是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。

- 远程过程调用和远程方法调用

![img](https://img-blog.csdn.net/20180110165544751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGoxNTAxMDczNTU3Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



### 信号

信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。

1. 在目的进程中安装信号，需要提供一个信号处理函数。
2. 信号被某个进程产生。
3. 操作系统响应信号，在目的进程中被注册。（信号在目的进程中被注册，操作系统将添加信号到目的进程的PCB的未决信号数据结构中）
4. 信号在进程中注销，进程在执行信号处理函数之前，首先要把信号在进程中注销。
5. 信号生命终止，保护上下文，进程捕获信号，即执行信号处理函数。

### 信号量

信号量多用于进程间的同步与互斥，简单的说一下同步和互斥的意思

同步：处理竞争就是同步，安排进程执行的先后顺序就是同步，每个进程都有一定的个先后执行顺序

互斥：互斥访问不可共享的临界资源，同时会引发两个新的控制问题（互斥可以说是特殊的同步）

竞争：当并发进程竞争使用同一个资源的时候，我们就称为竞争进程


简单说一下信号量的工作机制（因为真的很简单），可以直接理解成计数器（当然其实加锁的时候肯定不能这么简单，不只只是信号量了），信号量会有初值（>0），每当有进程申请使用信号量，通过一个P操作来对信号量进行-1操作，当计数器减到0的时候就说明没有资源了，其他进程要想访问就必须等待（具体怎么等还有说法，比如忙等待或者睡眠），当该进程执行完这段工作（我们称之为临界区）之后，就会执行V操作来对信号量进行+1操作。

临界区：不是个简单的区域！是加锁区间的代码！

临界资源：只能被一个进程同时使用（不可以多个进程共享），要用到互斥

我们可以说信号量也是进程间通信的一种方式，比如互斥锁的简单实现就是信号量，一个进程使用互斥锁，并通知（通信）其他想要该互斥锁的进程，阻止他们的访问和使用

