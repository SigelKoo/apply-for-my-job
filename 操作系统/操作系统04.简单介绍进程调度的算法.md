# 简单介绍进程调度的算法


进程调度基本概念： 按某种算法选择一个进程将处理机分配给它

#### 需要进行进程调度与切换的情况

- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞（如：等待I/O）
- 当前运行的进程被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理（如：I/O中断）
  - 有更高优先级的进程进入就绪队列

#### 进程调度方式

- 非抢占式：只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
- 抢占式：当一个进程正在处理机上执行，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

#### 进程与作业

- 一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。
- 用户提交作业以后，当作业被调度，系统会为作业创建进程，一个进程无法完成时，系统会为这个进程创建子进程。
- 进程是一个程序在一个数据集上的一次执行，而作业是用户提交给系统的一个任务。

#### 先来先服务FCFS

- 算法规则：按作业/进程到达的先后顺序进行服务
- 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列
- 是否可抢占：非抢占式算法
- 优点：公平、算法实现简单
- 缺点：排在长作业/进程后的短作业用户体验不好；
- 是否会导致饥饿：不会
- **类似排队买奶茶**

#### 最短作业优先SJF/最短进程优先SPF

- 算法规则：最短的作业/进程优先得到服务
- 用于作业/进程调度：既可用于作业调度，也可用于进程调度
- 是否可抢占：非抢占式算法，也有抢占式的版本——最短剩余时间优先算法SRTN
- 优点：平均等待时间、平均周转时间最短
- 缺点：不公平，对短作业有利，对长作业不利；作业/进程是用户提出的并不一定真实
- 是否会导致饥饿：会

#### 高响应比优先HRRN

- 算法规则：综合考虑作业/进程的等待时间和要求服务的时间，每次调度时先计算各个作业/进程的响应比，响应比=(等待时间+要求服务时间) / 要求服务时间
- 用于作业/进程调度：既可用于作业调度，也可用于进程调度
- 是否可抢占：非抢占式算法
- 优点：综合考虑等待时间和运行时间；等待时间相同时，要求服务时间短的优先；要求服务时间相同时，等待时间长的优先；对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题
- 是否会导致饥饿：不会

#### 时间片轮转

- 算法规则：公平、轮流为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
- 用于作业/进程调度：用于进程调度（作业放入内存建立了相应进程后，才能被分配处理机时间片）
- 是否可抢占：抢占式算法，被强行剥离处理机使用权
- 优点：公平、响应快，适用于分时操作系统
- 缺点：由于高频率切换进程，有一定开销；不区分任务的紧急程度
- 是否会导致饥饿：不会
- **要考虑时间片大小**

#### 优先级

- 算法规则：调度时选择优先级最高的作业/进程
- 用于作业/进程调度：用于进程调度、作业调度、I/O调度
- 是否可抢占：抢占式、非抢占式都有
- 优点：优先区分紧急程度、重要程度，适用于实时操作系统。可灵活调整各种作业/进程偏好程度
- 缺点：可能导致饥饿
- 是否会导致饥饿：会

#### 多级反馈队列

- 算法规则：对其他调度算法的折中权衡。
  - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
  - 新进程到达先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，者重新返回该队列队尾
  - 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
- 用于作业/进程调度：用于进程调度
- 是否可抢占：抢占式
- 优点：拥有以上所有优点
- 缺点：可能导致饥饿
- 是否会导致饥饿：会


![img](https://bkimg.cdn.bcebos.com/pic/500fd9f9d72a6059d09c84e42334349b023bba44?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

# Linux进程调度中有哪些常见算法以及策略？

#### I/O 消耗型和 CPU 消耗型

运行的进程如果大部分来进行 I/O 的请求或者等待的话，这个进程称之为 I/O 消耗型。经常处于可以运行的状态，但是都只是运行一点点时间，绝大多数的时间都在处于阻塞（睡眠）的状态。

如果进程的绝大多数都在使用 CPU 做运算的话，那么这种进程称之为 CPU 消耗型，比如开启 Matlab 做一个大型的运算。没有太多的 I/O 需求，从系统响应的角度上来讲，调度器不应该经常让他们运行。对于处理器消耗型的进程，调度策略往往是降低他们的执行频率，延长运行时间。

#### 策略

Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做出了优化（缩短响应时间），更倾向于优先调度I/O消耗型进程。

在Linux中采用了两种不同的优先级范围。

第一种是：nice值，nice值越大说明优先级越低。在Linux中nice值代表的是时间片的比例。

第二种是实时优先级，任何实时进程的优先级都高于普通进程的优先级。就是说实时优先级和nice优先级是两个不同的范畴。

Linux是将使用比划分给进程。这样一来进程所获得的处理器时间其实是和系统负载密切相关的。这个比例进一步还会受到nice值的影响。nice作为权重将调整进程的时间使用比。高nice值低优先级进程将被赋予低权重。

在CFS调度器（完全公平调度算法），进程抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小。则新进程抢占。完全摒弃时间片而是分配给进程一个处理器使用比重，通过这种方式CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。



























