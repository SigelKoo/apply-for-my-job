# 简单介绍进程调度的算法


进程调度基本概念： 按某种算法选择一个进程将处理机分配给它

#### 需要进行进程调度与切换的情况

- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞（如：等待I/O）
- 当前运行的进程被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理（如：I/O中断）
  - 有更高优先级的进程进入就绪队列

#### 进程调度方式

- 非抢占式：只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
- 抢占式：当一个进程正在处理机上执行，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

#### 进程与作业

- 一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。
- 用户提交作业以后，当作业被调度，系统会为作业创建进程，一个进程无法完成时，系统会为这个进程创建子进程。
- 进程是一个程序在一个数据集上的一次执行，而作业是用户提交给系统的一个任务。

#### 先来先服务FCFS

- 算法规则：按作业/进程到达的先后顺序进行服务
- 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列
- 是否可抢占：非抢占式算法
- 优点：公平、算法实现简单
- 缺点：排在长作业/进程后的短作业用户体验不好；
- 是否会导致饥饿：不会
- **类似排队买奶茶**

#### 最短作业优先SJF/最短进程优先SPF

- 算法规则：最短的作业/进程优先得到服务
- 用于作业/进程调度：既可用于作业调度，也可用于进程调度
- 是否可抢占：非抢占式算法，也有抢占式的版本——最短剩余时间优先算法SRTN
- 优点：平均等待时间、平均周转时间最短
- 缺点：不公平，对短作业有利，对长作业不利；作业/进程是用户提出的并不一定真实
- 是否会导致饥饿：会

#### 高响应比优先HRRN

- 算法规则：综合考虑作业/进程的等待时间和要求服务的时间，每次调度时先计算各个作业/进程的响应比，响应比=(等待时间+要求服务时间) / 要求服务时间
- 用于作业/进程调度：既可用于作业调度，也可用于进程调度
- 是否可抢占：非抢占式算法
- 优点：综合考虑等待时间和运行时间；等待时间相同时，要求服务时间短的优先；要求服务时间相同时，等待时间长的优先；对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题
- 是否会导致饥饿：不会

#### 时间片轮转

- 算法规则：公平、轮流为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
- 用于作业/进程调度：用于进程调度（作业放入内存建立了相应进程后，才能被分配处理机时间片）
- 是否可抢占：抢占式算法，被强行剥离处理机使用权
- 优点：公平、响应快，适用于分时操作系统
- 缺点：由于高频率切换进程，有一定开销；不区分任务的紧急程度
- 是否会导致饥饿：不会
- **要考虑时间片大小**

#### 优先级

- 算法规则：调度时选择优先级最高的作业/进程
- 用于作业/进程调度：用于进程调度、作业调度、I/O调度
- 是否可抢占：抢占式、非抢占式都有
- 优点：优先区分紧急程度、重要程度，适用于实时操作系统。可灵活调整各种作业/进程偏好程度
- 缺点：可能导致饥饿
- 是否会导致饥饿：会

#### 多级反馈队列

- 算法规则：对其他调度算法的折中权衡。
  - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
  - 新进程到达先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，者重新返回该队列队尾
  - 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
- 用于作业/进程调度：用于进程调度
- 是否可抢占：抢占式
- 优点：拥有以上所有优点
- 缺点：可能导致饥饿
- 是否会导致饥饿：会


![img](https://bkimg.cdn.bcebos.com/pic/500fd9f9d72a6059d09c84e42334349b023bba44?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

# Linux进程调度中有哪些常见算法以及策略？

Linux进程在调度器中被分为三类：

1. **交互式进程**：大量的人机交互，所以会有大量的睡眠状态，等待用户操作。例如：编辑器，这类进程需要比较高的响应速度
2. **批处理进程**：这类进程需要大量的CPU资源，但是响应延迟可以忍受，比如：视频编码，算法
3. **实时进程**：对调度延迟要求最高。比如：视频播放

**在Linux中，线程和进程一视同仁，所以讲到进程调度，也包含了线程调度。**

Linux内核有两个调度类：**CFS和实时调度类。**

## CFS

CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据nice值来计算的。nice值的范围从 -20 到 +19，数值较低的nice值表示较高的相对优先级。具有较低nice值的任务，与具有较高nice值的任务相比，会得到更高比例的处理器处理时间。默认nice值为 0。

**为什么叫nice？当一个任务增加了它的nice，说明它的优先级降低了，进而对其他任务变得nice**

CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（nice值为 0），虚拟运行时间与实际物理运行时间是相同的。下面分析一下 CFS 调度程序是如何工作的。

假设有两个任务，它们具有相同的nice值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。

因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。

## 实时调度

采用 SCHED_FIFO 或 SCHED_RR 实时策略来调度的任何任务，与普通（非实时的）任务相比，具有更高的优先级。

Linux 采用两个单独的优先级范围，一个用于实时任务，另一个用于正常任务。实时任务分配的静态优先级为 0-99，而正常任务分配的优先级为 100-139。

这两个值域合并成为一个全局的优先级方案，其中较低数值表明较高的优先级。正常任务，根据它们的nice值，分配一个优先级；这里 -20 的nice值映射到优先级 100，而 +19 的nice值映射到 139。下图显示了这个方案。

![img](https://pic2.zhimg.com/80/v2-9b2237e98d46e825ee07acebe9019661_720w.jpg)

### CFS 性能

Linux CFS 调度程序釆用高效算法，以便选择运行下个任务。每个可运行的任务放置在红黑树上（这是一种平衡的、二分搜索树，它的键是基于虚拟运行时间的）。这种树如下图所示：

![img](https://pic4.zhimg.com/80/v2-d5580bfcf145ba594295e22525e09933_720w.jpg)

当一个任务变成可运行时，它被添加到树上。当一个任务变成不可运行时（例如，当阻塞等待 I/O 时），它从树上被删除。一般来说，得到较少处理时间的任务（虚拟运行时间较小）会偏向树的左侧；得到较多处理时间的任务会偏向树的右侧。

根据二分搜索树的性质，最左侧的结点有最小的键值；从 CFS 调度程序角度而言，这也是具有最高优先级的任务。由于红黑树是平衡的，找到最左侧结点会需要 `O(lgN)` 操作（这里 N 为树内结点总数）。不过，为高效起见，Linux 调度程序将这个值缓存在变量 rb_leftmost 中，从而确定哪个任务运行只需检索缓存的值。



























