# 简述Linux的IO模型

### Linux IO模型分类

- 阻塞 I/O
- 非阻塞 I/O
- I/O多路复用
- 信号驱动式I/O
- 异步I/O

**POSIX（可移植操作系统接口）把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO**

这里统一使用Linux下的系统调用recv作为例子，它用于从套接字上接收一个消息，因为是一个系统调用，所以调用时会从用户进程空间切换到内核空间运行一段时间再切换回来。默认情况下recv会等到网络数据到达并且复制到用户进程空间或者发生错误时返回，而第4个参数flags可以让它马上返回。

##### 阻塞I/O

使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。

![image](http://image.euphie.net/2017-09-24-23-18-01.png)

##### 非阻塞 I/O

改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场（回到用户进程空间），可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间（等着水将水杯装满），因此它还是同步IO。

![image](http://image.euphie.net/2017-09-24-23-19-53.png)

当一个应用进程循环调用recvfrom的时候，这种操作叫做轮询。应用进程轮询内核，检查某个操作是否准备就绪，当IO操作准备就绪可以操作的时候就会进行真正的IO操作，就是将数据从内核写入用户空间的过程。但是这样做会导致CPU的大量耗费。

##### I/O多路复用

这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据（网络数据到达内核）时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作（不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂），如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。

这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水（recv）。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。

![image](http://image.euphie.net/2017-09-24-23-21-54.png)

##### 信号驱动式I/O

通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数（在这里面调用recv）。D同学让舍管阿姨等有水的时候通知他（注册信号函数），没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO（省不了装水的时间啊）。

![image](http://image.euphie.net/2017-09-24-23-22-38.png)

##### 异步I/O

调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情（没有recv），这才是真正的异步IO。

![image](http://image.euphie.net/2017-09-24-23-23-36.png)

### 区别

![img](https://images2015.cnblogs.com/blog/1066890/201611/1066890-20161129014959615-1351089676.png)