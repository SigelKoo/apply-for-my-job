# 如何减少频繁分配内存（malloc或者new）造成的内存碎片

内存池（Memory Pool）是一种内存分配方式。通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

1. 针对特殊情况，例如需要频繁分配释放固定大小的内存对象时，不需要复杂的分配算法和多线程保护。也不需要维护内存空闲表的额外开销，从而获得较高的性能。
2. 由于开辟一定数量的连续内存空间作为内存池块，因而一定程度上提高了程序局部性，提升了程序性能。
3. 比较容易控制页边界对齐和内存字节对齐，没有内存碎片的问题。
4. 当需要分配管理的内存在100M一下的时候，采用内存池会节省大量的时间，否则会耗费更多的时间。
5. 内存池可以防止更多的内存碎片的产生
6. 更方便于管理内存

##### **数据结构**

为了能够分配大小可变的对象，显然我们需要管理空闲内存块，我们可以用一个链表把所有内存块链接起来，然后使用一个指针来记录当前空闲内存块的位置，如图所示：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/nQzmQv.png)

从图中我们可以看到，有两个空闲内存块，空闲内存之间使用链表链接起来，每个内存块都是前一个的2倍，也就是说，当内存池中的空闲内存不足以分配时我们就向malloc申请内存，只不过其大小是前一个的2倍：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/NRRF3i.png)

其次，我们有一个指针free_ptr，指向接下来的空闲内存块起始位置，当向内存池分配内存时找到free_ptr并判断当前内存池剩余空闲是否足够就可以了，有就分配出去并修改free_ptr，否则向malloc再次成倍申请内存。  

从这里的设计可以看出，我们的内存池其实是不会提供类似free这样的内存释放函数的，如果要释放内存，那么会一次性将整个内存池释放掉，这一点和通用的内存分配器是不一样。  

现在，我们可以分配内存了，还有一个问题是所有内存池设计不得不考虑的，那就是线程安全，这个话题你可以参考这里。  

##### **线程安全**

显然，内存池不应该局限在单线程场景，那我们的内存池要怎样实现线程安全呢？  

有的同学可能会说这还不简单，直接给内存池一把锁保护就可以了。  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/FV7J3e.png)

这种方法是不是可行呢？还是那句话，It depends，要看情况。  

如果你的程序有大量线程申请释放内存，那么这种方案下锁的竞争将会非常激烈，线程这样的场景下使用该方案不会有很好的性能。  

那么还有没有一种更好的办法吗？答案是肯定的。  

##### **线程局部存储**    

既然多线程使用线程池存在竞争问题，那么干脆我们为每个线程维护一个内存池就好了，这样多线程间就不存在竞争问题了。  

那么我们该怎样为每个线程维护一个内存池呢？  

线程局部存储，Thread Local Storage正是用于解决这一类问题的，什么是线程局部存储呢？  

简单说就是，我们可以创建一个全局变量，因此所有线程都可以使用该全局变量，但与此同时，我们将该全局变量声明为线程私有存储，那么这时虽然所有线程依然看似使用同一个全局变量，但该全局变量在每个线程中都有自己的副本，**变量指向的值是线程私有的**，相互之间不会干扰。  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/2y6bmi.png)

假设这个全局变量是一个整数，变量名字为global_value，初始值为100，那么当线程A将global_value修改为200时，线程B看到的global_value的值依然为100，只有线程A看到的global_value为200，这就是线程局部存储的作用。  

##### **线程局部存储+内存池**   

有了线程局部存储问题就简单了，我们可以将内存池声明为线程局部存储，这样每个线程都只会操作属于自己的内存池，这样就再也不会有锁竞争问题了。  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/ZBvuQr.png)

注意，虽然这里给出了线程局部存储的设计，但并不是说加锁的方案就比不上线程局部存储方案，还是那句话，一切要看使用场景，如果加锁的方案够用，那么我们就没有必要绞尽脑汁的去用其它方案，因为加锁的方案更简单，代码也更容易维护。  

还需要提醒的是，这里只是给出了内存池的一种实现方法，并不是说所有内存池都要这么设计，内存池可以简单也可复杂，一切要看实际场景，这一点也需要注意。  

##### **其它内存池形式**   

到目前为止我们给出了两种内存池的设计方法，第一种是提前创建出一堆需要的对象（数据结构），自己维护好哪些对象（数据结构）可用哪些已被分配；第二种可以申请任意大小的内存空间，使用过程中只申请不释放，最后一次性释放。这两种内存池天然适用于服务器端编程。  

最后我们再来介绍一种内存池实现技术，这种内存池会提前申请出一大段内存，然后将这一大段内存切分为大小相同的小内存块：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/2qUbe2.png)

然后我们自己来维护这些被切分出来的小内存块哪些是空闲的哪些是已经被分配的，比如我们可以使用栈这种数据结构，最初把所有空闲内存块地址push到栈中，分配内存是就pop出来一个，用户使用完毕后再push回栈里。  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/Zru2u2.png)

从这里的设计我们可以看出，这种内存池有一个限制，这个限制就是说**程序申请的最大内存不能超过这里内存块的大小**，否则不足以装下用户数据，这需要我们对程序所涉及的业务非常了解才可以。  

用户申请到内存后根据需要将其塑造成特定对象（数据结构）。  

关于线程安全的问题，可以同样采用线程局部存储的方式来实现：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/zUnAve.png)

**一个有趣的问题**   

除了线程安全，这里还有一个非常有趣的问题，那就是如果线程A申请的对象被线程B拿去释放，我们的内存池该怎么处理呢？  

这个问题之所以有趣是因为我们**必须知道该内存属于哪个线程的局部存储，但申请的内存本身并不能告诉你这样的信息**。  

有的同学可能会说这还不简单，不就是一个指针到另一个指针的映射吗，直接用map之类存起来就好了，但问题并没有这么简单，原因就在于如果我们切分的内存块很小，那么会存在大量内存块，这就需要存储大量的映射关系，有没有办法改进呢？  

改进方法是这样的，一般来说，我们申请到的大段内存其实是会按照特定大小进行内存对齐，我们假设总是按照4K字节对齐，那么该大段内存的起始地址后12个bit(4K = 2^12)为总是0，比如地址0x9abcd**000**，同时我们也假设申请到的大段内存大小也是4K：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/YnYVve.png)

那么我们就能知道该大段内存中的各个小内存块起始地址除了后12个bit位外都是一样的：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/6NjEBb.png)

这样拿到任意一个内存的地址我们就能知道对应的大段内存的起始地址，只需要简单的将后12个bit置为0即可，有了大段内存的起始地址剩下的就简单了，我们可以在大段内存中的最后保存对应的线程局部存储信息：  

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/ryuqM3.png)

**这样我们对任意一个内存块地址进行简单的位运算就可以得到对应的线程局部存储信息**，大大减少了维护映射信息对内存的占用。