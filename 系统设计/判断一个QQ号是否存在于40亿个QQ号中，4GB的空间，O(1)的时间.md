# 判断一个QQ号是否存在于40亿个QQ号中，4GB的空间，O(1)的时间

BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。

BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。

1. 给定长度是10的bitmap，每一个bit位分别对应着从0到9的10个整型数。此时bitmap的所有位都是0。

![img](https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190926194848387-75519815.png)

2. 把整型数4存入bitmap，对应存储的位置就是下标为4的位置，将此bit置为1。

![img](https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190926194935527-1855767191.png)

3. 把整型数2存入bitmap，对应存储的位置就是下标为2的位置，将此bit置为1。

![img](https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190926194945873-1660289774.png)

位图排序时，我们需要考虑：给出一个数，如何找到其对应位图的位置，方法就是首先找到该数对应的字节，然后在找到该数对应的位。例如一个QQ号是：983262245，则将bit的98326625位进行标记。bitset是C++提供的一种位集合的数据结构，它让我们可以像使用数组一样使用位，可以访问指定下标的bit位。因此将通过bitset容器进行存储42亿个qq号码。由于一个字节可以存放8个QQ号码，则4000000000/8/1014/1024 = 500.679Mb，内存合适，通过bit位下表来判断QQ号码是否存在。

#### 第二种做法

将40亿个qq按最高位分为0-9十类，将十类分别写到十个文件中，其中一个文件中数的个数都会小很多，进入要查询的次高位进行分为十类十个文件，以此类推，10logn时间复杂度可以找到