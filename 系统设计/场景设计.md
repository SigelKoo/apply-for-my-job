### 搜索引擎的实现，会用到哪些重要的数据结构

![image.png](https://ucc.alicdn.com/pic/developer-ecology/5564c53ad4fb4f92a852d998dbc2e4ba.png)

避免网页的重复爬取——布隆过滤器

![image.png](https://ucc.alicdn.com/pic/developer-ecology/e934194a7a684b5d93841adfc7589853.png)

爬取后将HTML代码标签去除，拿到纯内容

将内容分词，倒排索引，将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档以及PageRank等算法

查询时，维护一个词库，词库使用字典树，可以在很快的情况下出现下拉

热点信息可以使用小顶堆进行存储

### 设计实现一个HTTP代理服务器

基本原理：代理服务器作为真实服务器的一个代理端，客户端的请求信息不是直接发送到其真实请求的服务器而是发送到代理服务器，此时代理服务器是作为一个服务器，之后代理服务器通过解析客户端的请求信息，再向真实服务器发送请求报文，获得请求的信息，此时代理服务器是作为一个客户端。

使用代理服务器的好处是：1. 在请求客户端和真实服务器之间添加了一层，这样就可控的对于请求的响应报文做一些限制或者是改变，例如网站过滤、钓鱼网站等，使得响应到客户端的信息是代理服务器处理过的；2、还有就是请求报文先发送到代理服务器，这样代理服务器可以设立缓存，通过对请求报文解析后代理服务器可以通过查找本地缓存，如果有缓存好的，并且通过向服务器发送是否更新的信息后得到没有修改后就可以直接从代理服务器将响应报文返回给客户端，这样减少了服务端的负载，减少了流量。

### 实现一个web服务器

以FTP服务器为例

首先创建一个服务器socket，然后bind地址，listen监听，然后把socket加入多路转接监听链表。当有连接到达的时候，我们对socket调用accept，返回一个已连接套接字描述符，然后根据用户传输过来的文件名去查找文件，读取文件内容并回送给用户。

accept之后创建一个线程，如果使用线程池的话就从池中取一个空闲线程，然后把已连接文件描述符传给这个线程，然后让线程去处理这个用户请求，一个线程处理一个用户请求。

### 设计一个cache缓存web服务器的网页访问记录

用队列，根据last visited排序，先进先出；队列每一个元素包含键值两部分，值就是访问的记录。再用一个hash表保存键值，这个值是指向队列元素的指针。

### 把一个文件快速下发到100w个服务器

IPFS模型，P2P下载方式，下载好的主机同样可以作为服务器发送给其他客户端。将数据分片，不同片給不同的hash，bittorrent swap交换协议，存储have_list和want_list，将别人want_list没有的，而自己have_list有的进行传输交换。（别人have_list有的，而自己want_list没有的进行交换）

### 将微信用户分为两组，组内的微信用户互相不为好友

https://www.sohu.com/a/106452919_211120

图分割的问题，组内没有边，组间有边。这就是一个 **二分图**。

根据二分图的特性，一条边上的两个点，肯定是属于不同的组。如果它们出现在同一个组中，肯定就不是二分图了。怎么判断，一条边上的两个点，分属于不同的组呢？我们需要遍历图，如果找到一条边，两个节点，都在同一组，则不是二分图；如果图遍历完成之后，没有找到这样的边，则是二分图。我们在遍历的过程中，我们需要区分，一条边的两个节点分属于不同的组，这里我们用到了染色法。

**从某一个点开始，将这个节点染色为白色，并且开始广度优先遍历，找到与其相邻的节点，如果是二分图，相邻节点的颜色都应该不同。如果是黑色，则不变；如果是无色，则染成黑色；如果是白色，也就是同色，程序退出。当图遍历完毕时，没有相邻节点同色的，则是二分图，标记为白色和黑色的两组就是一个划分。**

例：用户{1,2,3,4}，好友关系：1-2， 2-3， 3-4，4-1，划分：{1, 3}{2, 4}

<img src="http://n1.itc.cn/img8/wb/recom/2016/07/18/146884159483307448.JPEG" alt="img" style="zoom:25%;" />

队列空，结束遍历。找到划分{1,3}白{2,4}黑。

用户{1，2，3，4} 关系：1-2，1-3，1-4，2-3，3-4.

<img src="http://n1.itc.cn/img8/wb/recom/2016/07/18/146884159499262982.JPEG" alt="img" style="zoom:25%;" />

### 朋友之间的点对点关系用图维护，怎么判断两人是否是朋友；求朋友圈的个数

已知，有n个人和m对好友关系（存于一个集合r中），如果两个人是直接的或者间接的好友（好友的好友的好友...），那么他们属于一个集合，就是一个朋友圈里的

- 并查集

将N个不同的元素分成互不相交的集合，然后按照规律将两个集合进行合并

1. 首先我们建立n个大小的数组，分别代表人的序号，将数组的所有值初始化为 -1 ，代表各自属于各自的集合

2. 根据 集合r 对数组元素的值进行修改

   比如 {0,6}

   将a[0] 的值加上 a[6]的值

   然后将a[6]所存的值改为 a[0]的下标 0

   <img src="https://img-blog.csdn.net/20170306202244192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE4Mjg1MTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom: 50%;" />

   <img src="https://img-blog.csdn.net/20170306203217711?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE4Mjg1MTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:50%;" />

   如果0和4产生了关系，{0,4}

   那么找到4的根（为1），将a[1]的值加到a[0]上，然后将a[1]的值改为a[0]的下标0

   <img src="https://img-blog.csdn.net/20170306203350787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE4Mjg1MTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:50%;" />

   <img src="https://img-blog.csdn.net/20170306203332693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE4Mjg1MTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:50%;" />

### XX市有多少钢琴调音师傅？

费米估算

芝加哥当前人口数量（1930 —— 1950 年，略超过300 万）、
每家平均几口人（2 或3）、
家庭平均拥有的需要定期调音的钢琴数量（10 家里最多1 家，但30 家至少有1 家）、
每部钢琴需要调音的频率（也许平均1 年1 次）、
一个调音师平均每天能调多少部钢琴（4 —— 5 部，包括交通时间）、
一年工作多少天（约250 天）

芝加哥调音师的数量 = 人口 / 每家人口 × 有钢琴的家庭百分比 × 每年调音次数/ （调音师每天调音的钢琴数 × 年工作天数）

### 范围1到1000的数，原本有1000个，互不重复，现多出来1个重复的数，怎么找到它

求和相减，把给定的 1001个数相加的和减去（1+2+…+1000）即可得到答案

### 1-100顺序排列，丢失了一个怎么找到

二分法，比如第一次的话，你取arr[50]，看看是不是50，如果是，说明缺失的数在后面，如果是49，则缺失的数在[0-49]位置，包括49，依次类推即可

### 先手必胜策略问题

N个糖果，每次只能取1个到6个，不能不取，你先取，请问是否有必胜策略，怎么取。

每次取到只剩7的倍数个糖果即可。因为剩下的为7的倍数时可以保证对方不能一次性取完。当取到最后剩下7个时，对方不能取完，然后自己可以取完。

摆象棋的先手必胜策略，每个人每轮摆一个，直到某一个人不能在空白的地方继续放下，就算输，那么你有必胜的方法吗,

第一个人摆在正中心(同心圆)，然后不管第二个人怎么摆，第一个人都和他玩中心对称。

### 四辆小车 每辆车加满油可以走一公里

1. 先一起走
2. 走一段路程 s 之后，任选一辆车，把剩余的油全分给其余的车，加满
3. 重复步骤二，直到最后一辆车没油

## 两个大文件存url，找相同url，两个50亿url文件，找到相同url，内存4g

假如每个url大小为10bytes，那么可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。

Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0，a1，...，a999，每个小文件约300M）；

Step2：遍历文件b，采取和a相同的方式将url分别存储到1000个小文件（记为b0，b1，...，b999）；

巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件（a0 vs b0，a1 vs b1，...，a999 vs b999）中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。

Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

### 如何判断一个图是否连通？

并查集

### 洗牌发牌算法

每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。

在54张牌中随机选一张，将这张牌与第一张交换顺序

![img](https://pic2.zhimg.com/80/v2-10187efcf3f496f55f7b5de35b643cdd_720w.jpg)

在剩下的53张中继续随机选取一张与第二张牌进行交换

![img](https://pic2.zhimg.com/80/v2-1053b6815bf7d66e9de0381e963a28c1_720w.jpg)

直至最后一张。

![img](https://pic1.zhimg.com/80/v2-4d8149f2c38053c4cd01263f85845324_720w.png)

对于arr[i]，洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）

在n-2个位置概率是[(n-1)/n] * [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））

在第n-k个位置的概率是[(n-1)/n] * [(n-2)/(n-1)] *...* [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n

### 给你1MB的内存，你们怎么设计， 才能使其利用率最高，产生的碎片最少

采用分页法，1MB的内存，每4KB为单位进行，设置一个映射表，非连续性分配。最坏的情况，只有一个4KB产生碎片。

### 判断一个QQ号是否存在于40亿个QQ号中，4GB的空间，O(1)的时间

BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。

BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。

1. 给定长度是10的bitmap，每一个bit位分别对应着从0到9的10个整型数。此时bitmap的所有位都是0。

![img](https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190926194848387-75519815.png)

2. 把整型数4存入bitmap，对应存储的位置就是下标为4的位置，将此bit置为1。

![img](https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190926194935527-1855767191.png)

3. 把整型数2存入bitmap，对应存储的位置就是下标为2的位置，将此bit置为1。

![img](https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190926194945873-1660289774.png)

位图排序时，我们需要考虑：给出一个数，如何找到其对应位图的位置，方法就是首先找到该数对应的字节，然后在找到该数对应的位。例如一个QQ号是：983262245，则将bit的98326625位进行标记。bitset是C++提供的一种位集合的数据结构，它让我们可以像使用数组一样使用位，可以访问指定下标的bit位。因此将通过bitset容器进行存储42亿个qq号码。由于一个字节可以存放8个QQ号码，则4000000000/8/1014/1024 = 500.679Mb，内存合适，通过bit位下表来判断QQ号码是否存在。

### 从50亿的整数集合里找出中位数