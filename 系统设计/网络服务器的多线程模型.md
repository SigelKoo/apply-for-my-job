# 非Reactor模式的进程/线程模型

## 单进程单线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8b282b1937ba~tplv-t2oaga2asx-watermark.awebp)

这种模型所有的逻辑都在在一个进程中，包括建立连接->Read 连接上的数据->业务处理->Write 回一些数据然后一直循环下去。该模型一次只能处理一个连接，这个在真正的应用中是没有的。

## 单进程多线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8b0804b1a47c~tplv-t2oaga2asx-watermark.awebp)

进程只做建立连接的动作，每接收一个连接就创建一个线程，在此连接上的读->业务处理->写->关闭连接都在线程中去做，可以采用线程池的方式减少线程的创建和销毁。

优点：可以同时与多个 Client 建立连接，接收连接和处理连接业务分开。

缺点：每个连接占用一个线程，当连接上没有数据的时候造成线程资源浪费，可以建立的连接数比较有限。

## 多进程单线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8a0c89aa6902~tplv-t2oaga2asx-watermark.awebp)

主进程启动时创建监听套接字并监听，然后fork出N个子进程。由于父子进程的继承性，子进程同时也在端口监听，然后在父进程中关闭监听。父进程负责子进程的创建、销毁、资源回收等，子进程负责连接的建立->Read->业务处理->Write 等。

缺点：这种模型是单进程单线程的进化版本，然而并没有什么卵用。且增加了开发的难度。所以不列出它的优点，介绍这种模型主要是引出惊群的概念，在后面的 Reactor 模型中的多进程情况下也会出现类似的情况。

# Reactor模式的进程/线程模型

Reactor设计模式是一种为处理并发服务请求，并将请求提交到一个或多个服务处理程序的事件设计模式。

## 单进程单线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8a24e92c1553~tplv-t2oaga2asx-watermark.awebp)

只有一个进程，监听套接字和连接套接字上的事件都由 Select 来处理。如果有建立连接的请求过来，Acceptor 负责接受并与之建立连接，同时将连接套接字加入Select进行监听；如果某个连接上有读事件则进行Read->业务处理->Write等操作；如此循环反复。

优点：编程简单，对于业务处理不复杂的后台，基本能满足服务器端网络编程。

缺点：会有阻塞，在进行业务处理的时候不能进行其他操作：如建立连接，读取其他套接字上的数据等。

## 单进程多线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8a2e67bd5207~tplv-t2oaga2asx-watermark.awebp)

与单进程单线程类似，不同的是该模型将业务处理放在线程中，进程就不会阻塞在业务处理上。

优点：比较完美的进程/线程模型。

## 多进程单线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8a34fffe2cb6~tplv-t2oaga2asx-watermark.awebp)

与非Reactor模式中的多进程单线程相似，只是本模式在子进程中使用了IO多路复用，实用性以下就上来了。大名鼎鼎的nginx就采用这种进程/线程模型

优点：编程相对简单，充分利用多核。能满足高并发，不然 nginx 也不可能采用这种模式。

缺点：子进程还是会阻塞在业务处理上。

## 多进程多线程

子进程上将业务处理交给多线程处理，参考单进程多线程里的线程池那里。

优点：充分利用多核同时子进程不会阻塞在业务处理上

缺点：编程复杂。

## 主从进程+多线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/4/169e8a4060a78f5d~tplv-t2oaga2asx-watermark.awebp)

描述：前面几种Reactor模式的进程/线程模型中，连接的建立和连接的读写都是在同一进程中。本模型中将连接的建立和连接读写放在不同的进程中。

(1) 主进程在监听套接字上select阻塞，一旦有请求过来则与之建立连接，并将连接套接字传递给从进程。

(2) 从进程在连接套接字上select阻塞，一旦连接上有数据过来则进行Read，并将业务处理通过线程来处理。如果有必要还会向连接 Write 数据。

优点：连接的建立和连接的读写分开在不同进程中，处理效率会更高。该模型比单进程多线程模式还更优一点，且也可以利用多核。

缺点：编程复杂。

# 线程池的实现

大多数的网络服务器，包括Web服务器都具有一个特点，就是单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的。在传统的多线程服务器模型中是这样实现的：一旦有个请求到达，就创建一个新的线程，由该线程执行任务，任务执行完毕之后，线程就退出。这就是"即时创建，即时销毁"的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数非常频繁，那么服务器就将处于一个不停的创建线程和销毁线程的状态。这笔开销是不可忽略的，尤其是线程执行的时间非常非常短的情况。

线程池就是为了解决上述问题的，它的实现原理是这样的：在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。

## go实现

真正意义上的并发处理请求

思想：领导 ----> 工人 ----> 任务

领导便是协程池，工人便是一个个协程，任务就是工人要做的事

通过一个二级通道实现高并发控制

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201210163513536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prd2FuZ2E=,size_16,color_FFFFFF,t_70)

```go
package main

import (    
	"fmt"    
	"runtime"
    	"time"
)

//任务
type Job interface {
    Do()//do something...
}

//----------------------------------------------
//worker 工人
type Worker struct {
    JobQueue chan Job   //任务队列
    Quit     chan bool //停止当前任务
}

//新建一个 worker 通道实例   新建一个工人
func NewWorker() Worker {
    return Worker{
            JobQueue: make(chan Job), //初始化工作队列为null
            Quit:     make(chan bool),
    }
}

/*
整个过程中 每个Worker(工人)都会被运行在一个协程中，
在整个WorkerPool(领导)中就会有num个可空闲的Worker(工人)，
当来一条数据的时候，领导就会小组中取一个空闲的Worker(工人)去执行该Job，
当工作池中没有可用的worker(工人)时，就会阻塞等待一个空闲的worker(工人)。
每读到一个通道参数 运行一个 worker
*/

func (w Worker) Run(wq chan chan Job) {
    //这是一个独立的协程 循环读取通道内的数据，
    //保证 每读到一个通道参数就 去做这件事，没读到就阻塞
    go func() { 
               for {         
                   wq <- w.JobQueue //注册工作通道  到 线程池
                   select {            
                   case job := <-w.JobQueue: //读到参数                
                   	job.Do()
                   case <-w.Quit: //终止当前任务                
                   	return
                   }                                       
             }    
     }()
}

//----------------------------------------------
//workerpool 领导
type WorkerPool struct {
    workerlen   int      //线程池中  worker(工人) 的数量    
    JobQueue    chan Job //线程池的  job 通道    
    WorkerQueue chan chan Job
}

func NewWorkerPool(workerlen int) *WorkerPool {
    return &WorkerPool{        
    	workerlen:   workerlen,//开始建立 workerlen 个worker(工人)协程        
    	JobQueue:    make(chan Job), //工作队列 通道        
    	WorkerQueue: make(chan chan Job, workerlen), //最大通道参数设为 最大协程数 workerlen 工人的数量最大值    
    }
}

//运行线程池
func (wp *WorkerPool) Run() {
    //初始化时会按照传入的num，启动num个后台协程，然后循环读取Job通道里面的数据，    
    //读到一个数据时，再获取一个可用的Worker，并将Job对象传递到该Worker的chan通道    
    fmt.Println("初始化worker")    
    for i := 0; i < wp.workerlen; i++ {
            //新建 workerlen 20万 个 worker(工人) 协程(并发执行)，每个协程可处理一个请求        
            worker := NewWorker()        //运行一个协程 将线程池 通道的参数  传递到 worker协程的通道中 进而处理这个请求        
            worker.Run(wp.WorkerQueue)
    }
    
    // 循环获取可用的worker,往worker中写job
    go func() { //这是一个单独的协程 只负责保证 不断获取可用的worker        
        for {            
        	select {            
        	case job := <-wp.JobQueue: //读取任务   
        	     //尝试获取一个可用的worker作业通道。
        	     //这将阻塞，直到一个worker空闲             
        	     worker := <-wp.WorkerQueue                
       		     worker <- job//将任务 分配给该工人            
       		}        
       	}    
     }()
}

//----------------------------------------------
type Dosomething struct {
    Num int
}

func (d *Dosomething) Do() {   
    fmt.Println("开启线程数：", d.Num)    
    time.Sleep(1 * 1 * time.Second)
}

func main() {
   
    //设置最大线程数    
    num := 100 * 100 * 20
    
    // 注册工作池，传入任务    
    // 参数1 初始化worker(工人)并发个数 20万个    
    p := NewWorkerPool(num)    
    p.Run()//有任务就去做，没有就阻塞，任务做不过来也阻塞
    
    //datanum := 100 * 100 * 100 * 100    //模拟百万请求    
    datanum := 100 * 100    
    go func() { //这是一个独立的协程 保证可以接受到每个用户的请求
            for i := 1; i <= datanum; i++ {
                sc := &Dosomething{Num: i}            
                p.JobQueue <- sc //往线程池 的通道中 写参数   每个参数相当于一个请求  来了100万个请求        
            }    
     }()
     
    for { //阻塞主程序结束   
    	fmt.Println("runtime.NumGoroutine() :", runtime.NumGoroutine())        
    	time.Sleep(2 * time.Second)
    }
    
}
```

# 网络请求中，服务器工作流程

## 网卡将接收到的信号转换成数字信息

到达服务器的网络包其本质是电信号或者光信号，接收信号的过程和客户端是一样的。

接收操作的第一步是网卡接收到信号，然后将其还原成数字信息。局域网中传输的网络包信号是由 1 和 0 组成的数字信息与用来同步的时钟信号叠加而成的，因此只要从中分离出时钟信号，然后根据时钟信号进行同步，就可以读取并还原出 1 和 0 的数字信息了。

信号的格式随传输速率的不同而不同，因此某些操作过程可能存在细微差异，例如 10BASE-T 的工作方式如图5 所示。首先从报头部分提取出时钟信号（图5 ①），报头的信号是按一定频率变化的，只要测定这个变化的频率就可以和时钟信号同步了。接下来，按照相同的周期延长时钟信号（图5 ②），并在每个时钟周期位置检测信号的变化方向（图5 ③）。图中用向上和向下的箭头表示变化方向，实际的信号则是正或负的电压，这里需要检测电压是从正变为负，还是从负变为正，这两种变化方向分别对应 0 和 1（图5 ④）。在图中，向上的箭头为 1，向下的箭头为 0，实际上是从负到正变化为 1，从正到负变化为 0。这样，信号就被还原成数字信息了（图6）。

![图5　服务器将接收到的电信号还原为数字信息](https://xmoyking.github.io/2018/03/22/http-request-in-server/5.png)

![图6　根据信号还原的数字信息](https://xmoyking.github.io/2018/03/22/http-request-in-server/6.png)

接下来需要根据包末尾的帧校验序列（FCS）来校验错误，即根据校验公式（以太网中使用 CRC-32 方式来计算）计算刚刚接收到的数字信息，然后与包末尾的 FCS 值进行比较。 FCS 值是在发送时根据转换成电信号之前的数字信息进行计算得到的，因此如果根据信号还原出的数字信息与发送前的信息一致，则计算出的 FCS 也应该与包末尾的 FCS 一致。如果两者不一致，则可能是因为噪声等影响导致信号失真，数据产生了错误，这时接收的包是无效的，因此需要丢弃（包的丢失会由 TCP 检测出来并重传，因此错误的包可以直接丢弃）。

当 FCS 一致，即确认数据没有错误时，接下来需要检查 MAC 头部中的接收方 MAC 地址，看看这个包是不是发给自己的。以太网的基本工作方式是将数据广播到整个网络上，只有指定的接收者才接收数据，因此网络中还有很多发给其他设备的数据在传输，如果包的接收者不是自己，那么就需要丢弃这个包。

到这里，接收信号并还原成数字信息的操作就完成了，还原后的数字信息被保存在网卡内部的缓冲区中。上面这些操作都是由网卡的 MAC 模块来完成的。

**网卡的MAC模块将网络包从信号还原为数字信息，校验 FCS 并存入缓冲区。**

在这个过程中，服务器的 CPU 并不是一直在监控网络包的到达，而是在执行其他的任务，因此 CPU 并不知道此时网络包已经到达了。但接下来的接收操作需要 CPU 来参与，因此网卡需要通过中断将网络包到达的事件通知给 CPU。

接下来，CPU 就会暂停当前的工作，并切换到网卡的任务。然后，网卡驱动会开始运行，从网卡缓冲区中将接收到的包读取出来，根据 MAC 头部的以太类型字段判断协议的种类，并调用负责处理该协议的软件。这里，以太类型的值应该是表示 IP 协议，因此会调用 TCP/IP 协议栈，并将包转交给它。

实际的工作过程因操作系统的不同而不同，大多数情况下，网卡驱动并不会直接调用协议栈，而是先切换回操作系统，然后再由操作系统去调用协议栈，由协议栈继续执行接收操作。

**网卡驱动会根据 MAC 头部判断协议类型，并将包交给相应的协议栈。**

## IP 模块的接收操作

当网络包转交到协议栈时，IP 模块会首先开始工作，检查 IP 头部。IP 模块首先会检查 IP 头部的格式是否符合规范，然后检查接收方 IP 地址，看包是不是发给自己的。当服务器启用类似路由器的包转发功能时（服务器操作系统中内置了可实现路由器功能的软件，只要启用这一功能，服务器就可以像路由器一样工作），对于不是发给自己的包，会像路由器一样根据路由表对包进行转发（服务器也可以启用类似防火墙的包过滤功能，这时，在包转发的过程中还会对包进行检查，并丢弃不符合规则的包）。

确认包是发给自己的之后，接下来需要检查包有没有被分片。检查 IP 头部的内容就可以知道是否分片，如果是分片的包，则将包暂时存放在内存中，等所有分片全部到达之后将分片组装起来还原成原始包；如果没有分片，则直接保留接收时的样子，不需要进行重组。到这里，我们就完成了包的接收。

接下来需要检查 IP 头部的协议号字段，并将包转交给相应的模块。例如，如果协议号为 06（十六进制），则将包转交给 TCP 模块；如果是 11（十六进制），则转交给 UDP 模块。这里我们假设这个包被交给 TCP 模块处理，然后继续往下看。

协议栈的 IP 模块会检查 IP 头部：

1) 判断是不是发给自己的；

2) 判断网络包是否经过分片；

3) 将包转交给TCP模块或UDP模块

## TCP模块如何处理连接包

前面的步骤对于任何包都是一样的，但后面的 TCP 模块的操作则根据包的内容有所区别。首先，我们来看一下发起连接的包是如何处理的。

当 TCP 头部中的控制位 SYN 为 1 时，表示这是一个发起连接的包（图7 ①）。这时，TCP 模块会执行接受连接的操作，不过在此之前，需要先检查包的接收方端口号，并检查在该端口上有没有与接收方端口号相同且正在处于等待连接状态的套接字。如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包（向客户端返回一个表示接收方端口不存在等待连接的套接字的 ICMP 消息）。

![图7　服务器的工作过程](https://xmoyking.github.io/2018/03/22/http-request-in-server/7.png)

如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方 IP 地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中，同时分配用于发送缓冲区和接收缓冲区的内存空间。然后生成代表接收确认的 ACK 号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口大小，并用这些信息生成 TCP 头部，委托 IP 模块发送给客户端(这个包只有 TCP 头部，没有数据)。

这个包到达客户端之后，客户端会返回表示接收确认的 ACK 号，当这个 ACK 号返回服务器后，连接操作就完成了。

这时，服务器端的程序应该进入调用 accept 的暂停状态，当将新套接字的描述符转交给服务器程序之后，服务器程序就会恢复运行。

如果收到的是发起连接的包，则 TCP 模块会

1) 确认 TCP 头部的控制位SYN；
2) 检查接收方端口号；
3) 为相应的等待连接套接字复制一个新的副本；
4) 记录发送方 IP 地址和端口号等信息。

## TCP模块如何处理数据包

接下来我们来看看进入数据收发阶段之后，当数据包（假设包中的数据为 HTTP 请求消息）到达时 TCP 模块是如何处理的（图7 ②）。

首先，TCP 模块会检查收到的包对应哪一个套接字。在服务器端，可能有多个已连接的套接字对应同一个端口号，因此仅根据接收方端口号无法找到特定的套接字。这时我们需要根据 IP 头部中的发送方 IP 地址和接收方 IP 地址，以及 TCP 头部中的接收方端口号和发送方端口号共 4 种信息，找到上述 4 种信息全部匹配的套接字。

找到 4 种信息全部匹配的套接字之后，TCP 模块会对比该套接字中保存的数据收发状态和收到的包的 TCP 头部中的信息是否匹配，以确定数据收发操作是否正常。具体来说，就是根据套接字中保存的上一个序号和数据长度计算下一个序号，并检查与收到的包的 TCP 头部中的序号是否一致。如果两者一致，就说明包正常到达了服务器，没有丢失。这时，TCP 模块会从包中提出数据，并存放到接收缓冲区中，与上次收到的数据块连接起来。这样一来，数据就被还原成分包之前的状态了（拼合数据块的操作在每次收到数据包时都会进行，而不是等所有数据全部接受完毕之后再统一拼合的）。

当收到的数据进入接收缓冲区后，TCP 模块就会生成确认应答的 TCP 头部，并根据接收包的序号和数据长度计算出 ACK 号，然后委托 IP 模块发送给客户端（在返回 ACK 号之前，会先等待一段时间，看看能不能和后续的应答包合并）。

收到的数据块进入接收缓冲区，意味着数据包接收的操作告一段落了。接下来，应用程序会调用 Socket 库的 read（图7 ③）来获取收到的数据，这时数据会被转交给应用程序。如果应用程序不来获取数据，则数据会被一直保存在缓冲区中，但一般来说，应用程序会在数据到达之前调用 read 等待数据到达，在这种情况下，TCP 模块在完成接收操作的同时，就会执行将数据转交给应用程序的操作。

然后，控制流程会转移到服务器程序，对收到的数据进行处理，也就是检查 HTTP 请求消息的内容，并根据请求的内容向浏览器返回相应的数据。

收到数据包时，TCP 模块会

1. 根据收到的包的发送方 IP 地址、发送方端口号、接收方 IP 地址、接收方端口号找到相对应的套接字；
2. 将数据块拼合起来并保存在接收缓冲区中；
3. 向客户端返回ACK。

## TCP 模块的断开操作

当数据收发完成后，便开始执行断开操作。这个过程和客户端是一样的。

在 TCP 协议的规则中，断开操作可以由客户端或服务器任何一方发起，具体的顺序是由应用层协议决定的。Web 中，这一顺序随 HTTP 协议版本不同而不同，在 HTTP1.0 中，是服务器先发起断开操作。

这时，服务器程序会调用 Socket 库的 close，TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端。当客户端收到这个包之后，会返回一个 ACK 号。接下来客户端调用 close，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作就完成了。HTTP1.1 中，是客户端先发起断开操作，这种情况下只要将客户端和服务器的操作颠倒一下就可以了。

无论哪种情况，当断开操作完成后，套接字会在经过一段时间后被删除。

## 将请求的 URI 转换为实际的文件名

Web 服务器中，read 获取的数据内容就是 HTTP 请求消息。服务器程序会根据收到的请求消息中的内容进行相应的处理，并生成响应消息，再通过 write 返回给客户端。请求消息包括一个称为“方法”的命令，以及表示数据源的 URI（文件路径名），服务器程序会根据这些内容向客户端返回数据，但对于不同的方法和 URI，服务器内部的工作过程会有所不同。

最简单的一种情况如图8 中的例子所示，请求方法为 GET，URI 为一个 HTML 文件名。这种情况只要从文件中读出 HTML 文档，然后将其作为响应消息返回就可以了。不过，按照 URI 从磁盘上读取文件并没有这么简单。如果完全按照 URI 中的路径和文件名读取，那就意味着磁盘上所有的文件都可以访问，Web 服务器的磁盘内容就全部暴露了，这很危险。因此，这里需要一些特殊的机制。

![图8　Web 的基本工作方式](https://xmoyking.github.io/2018/03/22/http-request-in-server/8.png)

Web 服务器公开的目录其实并不是磁盘上的实际目录，虚拟目录，而 URI 中写的就是在这个虚拟目录结构下的路径名。因此，当读取文件时，需要先查询虚拟目录与实际目录的对应关系，并将 URI 转换成实际的文件名后，才能读取文件并返回数据。

![图9　客户端看到的目录结构和实际目录结构是不同的](https://xmoyking.github.io/2018/03/22/http-request-in-server/9.png)

客户端看到的 Web 服务器目录是虚拟的，和实际的目录结构不同。Web 服务器内部会将实际的目录名和供外部访问的虚拟目录名进行关联。

```
/~user2/sub-user2/sample.html                    (1)

/home/user2/sub-user2/sample.html                (2)
```



于是，服务器就会根据上述路径从磁盘中读取相应的文件，然后将数据返回给客户端。

文件名转换是有特例的，比如 URI 中的路径省略了文件名的情况，这时服务器会读取事先设置好的默认文件名。例如在浏览器中输入如下网址。

```
http://www.glasscom.com/tone/
```

上面这个网址省略了文件名，服务器会在末尾添加默认文件名，如下。

```
http://www.glasscom.com/tone/index.html
```

在这个例子中，index.html 这个文件名是在服务器中设置好的，服务器会将它添加在目录名的后面。这个文件名是在 Web 服务器配置文件中设置的。尽管这个文件名可以任意设置，但一般来说会设置成类似 index.html、index.cgi、default.htm 等这样的文件名。

有些 Web 服务器程序还具有文件名改写功能，只要设置好改写的规则，当 URI 中的路径符合改写规则时，就可以将 URI 中的文件名改写成其他的文件名进行访问(例如 Web 服务器程序 Apache 就具有这样的功能)。当出于某些原因 Web 服务器的目录和文件名发生变化，但又希望用户通过原来的网址进行访问的时候，这个功能非常有用。

## 运行 CGI 程序

如果 URI 指定的文件内容为 HTML 文档或图片，那么只要直接将文件内容作为响应消息返回客户端就可以了。但 URI 指定的文件内容不仅限于 HTML 文档，也有可能是一个程序。在这个情况下，服务器不会直接返回文件内容，而是会运行这个程序，然后将程序输出的数据返回给客户端。Web 服务器可以启动的程序有几种类型，每种类型的具体工作方式有所区别，下面我们来看看 CGI 程序是如何工作的。

当需要 Web 服务器运行程序时，浏览器发送的 HTTP 请求消息内容会和访问 HTML 文档时不太一样，我们先从这里开始讲。Web 服务器运行程序时，一般来说浏览器会将需要程序处理的数据放在 HTTP 请求消息中发送给服务器。这些数据有很多种类，例如购物网站订单表中的品名、数量、发货地址等，搜索引擎中输入的关键字也是一个常见的例子。

总之，浏览器需要在发送给 Web 服务器的请求消息中加入一些数据。有两种加入数据的方法。一种是在 HTML 文档的表单中加上 method=”GET”，通过 HTTP 的 GET 方法，将输入的数据作为参数添加在 URI 后面发送给服务器。另一种方法是在 HTML 文档的表单中加上 method=”POST”，将数据放在 HTTP 请求消息的消息体（即头部字段之后的部分）中发送给服务器。

![图10　用HTTP 请求发送表单中输入的内容](https://xmoyking.github.io/2018/03/22/http-request-in-server/10.png)

收到请求消息之后，Web 服务器会进行下面的工作。首先，Web 服务器会检查 URI 指定的文件名，看一看这个文件是不是一个程序。这里的判断方法是在 Web 服务器中事先设置好的，一般是通过文件的扩展名来进行判断，例如将 .cgi、.php 等扩展名的文件设置为程序，当遇到这些文件时，Web 服务器就会将它们作为程序来对待。也可以设置一个存放程序的目录，将这个目录下的所有文件都作为程序来对待。此外，还可以根据文件的属性来进行判断。

如果判断要访问的文件为程序文件，Web 服务器会委托操作系统运行这个程序，然后从请求消息中取出数据并交给运行的程序(除了数据，还可以将请求消息的头部字段传递给程序)。如果方法为 GET，则将 URI 后面的参数传递给程序；如果方法为 POST，则将消息体中的数据传递给程序。

![图11　数据如何传递给 Web 服务器上运行的程序](https://xmoyking.github.io/2018/03/22/http-request-in-server/11.png)

Web 服务器程序在组装网络包、还原数据之后，会运行其中指定的程序（实际是委托操作系统来运行），然后将数据传递给已运行的程序。

接下来，运行的程序收到数据后会进行一系列处理，并将输出的数据返回给 Web 服务器。程序可以返回各种内容，如表示订单已接受的说明，或者按照关键字从数据库中搜索出的结果等。无论如何，为了将数据处理的结果返回给客户端，首先需要将它返回给 Web 服务器。这些输出的数据一般来说会嵌入到 HTML 文档中，因此 Web 服务器可以直接将其作为响应消息返回给客户端。输出数据的内容是由运行的程序生成的，Web 服务器并不过问，也不会去改变程序输出的内容(但可以添加一些 HTTP 消息的头部字段)。

## 返回响应消息

当服务器完成对请求消息的各种处理之后，就可以返回响应消息了。这里的工作过程和客户端向服务器发送请求消息时的过程相同。

首先，Web 服务器调用 Socket 库的 write，将响应消息交给协议栈。这时，需要告诉协议栈这个响应消息应该发给谁，但我们并不需要直接告知客户端的 IP 地址等信息，而是只需要给出表示通信使用的套接字的描述符就可以了。套接字中保存了所有的通信状态，其中也包括通信对象的信息，因此只要有描述符就万事大吉了。

接下来，协议栈会将数据拆分成多个网络包，然后加上头部发送出去。这些包中包含接收方客户端的地址，它们将经过交换机和路由器的转发，通过互联网最终到达客户端。